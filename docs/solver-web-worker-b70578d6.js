var y=Object.defineProperty;var k=(E,b,s)=>b in E?y(E,b,{enumerable:!0,configurable:!0,writable:!0,value:s}):E[b]=s;var u=(E,b,s)=>(k(E,typeof b!="symbol"?b+"":b,s),s);(function(){"use strict";var Sides=(s=>(s[s.UP=0]="UP",s[s.LEFT=1]="LEFT",s[s.FRONT=2]="FRONT",s[s.RIGHT=3]="RIGHT",s[s.BACK=4]="BACK",s[s.DOWN=5]="DOWN",s))(Sides||{});const getAllSides=()=>Object.keys(Sides).filter(s=>!isNaN(Number(s))).map(s=>Number(s)),getAdjacentSides=s=>Object.keys(Sides).filter(e=>!isNaN(Number(e))).map(e=>Number(e)).filter(e=>e!==s&&e!==getOppositeSide(s)),getOppositeSide=s=>{switch(s){case 0:return 5;case 5:return 0;case 1:return 3;case 3:return 1;case 2:return 4;case 4:return 2}};var Colors=(s=>(s[s.YELLOW=0]="YELLOW",s[s.ORANGE=1]="ORANGE",s[s.BLUE=2]="BLUE",s[s.RED=3]="RED",s[s.GREEN=4]="GREEN",s[s.WHITE=5]="WHITE",s))(Colors||{});const getOppositeColor=s=>{switch(s){case 2:return 4;case 4:return 2;case 3:return 1;case 1:return 3;case 0:return 5;case 5:return 0}},colorToStringMap=new Map;colorToStringMap.set(0,"y"),colorToStringMap.set(1,"o"),colorToStringMap.set(2,"b"),colorToStringMap.set(3,"r"),colorToStringMap.set(4,"g"),colorToStringMap.set(5,"w");const mapColorInitialsToString=s=>colorToStringMap.get(s),stringToColorMap=new Map;stringToColorMap.set("y",0),stringToColorMap.set("o",1),stringToColorMap.set("b",2),stringToColorMap.set("r",3),stringToColorMap.set("g",4),stringToColorMap.set("w",5);const mapStringInitialToColor=s=>stringToColorMap.get(s),E=class{constructor(e){u(this,"dimension");u(this,"stickers");u(this,"cubeletCounter");this.dimension=e,this.stickers=[],this.cubeletCounter=0}create(){if(E.cubeletsCreatorMap.has(this.dimension))return E.cubeletsCreatorMap.get(this.dimension);{let e=0;getAllSides().map(h=>{for(let f=0;f<this.dimension;++f)for(let S=0;S<this.dimension;++S)this.stickers.push({side:h,x:S,y:f,id:e++})});const o=this.extractCenters(),t=this.extractCorners(),r=this.extractEdges(),n=[...t,...r,...o];return E.cubeletsCreatorMap.set(this.dimension,n),n}}cubeletsMerger(e){const o={stickers:[],id:++this.cubeletCounter};return e.forEach(t=>{this.stickers.forEach((r,n,h)=>{r.side===t.side&&t.x===r.x&&t.y===r.y&&o.stickers.push(...h.splice(n,1))})}),o}extractEdges(){const e=this.dimension-1,o=[];for(let t=1;t<this.dimension-1;++t)o.push(this.cubeletsMerger([{side:Sides.FRONT,x:0,y:t},{side:Sides.LEFT,x:e,y:t}])),o.push(this.cubeletsMerger([{side:Sides.FRONT,x:e,y:t},{side:Sides.RIGHT,x:0,y:t}])),o.push(this.cubeletsMerger([{side:Sides.FRONT,x:t,y:0},{side:Sides.UP,x:t,y:e}])),o.push(this.cubeletsMerger([{side:Sides.FRONT,x:t,y:e},{side:Sides.DOWN,x:t,y:0}])),o.push(this.cubeletsMerger([{side:Sides.BACK,x:e,y:t},{side:Sides.LEFT,x:0,y:t}])),o.push(this.cubeletsMerger([{side:Sides.BACK,x:0,y:t},{side:Sides.RIGHT,x:e,y:t}])),o.push(this.cubeletsMerger([{side:Sides.BACK,x:t,y:0},{side:Sides.UP,x:e-t,y:0}])),o.push(this.cubeletsMerger([{side:Sides.BACK,x:t,y:e},{side:Sides.DOWN,x:e-t,y:e}])),o.push(this.cubeletsMerger([{side:Sides.RIGHT,x:t,y:0},{side:Sides.UP,x:e,y:e-t}])),o.push(this.cubeletsMerger([{side:Sides.RIGHT,x:t,y:e},{side:Sides.DOWN,x:e,y:t}])),o.push(this.cubeletsMerger([{side:Sides.LEFT,x:t,y:0},{side:Sides.UP,x:0,y:t}])),o.push(this.cubeletsMerger([{side:Sides.LEFT,x:t,y:e},{side:Sides.DOWN,x:0,y:e-t}]));return o}extractCenters(){const e=this.dimension-1,o=[];return this.stickers.filter(t=>t.x!==0&&t.x!==e&&t.y!==0&&t.y!==e).forEach(t=>{o.push({stickers:[t],id:++this.cubeletCounter})}),o}extractCorners(){const e=[],o=this.dimension-1;return e.push(this.cubeletsMerger([{side:Sides.FRONT,x:0,y:0},{side:Sides.UP,x:0,y:o},{side:Sides.LEFT,x:o,y:0}])),e.push(this.cubeletsMerger([{side:Sides.FRONT,x:o,y:0},{side:Sides.UP,x:o,y:o},{side:Sides.RIGHT,x:0,y:0}])),e.push(this.cubeletsMerger([{side:Sides.FRONT,x:0,y:o},{side:Sides.DOWN,x:0,y:0},{side:Sides.LEFT,x:o,y:o}])),e.push(this.cubeletsMerger([{side:Sides.FRONT,x:o,y:o},{side:Sides.DOWN,x:o,y:0},{side:Sides.RIGHT,x:0,y:o}])),e.push(this.cubeletsMerger([{side:Sides.BACK,x:0,y:0},{side:Sides.UP,x:o,y:0},{side:Sides.RIGHT,x:o,y:0}])),e.push(this.cubeletsMerger([{side:Sides.BACK,x:o,y:0},{side:Sides.UP,x:0,y:0},{side:Sides.LEFT,x:0,y:0}])),e.push(this.cubeletsMerger([{side:Sides.BACK,x:0,y:o},{side:Sides.DOWN,x:o,y:o},{side:Sides.RIGHT,x:o,y:o}])),e.push(this.cubeletsMerger([{side:Sides.BACK,x:o,y:o},{side:Sides.DOWN,x:0,y:o},{side:Sides.LEFT,x:0,y:o}])),e}};let CubeletsCreator=E;u(CubeletsCreator,"cubeletsCreatorMap",new Map);const b=class{constructor(e){u(this,"dimension");if(this.dimension=e,!b.faceRotatorMap.has(this.dimension)){const o=new Map;for(let t=0;t<this.dimension;++t){const r=this.createUpFaceClockwiseRotator(t),n=this.createLeftFaceClockwiseRotator(t),h=this.createFrontFaceClockwiseRotator(t),f=this.createRightFaceClockwiseRotator(t),S=this.createBackFaceClockwiseRotator(t),I=this.createDownFaceClockwiseRotator(t),A=new Map;A.set(Sides.UP,r.map(T=>this.faceStickerMapper(T))),A.set(Sides.LEFT,n.map(T=>this.faceStickerMapper(T))),A.set(Sides.FRONT,h.map(T=>this.faceStickerMapper(T))),A.set(Sides.RIGHT,f.map(T=>this.faceStickerMapper(T))),A.set(Sides.BACK,S.map(T=>this.faceStickerMapper(T))),A.set(Sides.DOWN,I.map(T=>this.faceStickerMapper(T))),o.set(t,A)}b.faceRotatorMap.set(this.dimension,o)}}rotate(e,o){const t=new RubiksCube({clone:e.getConfiguration()}),r=[];return b.faceRotatorMap.get(this.dimension).get(o.layer||0).get(o.side).forEach(n=>{o.counterClockwiseDirection?r.push({index:n.source,color:e.getColorOfIndex(n.destination)}):r.push({index:n.destination,color:e.getColorOfIndex(n.source)})}),t.setColorsOfIndexes(r),t}idMapper(e){let o=e.side*this.dimension*this.dimension;return o+=this.dimension*e.y,o+=e.x,o}faceStickerMapper(e){return{source:this.idMapper(e.source),destination:this.idMapper(e.destination)}}createSideLidClockwiseRotator(e){const o=[];for(let t=0;t<this.dimension*this.dimension;++t){const r=t%this.dimension,n=Math.floor(t/this.dimension),h=this.dimension-1-n,f=r;o.push({source:{side:e,x:r,y:n},destination:{side:e,x:h,y:f}})}return o}createUpFaceClockwiseRotator(e){this.dimension-1;const o=[];e===0&&o.push(...this.createSideLidClockwiseRotator(Sides.UP));for(let t=0;t<this.dimension;++t)o.push({source:{side:Sides.FRONT,x:t,y:e},destination:{side:Sides.LEFT,x:t,y:e}}),o.push({source:{side:Sides.LEFT,x:t,y:e},destination:{side:Sides.BACK,x:t,y:e}}),o.push({source:{side:Sides.BACK,x:t,y:e},destination:{side:Sides.RIGHT,x:t,y:e}}),o.push({source:{side:Sides.RIGHT,x:t,y:e},destination:{side:Sides.FRONT,x:t,y:e}});return o}createLeftFaceClockwiseRotator(e){const o=this.dimension-1,t=[];e===0&&t.push(...this.createSideLidClockwiseRotator(Sides.LEFT));for(let r=0;r<this.dimension;++r)t.push({source:{side:Sides.FRONT,x:e,y:r},destination:{side:Sides.DOWN,x:e,y:r}}),t.push({source:{side:Sides.DOWN,x:e,y:r},destination:{side:Sides.BACK,x:o-e,y:o-r}}),t.push({source:{side:Sides.BACK,x:o-e,y:o-r},destination:{side:Sides.UP,x:e,y:r}}),t.push({source:{side:Sides.UP,x:e,y:r},destination:{side:Sides.FRONT,x:e,y:r}});return t}createFrontFaceClockwiseRotator(e){const o=this.dimension-1,t=[];e===0&&t.push(...this.createSideLidClockwiseRotator(Sides.FRONT));for(let r=0;r<this.dimension;++r)t.push({source:{side:Sides.UP,x:r,y:o-e},destination:{side:Sides.RIGHT,x:e,y:r}}),t.push({source:{side:Sides.RIGHT,x:e,y:r},destination:{side:Sides.DOWN,x:o-r,y:e}}),t.push({source:{side:Sides.DOWN,x:o-r,y:e},destination:{side:Sides.LEFT,x:o-e,y:o-r}}),t.push({source:{side:Sides.LEFT,x:o-e,y:o-r},destination:{side:Sides.UP,x:r,y:o-e}});return t}createRightFaceClockwiseRotator(e){const o=this.dimension-1,t=[];e===0&&t.push(...this.createSideLidClockwiseRotator(Sides.RIGHT));for(let r=0;r<this.dimension;++r)t.push({source:{side:Sides.UP,x:o-e,y:r},destination:{side:Sides.BACK,x:e,y:o-r}}),t.push({source:{side:Sides.BACK,x:e,y:o-r},destination:{side:Sides.DOWN,x:o-e,y:r}}),t.push({source:{side:Sides.DOWN,x:o-e,y:r},destination:{side:Sides.FRONT,x:o-e,y:r}}),t.push({source:{side:Sides.FRONT,x:o-e,y:r},destination:{side:Sides.UP,x:o-e,y:r}});return t}createBackFaceClockwiseRotator(e){const o=this.dimension-1,t=[];e===0&&t.push(...this.createSideLidClockwiseRotator(Sides.BACK));for(let r=0;r<this.dimension;++r)t.push({source:{side:Sides.LEFT,x:e,y:r},destination:{side:Sides.DOWN,x:r,y:o-e}}),t.push({source:{side:Sides.DOWN,x:r,y:o-e},destination:{side:Sides.RIGHT,x:o-e,y:o-r}}),t.push({source:{side:Sides.RIGHT,x:o-e,y:o-r},destination:{side:Sides.UP,x:o-r,y:e}}),t.push({source:{side:Sides.UP,x:o-r,y:e},destination:{side:Sides.LEFT,x:e,y:r}});return t}createDownFaceClockwiseRotator(e){const o=this.dimension-1,t=[];e===0&&t.push(...this.createSideLidClockwiseRotator(Sides.DOWN));for(let r=0;r<this.dimension;++r)t.push({source:{side:Sides.LEFT,x:r,y:o-e},destination:{side:Sides.FRONT,x:r,y:o-e}}),t.push({source:{side:Sides.FRONT,x:r,y:o-e},destination:{side:Sides.RIGHT,x:r,y:o-e}}),t.push({source:{side:Sides.RIGHT,x:r,y:o-e},destination:{side:Sides.BACK,x:r,y:o-e}}),t.push({source:{side:Sides.BACK,x:r,y:o-e},destination:{side:Sides.LEFT,x:r,y:o-e}});return t}};let RubiksCubeFaceRotator=b;u(RubiksCubeFaceRotator,"faceRotatorMap",new Map);const defaultColorMap=new Map;defaultColorMap.set(Sides.FRONT,Colors.BLUE),defaultColorMap.set(Sides.UP,Colors.YELLOW),defaultColorMap.set(Sides.RIGHT,Colors.RED),defaultColorMap.set(Sides.LEFT,Colors.ORANGE),defaultColorMap.set(Sides.BACK,Colors.GREEN),defaultColorMap.set(Sides.DOWN,Colors.WHITE);class RubiksCube{constructor(e){u(this,"configuration");u(this,"dimension");u(this,"faceRotator");u(this,"colorlessCubelets");if(this.dimension=e==null?void 0:e.dimension,e!=null&&e.clone)this.dimension=Math.sqrt(e.clone.length/6),this.configuration=e.clone.slice();else{const o=this.dimension*this.dimension,t=(e==null?void 0:e.colorMap)||defaultColorMap,r=getAllSides();this.configuration="";for(let n=0;n<r.length;++n){const h=t.get(n),f=mapColorInitialsToString(h);this.configuration+=f.repeat(o)}}this.faceRotator=new RubiksCubeFaceRotator(this.dimension),this.colorlessCubelets=new CubeletsCreator(this.dimension).create()}clone(){return new RubiksCube({clone:this.configuration})}getDimension(){return this.dimension}getConfiguration(){return this.configuration}getHash(){return this.configuration}isSolved(){const e=this.dimension*this.dimension,o=getAllSides(),t=Array.from(new Array(e));return o.every((r,n)=>t.every((h,f)=>this.configuration[n*e+f]===this.configuration[n*e]))}rotateFace(e){return this.faceRotator.rotate(this,e)}getAllCubelets(){return this.addColorToCubelets(this.colorlessCubelets)}getAllColorlessCubelets(){return this.colorlessCubelets}getSideOfIndex(e){const o=getAllSides().length;return e/o}getColorlessCubeletOfIndex(e){return this.colorlessCubelets.find(o=>o.stickers.some(t=>t.id===e))}getCubeletsBySides(...e){const o=this.colorlessCubelets.filter(t=>t.stickers.every(r=>e.includes(r.side)));return this.addColorToCubelets(o)}getCubeletsByColors(...e){const o=this.colorlessCubelets.filter(t=>t.stickers.every(r=>e.includes(mapStringInitialToColor(this.configuration[r.id]))));return this.addColorToCubelets(o)}getColorOfIndex(e){return mapStringInitialToColor(this.configuration[e])}setColorsOfIndexes(e){const o=this.configuration.split("");e.forEach(t=>{o[t.index]=mapColorInitialsToString(t.color)}),this.configuration=o.join("")}addColorToCubelets(e){return e.map(o=>({stickers:o.stickers.map(t=>({...t,color:mapStringInitialToColor(this.configuration[t.id])}))}))}}var commonjsGlobal=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function getDefaultExportFromCjs(s){return s&&s.__esModule&&Object.prototype.hasOwnProperty.call(s,"default")?s.default:s}var doubleLinkedList=LinkedList;function LinkedList(){this._start=null,this._end=null,this.length=0}LinkedList.prototype.unShift=function(s){if(this._start===null)this._start=makeNode(s),this._end=this._start;else{var e=this._start;this._start.previous=makeNode(s),this._start=this._start.previous,this._start.next=e}this.length++},LinkedList.prototype.push=function(s){if(this._start===null)this._start=makeNode(s),this._end=this._start;else{var e=this._end;this._end.next=makeNode(s),this._end=this._end.next,this._end.previous=e}this.length++},LinkedList.prototype.add=function(s,e){if(s%1===0)if(s<=0)this.unShift(e);else if(s>=this.length)this.push(e);else{var o=findNode.call(this,s);if(o){var t=o.previous,r=o,n=makeNode(e);n.previous=t,t.next=n,n.next=r,r.previous=n,this.length++}}},LinkedList.prototype.shift=function(){if(this._start){var s=this._start.data;return this._start.next===null?(this._end=null,this._start=null):(this._start=this._start.next,this._start.previous=null),this.length--,s}else return},LinkedList.prototype.pop=function(){if(this._end){var s=this._end.data;return this._end.previous===null?(this._end=null,this._start=null):(this._end=this._end.previous,this._end.next=null),this.length--,s}else return},LinkedList.prototype.remove=function(s){if(s===0)return this.shift();if(s===this.length-1)return this.pop();var e=findNode.call(this,s);if(e){var o=e.previous,t=e.next;o.next=t,t.previous=o,this.length--}else return},LinkedList.prototype.first=function(){if(this._start)return this._start.data},LinkedList.prototype.last=function(){if(this._end)return this._end.data},LinkedList.prototype.get=function(s){var e=findNode.call(this,s);if(e)return e.data},LinkedList.prototype.toString=function(){for(var s=this._start,e="",o=0;o<this.length;o++)typeof s.data=="object"?e+=JSON.stringify(s.data):e+=s.data,o!==this.length-1&&(e+=", "),s=s.next;return e};function makeNode(s){return{data:s,previous:null,next:null}}function findNode(s){var e,o;if(s>=this.length||s<0||s%1!==0)e=null;else if(s<this.length/2)for(e=this._start,o=0;o<s;o++)e=e.next;else for(e=this._end,o=this.length-1;o>s;o--)e=e.previous;return e}class ProcedureMeasurer{constructor(e=Configuration.metrics.enabled){u(this,"map");u(this,"enabled");u(this,"measurerOverhead");u(this,"startTime");u(this,"totalTime");this.map=new Map,this.enabled=e,this.measurerOverhead=0}add(e,o){const t=performance.now();if(!this.enabled)return o();const r=o(),n=performance.now(),h=this.map.get(e)||{elapsedTime:0,calls:0,stack:"",stackSize:0};return h.elapsedTime+=n-t,++h.calls,this.map.set(e,h),this.measurerOverhead+=performance.now()-n,r}start(){this.startTime=performance.now()}finish(){this.startTime&&(this.totalTime=performance.now()-this.startTime)}getTotalTime(){return this.totalTime}getData(e){const o=[];if(this.totalTime){let t=0;Array.from(this.map.entries()).forEach(r=>{const[n,h]=r;t+=h.elapsedTime,o.push(this.createSummary(h.elapsedTime,h.calls,n))}),e!=null&&e.measurementOverheadLabel&&(o.push(this.createSummary(this.measurerOverhead,0,e.measurementOverheadLabel)),t+=this.measurerOverhead),e!=null&&e.notMeasuredLabel&&o.push(this.createSummary(this.totalTime-t,0,e.notMeasuredLabel))}return o}createSummary(e,o,t){const r=100*e/this.totalTime;return{label:t,totalTime:e,totalRelativeTime:Math.trunc(100*r)/100+"%",numOfCalls:o,avgTimePerCall:e*1/(o||1)}}}const rotationsAreEqual=(s,e)=>s.layer===e.layer&&s.side===e.side&&s.counterClockwiseDirection===e.counterClockwiseDirection,rotationsCancel=(s,e)=>s.layer===e.layer&&s.side===e.side&&s.counterClockwiseDirection!==e.counterClockwiseDirection,getOppositeRotation=s=>({layer:s.layer,side:s.side,counterClockwiseDirection:!s.counterClockwiseDirection});var Metrics$5=(s=>(s[s.ADD_CANDIDATE=0]="ADD_CANDIDATE",s[s.POP_CANDIDATE=1]="POP_CANDIDATE",s[s.HASH_CALCULATION=2]="HASH_CALCULATION",s[s.VISISTED_LIST_CHECK=3]="VISISTED_LIST_CHECK",s[s.ADD_TO_VISISTED_LIST_CHECK=4]="ADD_TO_VISISTED_LIST_CHECK",s[s.PERFORM_ROTATION=5]="PERFORM_ROTATION",s[s.NOT_MEASURED=6]="NOT_MEASURED",s[s.MEASUREMENT_OVERHEAD=7]="MEASUREMENT_OVERHEAD",s))(Metrics$5||{});class BidirectionalBreadthFirstSearchSolver{constructor(e){u(this,"measurer");u(this,"forwardSearchToExploreList");u(this,"forwardSearchExploredMap");u(this,"reverseSearchToExploreList");u(this,"reverseSearchExploredMap");u(this,"actions");u(this,"iterations");u(this,"aborted");this.forwardSearchToExploreList=new doubleLinkedList,this.reverseSearchToExploreList=new doubleLinkedList,this.actions=[],this.iterations=0,this.measurer=new ProcedureMeasurer,this.forwardSearchExploredMap=new Map,this.reverseSearchExploredMap=new Map,this.aborted=!1;const o={cube:e,rotation:void 0,parent:void 0};this.forwardSearchToExploreList.push(o);const t=[];[Sides.RIGHT,Sides.UP,Sides.FRONT].map(f=>[!0,!1].map(S=>{t.push(getOppositeSide(f)),this.actions.push({side:f,counterClockwiseDirection:S,layer:0})}));const r=e.getCubeletsBySides(...t)[0],h={cube:this.buildSolvedCubeFromCornerCubelet(r,e.getDimension()),rotation:void 0,parent:void 0};this.reverseSearchToExploreList.push(h)}abort(){this.aborted=!0}async findSolution(){return new Promise((e,o)=>{this.measurer.start();let t,r,n=0;for(;this.forwardSearchToExploreList.length>0&&this.reverseSearchToExploreList.length>0;){if(++this.iterations,this.aborted)return o();do t=this.measurer.add(Metrics$5[1],()=>this.forwardSearchToExploreList.shift());while(this.measurer.add(Metrics$5[3],()=>this.forwardSearchExploredMap.has(t.cube.getHash())));do r=this.measurer.add(Metrics$5[1],()=>this.reverseSearchToExploreList.shift());while(this.measurer.add(Metrics$5[3],()=>this.reverseSearchExploredMap.has(r.cube.getHash())));++n;let h=this.measurer.add(Metrics$5[3],()=>this.forwardSearchExploredMap.get(r.cube.getHash()));if(h)return e(this.createSolution(h,r,n));if(h=this.measurer.add(Metrics$5[3],()=>this.reverseSearchExploredMap.get(t.cube.getHash())),h)return e(this.createSolution(t,h,n));this.measurer.add(Metrics$5[4],()=>this.forwardSearchExploredMap.set(t.cube.getHash(),t)),this.measurer.add(Metrics$5[4],()=>this.reverseSearchExploredMap.set(r.cube.getHash(),r)),this.applyRotations(this.forwardSearchToExploreList,this.forwardSearchExploredMap,t),this.applyRotations(this.reverseSearchToExploreList,this.reverseSearchExploredMap,r)}return o()})}applyRotations(e,o,t){this.actions.forEach(r=>{if(t.rotation&&(rotationsCancel(t.rotation,r)||t.parent&&t.parent.rotation&&rotationsAreEqual(t.rotation,r)&&rotationsAreEqual(t.parent.rotation,r)))return;const n=this.measurer.add(Metrics$5[5],()=>t.cube.rotateFace(r));this.measurer.add(Metrics$5[3],()=>o.has(n.getHash()))||this.measurer.add(Metrics$5[0],()=>{e.push({cube:n,rotation:r,parent:t})})})}createSolution(e,o,t){this.measurer.finish();const r=[];let n=e;for(;n&&n.rotation;)r.unshift(n.rotation),n=n.parent;for(n=o;n&&n.rotation;){const h={...n.rotation};h.counterClockwiseDirection=!h.counterClockwiseDirection,r.push(h),n=n.parent}return{rotations:r,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:Metrics$5[6],measurementOverheadLabel:Metrics$5[7]}),iterations:this.iterations,visitedNodes:t}}}buildSolvedCubeFromCornerCubelet(e,o){const t=new Map;return e.stickers.forEach(r=>{t.set(r.side,r.color),t.set(getOppositeSide(r.side),getOppositeColor(r.color))}),new RubiksCube({colorMap:t,dimension:o})}}class GeneticAlgorithm{constructor(e,o){u(this,"numberOfActions");u(this,"numOfGenes");u(this,"generationsCounter");u(this,"armageddonCounter");this.numberOfActions=e,this.numOfGenes=o,this.generationsCounter=0,this.armageddonCounter=0}createNextGeneration(e){if(++this.generationsCounter,!e)return this.createNewPopulationFromScratch();if(this.generationsCounter%GeneticAlgorithmConfig.armageddonThreshold===0)return console.log("Armageddon: "+ ++this.armageddonCounter),this.createNextGeneration();const o=e.sort((t,r)=>r.score-t.score).filter((t,r)=>r<GeneticAlgorithmConfig.elitism);return Array.from(new Array(GeneticAlgorithmConfig.populationPerGeneration)).map(()=>this.reproduceCitizens(o))}getArmageddonCounter(){return this.armageddonCounter}getGenerationsCounter(){return this.generationsCounter}pickOne(e,o){let t;do t=Math.floor(Math.random()*e.length);while(o.includes(t));return{chromosome:e[t],index:t}}createNewPopulationFromScratch(){return Array.from(new Array(GeneticAlgorithmConfig.populationPerGeneration)).map(()=>({genes:Array.from(new Array(this.numOfGenes)).map(()=>Math.floor(Math.random()*this.numberOfActions)),score:NaN}))}reproduceCitizens(e){const o=this.pickOne(e,[]),t=this.pickOne(e,[o.index]),r=Math.floor(o.chromosome.genes.length*.25+Math.random()*o.chromosome.genes.length*.5);return{genes:o.chromosome.genes.map((h,f)=>{let S=h;return f>r&&(S=t.chromosome.genes[f]),Math.random()<GeneticAlgorithmConfig.mutationRate&&(S=Math.floor(Math.random()*this.numberOfActions)),S}),score:NaN}}}var srcExports={},src={get exports(){return srcExports},set exports(s){srcExports=s}};(function(module){var colorList={reset:[0,0],bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],inverse:[7,27],hidden:[8,28],strikethrough:[9,29],black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],gray:[90,39],grey:[90,39],redBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39],bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],blackBG:[40,49],redBG:[41,49],greenBG:[42,49],yellowBG:[43,49],blueBG:[44,49],magentaBG:[45,49],cyanBG:[46,49],whiteBG:[47,49],bgBlackBright:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]};if(typeof process>"u"||!process.env)var process={env:{},argv:["--color"]};var isDisabled={}.NO_COLOR||process.argv.includes("--no-color"),isSupported=!isDisabled&&({}.FORCE_COLOR||process.platform==="win32"||process.argv.includes("--color")||eval("require('tty')").isatty(1)&&{}.TERM!=="dumb"||{}.CI),TObject=typeof Reflect>"u"?Object:Reflect,fncache={};function extend(s,e){var o=e.join("");return Object.keys(colorList).forEach(function(t){var r=o+t;TObject.defineProperty(s,t,{get(){return fncache[r]||(fncache[r]=extend(function(h){return s(color[t](h))},e.concat(t))),fncache[r]}})}),s}function replaceClose(s,e,o,t){var r=s.substring(t+o.length),n=r.indexOf(o);return s.substring(0,t)+e+(~n?replaceClose(r,e,o,n):r)}function getFn(s){var e=colorList[s];if(!e||!isSupported)return function(r){return String(r)};var o=e[0],t=e[1];return function(r){if(r===""||r==null)return"";r=""+r;var n=r.indexOf(t,o.length);return o+(n>-1&&n<r.length-1?replaceClose(r,o,t,n):r)+t}}function color(s,e){return getFn(e)(s)}color.list=colorList;function init(){Object.keys(colorList).forEach(function(s){clc[s]=color[s]=extend(getFn(s),[s])})}for(var clc={color,list:colorList,log(s,e){console.log(color(s,e))},isSupported(){return isSupported},enable(){isSupported=!0,init()},disable(){isSupported=!1,init()},strip(s){return s.replace(/\x1b\[\d+m/gm,"")}},i=0;i<256;i++)colorList["c"+i]=["38;5;"+i,0],colorList["bg"+i]=["48;5;"+i,0];Object.keys(colorList).forEach(function(s){colorList[s]=colorList[s].map(function(e){return"\x1B["+e+"m"}),clc.log[s]=function(){for(var e=[],o=0;o<arguments.length;o++)e.push(arguments[o]);console.log(color[s](e.join(" ")))}}),init(),module.exports=clc})(src);class RotationsTuner{tune(e){let o=[...e];for(;;){const t=this.removeTwoConsecutiveOppositeRotations(o);if(o=t.result,t.modifiedFlag)continue;const r=this.replaceThreeConsecutiveRotations(o);if(o=r.result,!r.modifiedFlag)break}return o}removeTwoConsecutiveOppositeRotations(e){if(e.length===1)return{modifiedFlag:!1,result:e};let o=!1;const t=[];for(let r=0;r<e.length;++r)t.length>0&&rotationsCancel(e[r],t[t.length-1])?(o=!0,t.pop()):t.push({...e[r]});return{modifiedFlag:o,result:t}}replaceThreeConsecutiveRotations(e){if(e.length<=2)return{modifiedFlag:!1,result:e};let o=!1;const t=[];for(let r=0;r<e.length;++r)t.length>1&&rotationsAreEqual(e[r],t[t.length-1])&&rotationsAreEqual(e[r],t[t.length-2])?(o=!0,t.pop(),t.pop(),t.push({...getOppositeRotation(e[r])})):t.push({...e[r]});return{modifiedFlag:o,result:t}}}var Metrics$4=(s=>(s[s.NOT_MEASURED=0]="NOT_MEASURED",s[s.RUN_CITIZEN_ROTATIONS=1]="RUN_CITIZEN_ROTATIONS",s[s.CALCULATE_CITIZEN_SCORE=2]="CALCULATE_CITIZEN_SCORE",s[s.APPLYING_ROTATIONS=3]="APPLYING_ROTATIONS",s[s.CREATE_NEXT_GENERATION=4]="CREATE_NEXT_GENERATION",s[s.COMPUTE_GENE=5]="COMPUTE_GENE",s[s.AGGREGATE_CURRENT_GENERATION=6]="AGGREGATE_CURRENT_GENERATION",s[s.CHECK_SOLUTION=7]="CHECK_SOLUTION",s[s.MEASUREMENT_OVERHEAD=8]="MEASUREMENT_OVERHEAD",s))(Metrics$4||{});class GeneticAlgorithmSolver{constructor(e){u(this,"measurer");u(this,"initialState");u(this,"goalStateHash");u(this,"geneticAlgorithm");u(this,"citizens");u(this,"aborted");u(this,"actions");this.measurer=new ProcedureMeasurer,this.initialState=e.clone(),this.aborted=!1,this.actions=[];const o=e.getCubeletsBySides(Sides.BACK,Sides.LEFT,Sides.DOWN)[0],t=this.buildSolvedPocketCubeFromCornerCubelet(o);this.goalStateHash=t.getHash(),[Sides.FRONT,Sides.UP,Sides.RIGHT].map(r=>[!0,!1].map(n=>{this.actions.push({side:r,counterClockwiseDirection:n,layer:0})})),this.geneticAlgorithm=new GeneticAlgorithm(this.actions.length,GeneticAlgorithmConfig.maxNumOfRotations),this.citizens=this.geneticAlgorithm.createNextGeneration()}async findSolution(){return this.measurer.start(),new Promise((e,o)=>{for(;;){if(this.aborted)return o();const t=[];for(let r of this.citizens){const n=this.runCitizen(r);if(n.score===this.goalStateHash.length)return e(this.createSolution(n));this.measurer.add(Metrics$4[6],()=>t.push(n))}this.citizens=this.measurer.add(Metrics$4[4],()=>this.geneticAlgorithm.createNextGeneration(t))}})}abort(){this.aborted=!0}runCitizen(e){let o=this.initialState.clone();return e.genes.reduce((t,r)=>(this.measurer.add(Metrics$4[7],()=>t.score===this.goalStateHash.length)||(o=this.measurer.add(Metrics$4[3],()=>o.rotateFace(this.actions[r])),this.measurer.add(Metrics$4[5],()=>t.genes.push(r)),t.score=this.measurer.add(Metrics$4[2],()=>this.calculateCitizenScore(o))),t),{score:0,genes:[]})}calculateCitizenScore(e){return e.getConfiguration().split("").filter((t,r)=>t===this.goalStateHash[r]).length}createSolution(e){const o=new RotationsTuner().tune(e.genes.map(t=>this.actions[t]));return this.measurer.finish(),{rotations:o,totalTime:this.measurer.getTotalTime(),data:{armageddonCounter:this.geneticAlgorithm.getArmageddonCounter(),generations:this.geneticAlgorithm.getGenerationsCounter(),metrics:this.measurer.getData({notMeasuredLabel:Metrics$4[0],measurementOverheadLabel:Metrics$4[8]})}}}buildSolvedPocketCubeFromCornerCubelet(e){const o=new Map;return e.stickers.forEach(t=>{o.set(t.side,t.color),o.set(getOppositeSide(t.side),getOppositeColor(t.color))}),new RubiksCube({colorMap:o,dimension:this.initialState.getDimension()})}}var Metrics$3=(s=>(s[s.ADD_CANDIDATE=0]="ADD_CANDIDATE",s[s.POP_CANDIDATE=1]="POP_CANDIDATE",s[s.CHECK_SOLUTION=2]="CHECK_SOLUTION",s[s.BREATHING_TIME=3]="BREATHING_TIME",s[s.HASH_CALCULATION=4]="HASH_CALCULATION",s[s.VISISTED_LIST_CHECK=5]="VISISTED_LIST_CHECK",s[s.ADD_TO_VISISTED_LIST_CHECK=6]="ADD_TO_VISISTED_LIST_CHECK",s[s.PERFORM_ROTATION=7]="PERFORM_ROTATION",s[s.NOT_MEASURED=8]="NOT_MEASURED",s[s.CYCLE_AVOIDANCE_CHECK=9]="CYCLE_AVOIDANCE_CHECK",s))(Metrics$3||{});class InterativeDeepeningAStarSolver{constructor(e){u(this,"measurer");u(this,"actions");u(this,"goalStateHash");u(this,"root");u(this,"numberOfStickersMovedInOneTwist");u(this,"iterations");u(this,"minBoundGrow",1.25);u(this,"bound");u(this,"visitedNodes");u(this,"aborted");this.iterations=[],this.measurer=new ProcedureMeasurer,this.visitedNodes=0,this.aborted=!1,this.actions=[],[Sides.FRONT,Sides.UP,Sides.RIGHT].map(n=>[!0,!1].map(h=>{this.actions.push({side:n,counterClockwiseDirection:h,layer:0})}));const o=e.getCubeletsBySides(Sides.BACK,Sides.LEFT,Sides.DOWN)[0],t=this.buildSolvedPocketCubeFromCornerCubelet(o,e.getDimension());this.goalStateHash=t.getHash();const r=e.getDimension();this.numberOfStickersMovedInOneTwist=r*r+r*getAdjacentSides(Sides.UP).length,this.bound=Math.ceil(this.calculateDistanceToFinalState(e)),this.root={cube:e,rotation:void 0,parent:void 0}}abort(){this.aborted=!0}async findSolution(){return new Promise((e,o)=>{for(this.measurer.start();!this.aborted;){const t=this.search(this.root,0);if(t.solution)return e(this.createSolution(t.solution));if(t.aborted)break;this.iterations.push({visitedNodes:this.visitedNodes,bound:this.bound}),this.bound=Math.max(t.cost,this.bound+this.minBoundGrow),this.visitedNodes=0}o(Error("Aborted"))})}search(e,o){if(++this.visitedNodes,this.aborted)return{aborted:!0};let t=this.calculateDistanceToFinalState(e.cube);if(e.cube.isSolved())return{solution:e};let r=1/0;const n=this.applyRotations(e);for(let h of n){const f=o+t;if(f>this.bound)return{cost:f};const S=this.search(h,o+1);if(S.solution||S.aborted)return S;t=Math.min(t,S.cost-1),r=Math.min(S.cost,r)}return{cost:r}}createSolution(e){this.measurer.finish();const o=[];let t=e;for(;t&&t.rotation;)o.unshift(t.rotation),t=t.parent;return{rotations:o,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:Metrics$3[8]}),visitedNodes:this.iterations.reduce((r,n)=>r+n.visitedNodes,0),iterations:this.iterations}}}applyRotations(e){const o=[];return this.actions.forEach(t=>{if(e.rotation&&(rotationsCancel(e.rotation,t)||e.parent&&e.parent.rotation&&rotationsAreEqual(e.rotation,t)&&rotationsAreEqual(e.parent.rotation,t)))return;const r=this.measurer.add(Metrics$3[7],()=>e.cube.rotateFace(t));this.measurer.add(Metrics$3[0],()=>{o.push({cube:r,rotation:t,parent:e})})}),o}calculateDistanceToFinalState(e){return e.getConfiguration().split("").filter((t,r)=>t!==this.goalStateHash[r]).length/this.numberOfStickersMovedInOneTwist}buildSolvedPocketCubeFromCornerCubelet(e,o){const t=new Map;return e.stickers.forEach(r=>{t.set(r.side,r.color),t.set(getOppositeSide(r.side),getOppositeColor(r.color))}),new RubiksCube({colorMap:t,dimension:o})}}var Metrics$2=(s=>(s[s.ADD_CANDIDATE=0]="ADD_CANDIDATE",s[s.POP_CANDIDATE=1]="POP_CANDIDATE",s[s.CHECK_SOLUTION=2]="CHECK_SOLUTION",s[s.BREATHING_TIME=3]="BREATHING_TIME",s[s.HASH_CALCULATION=4]="HASH_CALCULATION",s[s.VISISTED_LIST_CHECK=5]="VISISTED_LIST_CHECK",s[s.ADD_TO_VISISTED_LIST_CHECK=6]="ADD_TO_VISISTED_LIST_CHECK",s[s.PERFORM_ROTATION=7]="PERFORM_ROTATION",s[s.NOT_MEASURED=8]="NOT_MEASURED",s))(Metrics$2||{});class InterativeDeepeningDepthFirstSearchSolver{constructor(e){u(this,"measurer");u(this,"actions");u(this,"root");u(this,"iterations");u(this,"currentMaxDepth");u(this,"visitedNodes");u(this,"aborted");this.measurer=new ProcedureMeasurer,this.iterations=[],this.visitedNodes=0,this.aborted=!1,this.actions=this.createActions();const o=e.getCubeletsBySides(Sides.BACK,Sides.LEFT,Sides.DOWN)[0],t=this.buildSolvedPocketCubeFromCornerCubelet(o,e.getDimension());this.currentMaxDepth=this.calculateDistanceToFinalState(e,t.getConfiguration()),this.root={cube:e,rotation:void 0,parent:void 0}}abort(){this.aborted=!0}async findSolution(){return new Promise((e,o)=>{for(this.measurer.start();!this.aborted;){const t=this.beginSearch(this.root,0);if(t)return this.measurer.finish(),e(this.createSolution(t));this.iterations.push({visitedNodes:this.visitedNodes,bound:this.currentMaxDepth}),this.visitedNodes=0,++this.currentMaxDepth}o(Error("Aborted"))})}beginSearch(e,o){if(++this.visitedNodes,!this.aborted){if(o<this.currentMaxDepth){const t=this.applyRotations(e);for(let r of t){const n=this.beginSearch(r,o+1);if(n)return n}}else if(o===this.currentMaxDepth&&e.cube.isSolved())return e}}createActions(){const e=[];return[Sides.FRONT,Sides.UP,Sides.RIGHT].map(o=>[!0,!1].map(t=>{e.push({side:o,counterClockwiseDirection:t,layer:0})})),e}createSolution(e){const o=[];let t=e;for(;t&&t.rotation;)o.unshift(t.rotation),t=t.parent;return{rotations:o,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:Metrics$2[8]}),visitedNodes:this.iterations.reduce((r,n)=>r+n.visitedNodes,0),iterations:this.iterations}}}applyRotations(e){const o=[];return this.actions.forEach(t=>{if(e.rotation&&(rotationsCancel(e.rotation,t)||e.parent&&e.parent.rotation&&rotationsAreEqual(e.rotation,t)&&rotationsAreEqual(e.parent.rotation,t)))return;const r=this.measurer.add(Metrics$2[7],()=>e.cube.rotateFace(t));this.measurer.add(Metrics$2[0],()=>{o.push({cube:r,rotation:t,parent:e})})}),o}calculateDistanceToFinalState(e,o){const t=e.getDimension()*e.getDimension()+e.getDimension()*4,r=e.getConfiguration();return Math.ceil(r.split("").filter((n,h)=>n!==o[h]).length/t)}buildSolvedPocketCubeFromCornerCubelet(e,o){const t=new Map;return e.stickers.forEach(r=>{t.set(r.side,r.color),t.set(getOppositeSide(r.side),getOppositeColor(r.color))}),new RubiksCube({colorMap:t,dimension:o})}}class SimulatedAnnealing{constructor(e){u(this,"maxSuccessPerIteration",SimulatedAnnealingConfig.maxSuccessPerIteration);u(this,"temperatureDecreaseRate",SimulatedAnnealingConfig.temperatureDecreaseRate);u(this,"numOfRotations",SimulatedAnnealingConfig.numOfRotations);u(this,"population",SimulatedAnnealingConfig.population);u(this,"numOfActions");u(this,"temperature",SimulatedAnnealingConfig.initialTemperature);u(this,"lastResult");u(this,"successCounter",0);u(this,"generationCounter",0);this.numOfActions=e}createNextGeneration(e){if(++this.generationCounter,!e)return this.createNewPopulationFromScratch();const o=e.sort((r,n)=>n.score-r.score)[0];return this.lastResult?o.score-this.lastResult.score>0?(++this.successCounter,this.successCounter>this.maxSuccessPerIteration&&this.adjustTemperature(),this.disturbCandidate(o)):this.disturbCandidate(this.lastResult):this.disturbCandidate(o)}getGenerationCounter(){return this.generationCounter}createNewPopulationFromScratch(){return Array.from(new Array(this.population)).map(()=>({actions:Array.from(new Array(this.numOfRotations)).map(()=>this.createAction()),score:NaN}))}disturbCandidate(e){return this.lastResult=e,Array.from(Array(this.population-1)).map(()=>({actions:e.actions.map(t=>Math.random()<this.temperature?this.createAction():t),score:NaN})).concat(e)}createAction(){return Math.floor(Math.random()*this.numOfActions)}adjustTemperature(){this.temperature*=this.temperatureDecreaseRate,this.successCounter=0}}var Metrics$1=(s=>(s[s.NOT_MEASURED=0]="NOT_MEASURED",s[s.RUN_CANDIDATE_ROTATIONS=1]="RUN_CANDIDATE_ROTATIONS",s[s.CALCULATE_CITIZEN_SCORE=2]="CALCULATE_CITIZEN_SCORE",s[s.APPLYING_ROTATIONS=3]="APPLYING_ROTATIONS",s[s.CREATE_NEXT_GENERATION=4]="CREATE_NEXT_GENERATION",s[s.COMPUTE_ROTATION=5]="COMPUTE_ROTATION",s[s.AGGREGATE_CURRENT_GENERATION=6]="AGGREGATE_CURRENT_GENERATION",s[s.CHECK_SOLUTION=7]="CHECK_SOLUTION",s[s.MEASUREMENT_OVERHEAD=8]="MEASUREMENT_OVERHEAD",s))(Metrics$1||{});class SimulatedAnnealingSolver{constructor(e){u(this,"measurer");u(this,"initialState");u(this,"goalStateHash");u(this,"simulatedAnnealing");u(this,"candidates");u(this,"aborted");u(this,"actions");u(this,"restartCounter",0);u(this,"iterations",0);this.measurer=new ProcedureMeasurer,this.initialState=e.clone(),this.aborted=!1,this.actions=[];const o=e.getCubeletsBySides(Sides.BACK,Sides.LEFT,Sides.DOWN)[0],t=this.buildSolvedPocketCubeFromCornerCubelet(o);this.goalStateHash=t.getHash(),[Sides.FRONT,Sides.UP,Sides.RIGHT].map(r=>[!0,!1].map(n=>{this.actions.push({side:r,counterClockwiseDirection:n,layer:0})})),this.simulatedAnnealing=new SimulatedAnnealing(this.actions.length),this.candidates=this.simulatedAnnealing.createNextGeneration()}async findSolution(){return this.measurer.start(),new Promise((e,o)=>{for(;;){if(++this.iterations,this.aborted)return o();this.simulatedAnnealing.getGenerationCounter()>SimulatedAnnealingConfig.restartThreshold&&(++this.restartCounter,console.log("Restart: "+this.restartCounter),this.simulatedAnnealing=new SimulatedAnnealing(this.actions.length),this.candidates=this.simulatedAnnealing.createNextGeneration());const t=[];for(let r of this.candidates){const n=this.runCitizen(r);if(n.score===this.goalStateHash.length)return e(this.createSolution(n));this.measurer.add(Metrics$1[6],()=>t.push(n))}this.candidates=this.measurer.add(Metrics$1[4],()=>this.simulatedAnnealing.createNextGeneration(t))}})}abort(){this.aborted=!0}runCitizen(e){let o=this.initialState.clone();return e.actions.reduce((t,r)=>(this.measurer.add(Metrics$1[7],()=>t.score===this.goalStateHash.length)||(o=this.measurer.add(Metrics$1[3],()=>o.rotateFace(this.actions[r])),this.measurer.add(Metrics$1[5],()=>t.actions.push(r)),t.score=this.measurer.add(Metrics$1[2],()=>this.calculateCitizenScore(o))),t),{score:0,actions:[]})}calculateCitizenScore(e){return e.getConfiguration().split("").filter((t,r)=>t===this.goalStateHash[r]).length}createSolution(e){const o=new RotationsTuner().tune(e.actions.map(t=>this.actions[t]));return this.measurer.finish(),{rotations:o,totalTime:this.measurer.getTotalTime(),data:{restartCounter:this.restartCounter,iterations:this.iterations,metrics:this.measurer.getData({notMeasuredLabel:Metrics$1[0],measurementOverheadLabel:Metrics$1[8]})}}}buildSolvedPocketCubeFromCornerCubelet(e){const o=new Map;return e.stickers.forEach(t=>{o.set(t.side,t.color),o.set(getOppositeSide(t.side),getOppositeColor(t.color))}),new RubiksCube({colorMap:o,dimension:this.initialState.getDimension()})}}var heapExports$1={},heap$1={get exports(){return heapExports$1},set exports(s){heapExports$1=s}},heapExports={},heap={get exports(){return heapExports},set exports(s){heapExports=s}};(function(s,e){(function(){var o,t,r,n,h,f,S,I,A,T,x,L,w,_,N;r=Math.floor,T=Math.min,t=function(a,l){return a<l?-1:a>l?1:0},A=function(a,l,d,c,m){var p;if(d==null&&(d=0),m==null&&(m=t),d<0)throw new Error("lo must be non-negative");for(c==null&&(c=a.length);d<c;)p=r((d+c)/2),m(l,a[p])<0?c=p:d=p+1;return[].splice.apply(a,[d,d-d].concat(l)),l},f=function(a,l,d){return d==null&&(d=t),a.push(l),_(a,0,a.length-1,d)},h=function(a,l){var d,c;return l==null&&(l=t),d=a.pop(),a.length?(c=a[0],a[0]=d,N(a,0,l)):c=d,c},I=function(a,l,d){var c;return d==null&&(d=t),c=a[0],a[0]=l,N(a,0,d),c},S=function(a,l,d){var c;return d==null&&(d=t),a.length&&d(a[0],l)<0&&(c=[a[0],l],l=c[0],a[0]=c[1],N(a,0,d)),l},n=function(a,l){var d,c,m,p,g,C;for(l==null&&(l=t),p=function(){C=[];for(var R=0,O=r(a.length/2);0<=O?R<O:R>O;0<=O?R++:R--)C.push(R);return C}.apply(this).reverse(),g=[],c=0,m=p.length;c<m;c++)d=p[c],g.push(N(a,d,l));return g},w=function(a,l,d){var c;if(d==null&&(d=t),c=a.indexOf(l),c!==-1)return _(a,0,c,d),N(a,c,d)},x=function(a,l,d){var c,m,p,g,C;if(d==null&&(d=t),m=a.slice(0,l),!m.length)return m;for(n(m,d),C=a.slice(l),p=0,g=C.length;p<g;p++)c=C[p],S(m,c,d);return m.sort(d).reverse()},L=function(a,l,d){var c,m,p,g,C,R,O,v,D;if(d==null&&(d=t),l*10<=a.length){if(p=a.slice(0,l).sort(d),!p.length)return p;for(m=p[p.length-1],O=a.slice(l),g=0,R=O.length;g<R;g++)c=O[g],d(c,m)<0&&(A(p,c,0,null,d),p.pop(),m=p[p.length-1]);return p}for(n(a,d),D=[],C=0,v=T(l,a.length);0<=v?C<v:C>v;0<=v?++C:--C)D.push(h(a,d));return D},_=function(a,l,d,c){var m,p,g;for(c==null&&(c=t),m=a[d];d>l;){if(g=d-1>>1,p=a[g],c(m,p)<0){a[d]=p,d=g;continue}break}return a[d]=m},N=function(a,l,d){var c,m,p,g,C;for(d==null&&(d=t),m=a.length,C=l,p=a[l],c=2*l+1;c<m;)g=c+1,g<m&&!(d(a[c],a[g])<0)&&(c=g),a[l]=a[c],l=c,c=2*l+1;return a[l]=p,_(a,C,l,d)},o=function(){a.push=f,a.pop=h,a.replace=I,a.pushpop=S,a.heapify=n,a.updateItem=w,a.nlargest=x,a.nsmallest=L;function a(l){this.cmp=l??t,this.nodes=[]}return a.prototype.push=function(l){return f(this.nodes,l,this.cmp)},a.prototype.pop=function(){return h(this.nodes,this.cmp)},a.prototype.peek=function(){return this.nodes[0]},a.prototype.contains=function(l){return this.nodes.indexOf(l)!==-1},a.prototype.replace=function(l){return I(this.nodes,l,this.cmp)},a.prototype.pushpop=function(l){return S(this.nodes,l,this.cmp)},a.prototype.heapify=function(){return n(this.nodes,this.cmp)},a.prototype.updateItem=function(l){return w(this.nodes,l,this.cmp)},a.prototype.clear=function(){return this.nodes=[]},a.prototype.empty=function(){return this.nodes.length===0},a.prototype.size=function(){return this.nodes.length},a.prototype.clone=function(){var l;return l=new a,l.nodes=this.nodes.slice(0),l},a.prototype.toArray=function(){return this.nodes.slice(0)},a.prototype.insert=a.prototype.push,a.prototype.top=a.prototype.peek,a.prototype.front=a.prototype.peek,a.prototype.has=a.prototype.contains,a.prototype.copy=a.prototype.clone,a}(),function(a,l){return s.exports=l()}(this,function(){return o})}).call(commonjsGlobal)})(heap),function(s){s.exports=heapExports}(heap$1);var Heap=getDefaultExportFromCjs(heapExports$1),Metrics=(s=>(s[s.ADD_CANDIDATE=0]="ADD_CANDIDATE",s[s.POP_CANDIDATE=1]="POP_CANDIDATE",s[s.CHECK_SOLUTION=2]="CHECK_SOLUTION",s[s.BREATHING_TIME=3]="BREATHING_TIME",s[s.HASH_CALCULATION=4]="HASH_CALCULATION",s[s.VISISTED_LIST_CHECK=5]="VISISTED_LIST_CHECK",s[s.ADD_TO_VISISTED_LIST_CHECK=6]="ADD_TO_VISISTED_LIST_CHECK",s[s.PERFORM_ROTATION=7]="PERFORM_ROTATION",s[s.NOT_MEASURED=8]="NOT_MEASURED",s[s.HEURISTIC_CALCULATION=9]="HEURISTIC_CALCULATION",s[s.GET_ALL_CUBELETS=10]="GET_ALL_CUBELETS",s[s.CUBELET_FINAL_POSITION=11]="CUBELET_FINAL_POSITION",s[s.CUBELET_SIMILARITY=12]="CUBELET_SIMILARITY",s[s.ITERATION=13]="ITERATION",s[s.SOLUTION_CREATION=14]="SOLUTION_CREATION",s[s.MEASUREMENT_OVERHEAD=15]="MEASUREMENT_OVERHEAD",s[s.ITERATIONS_COUNTER_INCREMENT=16]="ITERATIONS_COUNTER_INCREMENT",s[s.ABORTED_VERIFICATION=17]="ABORTED_VERIFICATION",s[s.BUILD_SOLUTION=18]="BUILD_SOLUTION",s))(Metrics||{});class WeightedAStarSolver{constructor(e){u(this,"measurer");u(this,"candidates");u(this,"visitedChecklist");u(this,"actions");u(this,"dimension");u(this,"goalStateHash");u(this,"aborted");this.aborted=!1,this.dimension=e.getDimension(),this.candidates=new Heap((n,h)=>n.cost+WeightedAStarAlgorithmConfig.heuristicWeight*n.heuristicValue-(h.cost+WeightedAStarAlgorithmConfig.heuristicWeight*h.heuristicValue)),this.visitedChecklist=new Map;const o={cost:0,heuristicValue:0,cube:e,rotation:void 0,parent:void 0};this.candidates.push(o),this.actions=[];const t=e.getCubeletsBySides(Sides.BACK,Sides.LEFT,Sides.DOWN)[0],r=this.buildSolvedPocketCubeFromCornerCubelet(t);this.goalStateHash=r.getHash(),[Sides.FRONT,Sides.UP,Sides.RIGHT].map(n=>[!0,!1].map(h=>{this.actions.push({side:n,counterClockwiseDirection:h,layer:0})})),this.measurer=new ProcedureMeasurer}async findSolution(){return new Promise((e,o)=>{this.measurer.start();let t,r=0,n=0;for(;this.measurer.add(Metrics[16],()=>this.candidates.size()>0);){if(this.measurer.add(Metrics[17],()=>this.aborted))return o();if(this.measurer.add(Metrics[16],()=>++r),t=this.measurer.add(Metrics[1],()=>this.candidates.pop()),!this.measurer.add(Metrics[5],()=>this.visitedChecklist.has(t.cube.getHash()))){if(++n,this.measurer.add(Metrics[2],()=>t.cube.getHash()===this.goalStateHash))return e(this.measurer.add(Metrics[14],()=>this.createSolution(t,r,n)));this.measurer.add(Metrics[6],()=>this.visitedChecklist.set(t.cube.getHash(),t)),this.applyRotations(t)}}o(Error("No more candidates to explore"))})}abort(){this.aborted=!0}createSolution(e,o,t){const r=[];let n=e;return this.measurer.add(Metrics[18],()=>{for(;n&&n.rotation;)r.unshift(n.rotation),n=n.parent}),this.measurer.finish(),this.candidates.clear(),{rotations:r,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:Metrics[8],measurementOverheadLabel:Metrics[15]}),visitedNodes:o,differentNodes:t}}}applyRotations(e){for(let o of this.actions){if(e.rotation&&(rotationsCancel(e.rotation,o)||e.parent&&e.parent.rotation&&rotationsAreEqual(e.rotation,o)&&rotationsAreEqual(e.parent.rotation,o)))continue;const t=this.measurer.add(Metrics[7],()=>e.cube.rotateFace(o)),r=t.getHash(),n=this.measurer.add(Metrics[9],()=>this.calculateDistanceToFinalState(t)),h={cost:e.cost+1,cube:t,rotation:o,heuristicValue:n,parent:e};this.measurer.add(Metrics[5],()=>this.visitedChecklist.get(r))||this.measurer.add(Metrics[0],()=>{this.candidates.push(h)})}}calculateDistanceToFinalState(e){const o=this.dimension*this.dimension+this.dimension*4;return e.getConfiguration().split("").filter((r,n)=>r!==this.goalStateHash[n]).length/o}buildSolvedPocketCubeFromCornerCubelet(e){const o=new Map;return e.stickers.forEach(t=>{o.set(t.side,t.color),o.set(getOppositeSide(t.side),getOppositeColor(t.color))}),new RubiksCube({colorMap:o,dimension:this.dimension})}}class KeyboardInterpreter{readKeys(e,o){let t;switch(e.key.toLowerCase()){case"w":t=Sides.UP;break;case"a":t=Sides.LEFT;break;case"s":t=Sides.FRONT;break;case"d":t=Sides.RIGHT;break;case"f":t=Sides.BACK;break;case"x":t=Sides.DOWN;break}if(t!==void 0)return{side:t,counterClockwiseDirection:e.shiftKey,layer:o}}}class HumanSolver{constructor(e){u(this,"moves");u(this,"findSolutionResolve");u(this,"findSolutionReject");u(this,"cube");u(this,"startTime");u(this,"keyboardInterpreter");this.cube=e,this.moves=[],this.keyboardInterpreter=new KeyboardInterpreter}async findSolution(){return this.startTime=Date.now(),new Promise((e,o)=>{this.findSolutionResolve=e,this.findSolutionReject=o})}abort(){this.findSolutionReject()}async readKeys(e){if(this.cube.isSolved())return;const o=this.keyboardInterpreter.readKeys(e);if(o!==void 0)return this.moves.push(o),this.cube=this.cube.rotateFace(o),this.cube.isSolved()&&this.findSolutionResolve({rotations:this.moves,totalTime:Date.now()-this.startTime,data:{human:!0}}),o}}const WeightedAStarAlgorithmConfig={heuristicWeight:50},GeneticAlgorithmConfig={mutationRate:.25,populationPerGeneration:100,maxNumOfRotations:30,elitism:15,armageddonThreshold:4e3},SimulatedAnnealingConfig={population:100,initialTemperature:.5,temperatureDecreaseRate:.95,numOfRotations:30,maxSuccessPerIteration:10,restartThreshold:4e3},Configuration={metrics:{enabled:!0,generateReport:!1},world:{debug:!1,scrambleMoves:()=>Math.floor(Math.random()*10+30),scrambleRotationDuration:80,cubesCircleRay:4.5,camera:{closeDistance:20,farDistance:55}},renderers:{translationDuration:500,rotationDuration:250,titleDistance:8.5,cubeSize:2.5},initiallySelectedCubeTypeIndex:0,cubeTypes:[{label:"2x2",dimension:2,instantiator:()=>new RubiksCube({dimension:2}),methods:[{key:"Human",instantiator:s=>new HumanSolver(new RubiksCube({clone:s})),checked:!1,human:!0,info:"Use keys 'WASDFX' combined with 'shift' to rotate cube faces"},{key:"IDDFS",instantiator:s=>new InterativeDeepeningDepthFirstSearchSolver(new RubiksCube({clone:s})),checked:!1,info:"Interative-deepening depth-first-search. Brute force"},{key:"IDA*",instantiator:s=>new InterativeDeepeningAStarSolver(new RubiksCube({clone:s})),checked:!1,info:"Interative-deepening A star. Uses number of misplaced stickers as heuristic."},{key:"SA",instantiator:s=>new SimulatedAnnealingSolver(new RubiksCube({clone:s})),checked:!0,info:`Random movements improved by simulated annealing algorithm. Uses number of misplaced stickers as a measure of a solution candidate result. Population: ${SimulatedAnnealingConfig.population}. Initial temperature: ${SimulatedAnnealingConfig.initialTemperature}. Temperature decrease rate: ${SimulatedAnnealingConfig.temperatureDecreaseRate}`},{key:"GA",instantiator:s=>new GeneticAlgorithmSolver(new RubiksCube({clone:s})),checked:!0,info:`Random movements improved by genetic algorithm. Uses number of misplaced stickers as fitness function. Population: ${GeneticAlgorithmConfig.populationPerGeneration}. Elitism ${GeneticAlgorithmConfig.elitism}.  Mutation rate ${GeneticAlgorithmConfig.mutationRate}. `},{key:"WA*",instantiator:s=>new WeightedAStarSolver(new RubiksCube({clone:s})),checked:!0,info:`Weighted A star. No re-expansions. Uses number of misplaced stickers as heuristic and weights the heuristic (${WeightedAStarAlgorithmConfig.heuristicWeight} * h(x)) value.`},{key:"BiBFS",instantiator:s=>new BidirectionalBreadthFirstSearchSolver(new RubiksCube({clone:s})),checked:!0,info:"Bidirectional breadth-first-search. Brute force."}]},{label:"3x3",dimension:3,instantiator:()=>new RubiksCube({dimension:3}),methods:[{key:"Human",instantiator:s=>new HumanSolver(new RubiksCube({clone:s})),checked:!0,human:!0,info:"Use keys 'WASDFX' combined with 'shift' to rotate cube faces"}]},{label:"4x4",dimension:4,instantiator:()=>new RubiksCube({dimension:4}),methods:[{key:"Human",instantiator:s=>new HumanSolver(new RubiksCube({clone:s})),checked:!0,human:!0,info:"Use keys 'WASDFX' combined with 'shift' and numbers to rotate cube faces"}]},{label:"5x5",dimension:5,instantiator:()=>new RubiksCube({dimension:5}),methods:[{key:"Human",instantiator:s=>new HumanSolver(new RubiksCube({clone:s})),checked:!0,human:!0,info:"Use keys 'WASDFX' combined with 'shift' and numbers to rotate cube faces"}]},{label:"6x6",dimension:6,instantiator:()=>new RubiksCube({dimension:6}),methods:[{key:"Human",instantiator:s=>new HumanSolver(new RubiksCube({clone:s})),checked:!0,human:!0,info:"Use keys 'WASDFX' combined with 'shift' and numbers to rotate cube faces"}]},{label:"7x7",dimension:7,instantiator:()=>new RubiksCube({dimension:7}),methods:[{key:"Human",instantiator:s=>new HumanSolver(new RubiksCube({clone:s})),checked:!0,human:!0,info:"Use keys 'WASDFX' combined with 'shift' and numbers to rotate cube faces"}]}]},solverMethodFinder=s=>{for(let e of Configuration.cubeTypes)if(e.label.toLowerCase()===s.label.toLowerCase()){for(let o of e.methods)if(o.key.toLowerCase()===s.solverTag.toLowerCase())return o;return}};let solver;self.onmessage=async s=>{if(s.data.abort)solver.abort();else{const e=s.data.solverTag.toLowerCase(),o=solverMethodFinder(s.data);if(e&&o)if(s.data.cube)try{solver=o.instantiator(s.data.cube);const t=await solver.findSolution();self.postMessage({solution:JSON.stringify(t),solverKey:e})}catch(t){console.log(`Solver '${s.data.label}.${e}' aborted`,t),self.postMessage({error:`Solver '${s.data.label}.${e}' aborted`,solverTag:s.data.solverTag})}else if(s.data.keyboardEvent){if(solver instanceof HumanSolver){const t=await solver.readKeys(s.data.keyboardEvent);t!==void 0&&self.postMessage({faceRotation:t,solverKey:e})}}else self.postMessage({error:`Command for '${s.data}' not found`,solverTag:s.data.solverTag});else self.postMessage({error:`Solver '${s.data.solverTag}' not found`,solverTag:s.data.solverTag})}}})();
