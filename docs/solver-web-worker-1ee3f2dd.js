var k=Object.defineProperty;var x=(N,R,o)=>R in N?k(N,R,{enumerable:!0,configurable:!0,writable:!0,value:o}):N[R]=o;var l=(N,R,o)=>(x(N,typeof R!="symbol"?R+"":R,o),o);(function(){"use strict";var Sides=(o=>(o[o.UP=0]="UP",o[o.LEFT=1]="LEFT",o[o.FRONT=2]="FRONT",o[o.RIGHT=3]="RIGHT",o[o.BACK=4]="BACK",o[o.DOWN=5]="DOWN",o))(Sides||{});const getAllSides=()=>Object.keys(Sides).filter(o=>!isNaN(Number(o))).map(o=>Number(o)),getAdjacentSides=o=>Object.keys(Sides).filter(e=>!isNaN(Number(e))).map(e=>Number(e)).filter(e=>e!==o&&e!==getOppositeSide(o)),getOppositeSide=o=>{switch(o){case 0:return 5;case 5:return 0;case 1:return 3;case 3:return 1;case 2:return 4;case 4:return 2}};var Colors=(o=>(o[o.YELLOW=0]="YELLOW",o[o.ORANGE=1]="ORANGE",o[o.BLUE=2]="BLUE",o[o.RED=3]="RED",o[o.GREEN=4]="GREEN",o[o.WHITE=5]="WHITE",o))(Colors||{});const getOppositeColor=o=>{switch(o){case 2:return 4;case 4:return 2;case 3:return 1;case 1:return 3;case 0:return 5;case 5:return 0}},colorToStringMap=new Map;colorToStringMap.set(0,"y"),colorToStringMap.set(1,"o"),colorToStringMap.set(2,"b"),colorToStringMap.set(3,"r"),colorToStringMap.set(4,"g"),colorToStringMap.set(5,"w");const mapColorInitialsToString=o=>colorToStringMap.get(o),stringToColorMap=new Map;stringToColorMap.set("y",0),stringToColorMap.set("o",1),stringToColorMap.set("b",2),stringToColorMap.set("r",3),stringToColorMap.set("g",4),stringToColorMap.set("w",5);const mapStringInitialToColor=o=>stringToColorMap.get(o),N=class{constructor(e){l(this,"dimension");l(this,"stickers");l(this,"cubeletCounter");this.dimension=e,this.stickers=[],this.cubeletCounter=0}create(){if(N.cubeletsCreatorMap.has(this.dimension))return N.cubeletsCreatorMap.get(this.dimension);{let e=0;getAllSides().map(a=>{for(let u=0;u<this.dimension;++u)for(let g=0;g<this.dimension;++g)this.stickers.push({side:a,x:g,y:u,id:e++})});const t=this.extractCenters(),s=this.extractCorners(),r=this.extractEdges(),n=[...s,...r,...t];return N.cubeletsCreatorMap.set(this.dimension,n),n}}cubeletsMerger(e){const t={stickers:[],id:++this.cubeletCounter};return e.forEach(s=>{this.stickers.forEach((r,n,a)=>{r.side===s.side&&s.x===r.x&&s.y===r.y&&t.stickers.push(...a.splice(n,1))})}),t}extractEdges(){const e=this.dimension-1,t=[];for(let s=1;s<this.dimension-1;++s)t.push(this.cubeletsMerger([{side:Sides.FRONT,x:0,y:s},{side:Sides.LEFT,x:e,y:s}])),t.push(this.cubeletsMerger([{side:Sides.FRONT,x:e,y:s},{side:Sides.RIGHT,x:0,y:s}])),t.push(this.cubeletsMerger([{side:Sides.FRONT,x:s,y:0},{side:Sides.UP,x:s,y:e}])),t.push(this.cubeletsMerger([{side:Sides.FRONT,x:s,y:e},{side:Sides.DOWN,x:s,y:0}])),t.push(this.cubeletsMerger([{side:Sides.BACK,x:e,y:s},{side:Sides.LEFT,x:0,y:s}])),t.push(this.cubeletsMerger([{side:Sides.BACK,x:0,y:s},{side:Sides.RIGHT,x:e,y:s}])),t.push(this.cubeletsMerger([{side:Sides.BACK,x:s,y:0},{side:Sides.UP,x:e-s,y:0}])),t.push(this.cubeletsMerger([{side:Sides.BACK,x:s,y:e},{side:Sides.DOWN,x:e-s,y:e}])),t.push(this.cubeletsMerger([{side:Sides.RIGHT,x:s,y:0},{side:Sides.UP,x:e,y:e-s}])),t.push(this.cubeletsMerger([{side:Sides.RIGHT,x:s,y:e},{side:Sides.DOWN,x:e,y:s}])),t.push(this.cubeletsMerger([{side:Sides.LEFT,x:s,y:0},{side:Sides.UP,x:0,y:s}])),t.push(this.cubeletsMerger([{side:Sides.LEFT,x:s,y:e},{side:Sides.DOWN,x:0,y:e-s}]));return t}extractCenters(){const e=this.dimension-1,t=[];return this.stickers.filter(s=>s.x!==0&&s.x!==e&&s.y!==0&&s.y!==e).forEach(s=>{t.push({stickers:[s],id:++this.cubeletCounter})}),t}extractCorners(){const e=[],t=this.dimension-1;return e.push(this.cubeletsMerger([{side:Sides.FRONT,x:0,y:0},{side:Sides.UP,x:0,y:t},{side:Sides.LEFT,x:t,y:0}])),e.push(this.cubeletsMerger([{side:Sides.FRONT,x:t,y:0},{side:Sides.UP,x:t,y:t},{side:Sides.RIGHT,x:0,y:0}])),e.push(this.cubeletsMerger([{side:Sides.FRONT,x:0,y:t},{side:Sides.DOWN,x:0,y:0},{side:Sides.LEFT,x:t,y:t}])),e.push(this.cubeletsMerger([{side:Sides.FRONT,x:t,y:t},{side:Sides.DOWN,x:t,y:0},{side:Sides.RIGHT,x:0,y:t}])),e.push(this.cubeletsMerger([{side:Sides.BACK,x:0,y:0},{side:Sides.UP,x:t,y:0},{side:Sides.RIGHT,x:t,y:0}])),e.push(this.cubeletsMerger([{side:Sides.BACK,x:t,y:0},{side:Sides.UP,x:0,y:0},{side:Sides.LEFT,x:0,y:0}])),e.push(this.cubeletsMerger([{side:Sides.BACK,x:0,y:t},{side:Sides.DOWN,x:t,y:t},{side:Sides.RIGHT,x:t,y:t}])),e.push(this.cubeletsMerger([{side:Sides.BACK,x:t,y:t},{side:Sides.DOWN,x:0,y:t},{side:Sides.LEFT,x:0,y:t}])),e}};let CubeletsCreator=N;l(CubeletsCreator,"cubeletsCreatorMap",new Map);const R=class{constructor(e){l(this,"dimension");if(this.dimension=e,!R.faceRotatorMap.has(this.dimension)){const t=new Map;for(let s=0;s<this.dimension;++s){const r=this.createUpFaceClockwiseRotator(s),n=this.createLeftFaceClockwiseRotator(s),a=this.createFrontFaceClockwiseRotator(s),u=this.createRightFaceClockwiseRotator(s),g=this.createBackFaceClockwiseRotator(s),p=this.createDownFaceClockwiseRotator(s),S=new Map;S.set(Sides.UP,r.map(m=>this.faceStickerMapper(m))),S.set(Sides.LEFT,n.map(m=>this.faceStickerMapper(m))),S.set(Sides.FRONT,a.map(m=>this.faceStickerMapper(m))),S.set(Sides.RIGHT,u.map(m=>this.faceStickerMapper(m))),S.set(Sides.BACK,g.map(m=>this.faceStickerMapper(m))),S.set(Sides.DOWN,p.map(m=>this.faceStickerMapper(m))),t.set(s,S)}R.faceRotatorMap.set(this.dimension,t)}}rotate(e,t){const s=new RubiksCube({clone:e.getConfiguration()}),r=[];return R.faceRotatorMap.get(this.dimension).get(t.layer||0).get(t.side).forEach(n=>{t.counterClockwiseDirection?r.push({index:n.source,color:e.getColorOfIndex(n.destination)}):r.push({index:n.destination,color:e.getColorOfIndex(n.source)})}),s.setColorsOfIndexes(r),s}idMapper(e){let t=e.side*this.dimension*this.dimension;return t+=this.dimension*e.y,t+=e.x,t}faceStickerMapper(e){return{source:this.idMapper(e.source),destination:this.idMapper(e.destination)}}createSideLidClockwiseRotator(e){const t=[];for(let s=0;s<this.dimension*this.dimension;++s){const r=s%this.dimension,n=Math.floor(s/this.dimension),a=this.dimension-1-n,u=r;t.push({source:{side:e,x:r,y:n},destination:{side:e,x:a,y:u}})}return t}createUpFaceClockwiseRotator(e){this.dimension-1;const t=[];e===0&&t.push(...this.createSideLidClockwiseRotator(Sides.UP));for(let s=0;s<this.dimension;++s)t.push({source:{side:Sides.FRONT,x:s,y:e},destination:{side:Sides.LEFT,x:s,y:e}}),t.push({source:{side:Sides.LEFT,x:s,y:e},destination:{side:Sides.BACK,x:s,y:e}}),t.push({source:{side:Sides.BACK,x:s,y:e},destination:{side:Sides.RIGHT,x:s,y:e}}),t.push({source:{side:Sides.RIGHT,x:s,y:e},destination:{side:Sides.FRONT,x:s,y:e}});return t}createLeftFaceClockwiseRotator(e){const t=this.dimension-1,s=[];e===0&&s.push(...this.createSideLidClockwiseRotator(Sides.LEFT));for(let r=0;r<this.dimension;++r)s.push({source:{side:Sides.FRONT,x:e,y:r},destination:{side:Sides.DOWN,x:e,y:r}}),s.push({source:{side:Sides.DOWN,x:e,y:r},destination:{side:Sides.BACK,x:t-e,y:t-r}}),s.push({source:{side:Sides.BACK,x:t-e,y:t-r},destination:{side:Sides.UP,x:e,y:r}}),s.push({source:{side:Sides.UP,x:e,y:r},destination:{side:Sides.FRONT,x:e,y:r}});return s}createFrontFaceClockwiseRotator(e){const t=this.dimension-1,s=[];e===0&&s.push(...this.createSideLidClockwiseRotator(Sides.FRONT));for(let r=0;r<this.dimension;++r)s.push({source:{side:Sides.UP,x:r,y:t-e},destination:{side:Sides.RIGHT,x:e,y:r}}),s.push({source:{side:Sides.RIGHT,x:e,y:r},destination:{side:Sides.DOWN,x:t-r,y:e}}),s.push({source:{side:Sides.DOWN,x:t-r,y:e},destination:{side:Sides.LEFT,x:t-e,y:t-r}}),s.push({source:{side:Sides.LEFT,x:t-e,y:t-r},destination:{side:Sides.UP,x:r,y:t-e}});return s}createRightFaceClockwiseRotator(e){const t=this.dimension-1,s=[];e===0&&s.push(...this.createSideLidClockwiseRotator(Sides.RIGHT));for(let r=0;r<this.dimension;++r)s.push({source:{side:Sides.UP,x:t-e,y:r},destination:{side:Sides.BACK,x:e,y:t-r}}),s.push({source:{side:Sides.BACK,x:e,y:t-r},destination:{side:Sides.DOWN,x:t-e,y:r}}),s.push({source:{side:Sides.DOWN,x:t-e,y:r},destination:{side:Sides.FRONT,x:t-e,y:r}}),s.push({source:{side:Sides.FRONT,x:t-e,y:r},destination:{side:Sides.UP,x:t-e,y:r}});return s}createBackFaceClockwiseRotator(e){const t=this.dimension-1,s=[];e===0&&s.push(...this.createSideLidClockwiseRotator(Sides.BACK));for(let r=0;r<this.dimension;++r)s.push({source:{side:Sides.LEFT,x:e,y:r},destination:{side:Sides.DOWN,x:r,y:t-e}}),s.push({source:{side:Sides.DOWN,x:r,y:t-e},destination:{side:Sides.RIGHT,x:t-e,y:t-r}}),s.push({source:{side:Sides.RIGHT,x:t-e,y:t-r},destination:{side:Sides.UP,x:t-r,y:e}}),s.push({source:{side:Sides.UP,x:t-r,y:e},destination:{side:Sides.LEFT,x:e,y:r}});return s}createDownFaceClockwiseRotator(e){const t=this.dimension-1,s=[];e===0&&s.push(...this.createSideLidClockwiseRotator(Sides.DOWN));for(let r=0;r<this.dimension;++r)s.push({source:{side:Sides.LEFT,x:r,y:t-e},destination:{side:Sides.FRONT,x:r,y:t-e}}),s.push({source:{side:Sides.FRONT,x:r,y:t-e},destination:{side:Sides.RIGHT,x:r,y:t-e}}),s.push({source:{side:Sides.RIGHT,x:r,y:t-e},destination:{side:Sides.BACK,x:r,y:t-e}}),s.push({source:{side:Sides.BACK,x:r,y:t-e},destination:{side:Sides.LEFT,x:r,y:t-e}});return s}};let RubiksCubeFaceRotator=R;l(RubiksCubeFaceRotator,"faceRotatorMap",new Map);const defaultColorMap=new Map;defaultColorMap.set(Sides.FRONT,Colors.BLUE),defaultColorMap.set(Sides.UP,Colors.YELLOW),defaultColorMap.set(Sides.RIGHT,Colors.RED),defaultColorMap.set(Sides.LEFT,Colors.ORANGE),defaultColorMap.set(Sides.BACK,Colors.GREEN),defaultColorMap.set(Sides.DOWN,Colors.WHITE);class RubiksCube{constructor(e){l(this,"configuration");l(this,"dimension");l(this,"faceRotator");l(this,"colorlessCubelets");if(this.dimension=e==null?void 0:e.dimension,e!=null&&e.clone)this.dimension=Math.sqrt(e.clone.length/6),this.configuration=e.clone.slice();else{const t=this.dimension*this.dimension,s=(e==null?void 0:e.colorMap)||defaultColorMap,r=getAllSides();this.configuration="";for(let n=0;n<r.length;++n){const a=s.get(n),u=mapColorInitialsToString(a);this.configuration+=u.repeat(t)}}this.faceRotator=new RubiksCubeFaceRotator(this.dimension),this.colorlessCubelets=new CubeletsCreator(this.dimension).create()}clone(){return new RubiksCube({clone:this.configuration})}getDimension(){return this.dimension}getConfiguration(){return this.configuration}getHash(){return this.configuration}isSolved(){const e=this.dimension*this.dimension,t=getAllSides(),s=Array.from(new Array(e));return t.every((r,n)=>s.every((a,u)=>this.configuration[n*e+u]===this.configuration[n*e]))}rotateFace(e){return this.faceRotator.rotate(this,e)}getAllCubelets(){return this.addColorToCubelets(this.colorlessCubelets)}getAllColorlessCubelets(){return this.colorlessCubelets}getSideOfIndex(e){const t=getAllSides().length;return e/t}getColorlessCubeletOfIndex(e){return this.colorlessCubelets.find(t=>t.stickers.some(s=>s.id===e))}getCubeletsBySides(...e){const t=this.colorlessCubelets.filter(s=>s.stickers.every(r=>e.includes(r.side)));return this.addColorToCubelets(t)}getCubeletsByColors(...e){const t=this.colorlessCubelets.filter(s=>s.stickers.every(r=>e.includes(mapStringInitialToColor(this.configuration[r.id]))));return this.addColorToCubelets(t)}getColorOfIndex(e){return mapStringInitialToColor(this.configuration[e])}setColorsOfIndexes(e){const t=this.configuration.split("");e.forEach(s=>{t[s.index]=mapColorInitialsToString(s.color)}),this.configuration=t.join("")}addColorToCubelets(e){return e.map(t=>({stickers:t.stickers.map(s=>({...s,color:mapStringInitialToColor(this.configuration[s.id])}))}))}}var commonjsGlobal=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function getDefaultExportFromCjs(o){return o&&o.__esModule&&Object.prototype.hasOwnProperty.call(o,"default")?o.default:o}var doubleLinkedList=LinkedList;function LinkedList(){this._start=null,this._end=null,this.length=0}LinkedList.prototype.unShift=function(o){if(this._start===null)this._start=makeNode(o),this._end=this._start;else{var e=this._start;this._start.previous=makeNode(o),this._start=this._start.previous,this._start.next=e}this.length++},LinkedList.prototype.push=function(o){if(this._start===null)this._start=makeNode(o),this._end=this._start;else{var e=this._end;this._end.next=makeNode(o),this._end=this._end.next,this._end.previous=e}this.length++},LinkedList.prototype.add=function(o,e){if(o%1===0)if(o<=0)this.unShift(e);else if(o>=this.length)this.push(e);else{var t=findNode.call(this,o);if(t){var s=t.previous,r=t,n=makeNode(e);n.previous=s,s.next=n,n.next=r,r.previous=n,this.length++}}},LinkedList.prototype.shift=function(){if(this._start){var o=this._start.data;return this._start.next===null?(this._end=null,this._start=null):(this._start=this._start.next,this._start.previous=null),this.length--,o}else return},LinkedList.prototype.pop=function(){if(this._end){var o=this._end.data;return this._end.previous===null?(this._end=null,this._start=null):(this._end=this._end.previous,this._end.next=null),this.length--,o}else return},LinkedList.prototype.remove=function(o){if(o===0)return this.shift();if(o===this.length-1)return this.pop();var e=findNode.call(this,o);if(e){var t=e.previous,s=e.next;t.next=s,s.previous=t,this.length--}else return},LinkedList.prototype.first=function(){if(this._start)return this._start.data},LinkedList.prototype.last=function(){if(this._end)return this._end.data},LinkedList.prototype.get=function(o){var e=findNode.call(this,o);if(e)return e.data},LinkedList.prototype.toString=function(){for(var o=this._start,e="",t=0;t<this.length;t++)typeof o.data=="object"?e+=JSON.stringify(o.data):e+=o.data,t!==this.length-1&&(e+=", "),o=o.next;return e};function makeNode(o){return{data:o,previous:null,next:null}}function findNode(o){var e,t;if(o>=this.length||o<0||o%1!==0)e=null;else if(o<this.length/2)for(e=this._start,t=0;t<o;t++)e=e.next;else for(e=this._end,t=this.length-1;t>o;t--)e=e.previous;return e}class ProcedureMeasurer{constructor(e=!0){l(this,"map");l(this,"enabled");l(this,"measurerOverhead");l(this,"startTime");l(this,"totalTime");this.map=new Map,this.enabled=e,this.measurerOverhead=0}add(e,t){const s=performance.now();if(!this.enabled)return t();const r=t(),n=performance.now(),a=this.map.get(e)||{elapsedTime:0,calls:0,stack:"",stackSize:0};return a.elapsedTime+=n-s,++a.calls,this.map.set(e,a),this.measurerOverhead+=performance.now()-n,r}start(){this.startTime=performance.now()}finish(){this.startTime&&(this.totalTime=performance.now()-this.startTime)}getTotalTime(){return this.totalTime}getData(e){const t=[];if(this.totalTime){let s=0;Array.from(this.map.entries()).forEach(r=>{const[n,a]=r;s+=a.elapsedTime,t.push(this.createSummary(a.elapsedTime,a.calls,n))}),e!=null&&e.notMeasuredLabel&&t.push(this.createSummary(this.totalTime-s,0,e.notMeasuredLabel)),e!=null&&e.measurementOverheadLabel&&t.push(this.createSummary(this.measurerOverhead,0,e.measurementOverheadLabel))}return t}createSummary(e,t,s){const r=100*e/this.totalTime;return{label:s,totalTime:e,totalRelativeTime:Math.trunc(100*r)/100+"%",numOfCalls:t,avgTimePerCall:e*1/(t||1)}}}var Metrics$7=(o=>(o[o.ADD_CANDIDATE=0]="ADD_CANDIDATE",o[o.POP_CANDIDATE=1]="POP_CANDIDATE",o[o.HASH_CALCULATION=2]="HASH_CALCULATION",o[o.VISISTED_LIST_CHECK=3]="VISISTED_LIST_CHECK",o[o.ADD_TO_VISISTED_LIST_CHECK=4]="ADD_TO_VISISTED_LIST_CHECK",o[o.PERFORM_ROTATION=5]="PERFORM_ROTATION",o[o.NOT_MEASURED=6]="NOT_MEASURED",o))(Metrics$7||{});class BidirectionalBreadthFirstSearchSolver{constructor(e){l(this,"measurer");l(this,"forwardSearchToExploreList");l(this,"forwardSearchExploredMap");l(this,"reverseSearchToExploreList");l(this,"reverseSearchExploredMap");l(this,"actions");l(this,"iterations");l(this,"aborted");this.forwardSearchToExploreList=new doubleLinkedList,this.reverseSearchToExploreList=new doubleLinkedList,this.actions=[],this.iterations=0,this.measurer=new ProcedureMeasurer,this.forwardSearchExploredMap=new Map,this.reverseSearchExploredMap=new Map,this.aborted=!1;const t={cube:e,rotation:void 0,parent:void 0};this.forwardSearchToExploreList.push(t);const s=[],r=[Sides.RIGHT,Sides.LEFT][Math.floor(Math.random()*2)],n=[Sides.UP,Sides.DOWN][Math.floor(Math.random()*2)],a=[Sides.FRONT,Sides.BACK][Math.floor(Math.random()*2)];[r,n,a].map(S=>[!0,!1].map(m=>{s.push(getOppositeSide(S)),this.actions.push({side:S,counterClockwiseDirection:m,layer:0})}));const u=e.getCubeletsBySides(...s)[0],p={cube:this.buildSolvedCubeFromCornerCubelet(u,e.getDimension()),rotation:void 0,parent:void 0};this.reverseSearchToExploreList.push(p)}abort(){this.aborted=!0}async findSolution(){return new Promise((e,t)=>{this.measurer.start();let s,r,n=0;for(;this.forwardSearchToExploreList.length>0&&this.reverseSearchToExploreList.length>0;){if(++this.iterations,this.aborted)return t();do s=this.measurer.add(Metrics$7[1],()=>this.forwardSearchToExploreList.shift());while(this.measurer.add(Metrics$7[3],()=>this.forwardSearchExploredMap.has(s.cube.getHash())));do r=this.measurer.add(Metrics$7[1],()=>this.reverseSearchToExploreList.shift());while(this.measurer.add(Metrics$7[3],()=>this.reverseSearchExploredMap.has(r.cube.getHash())));++n;let a=this.measurer.add(Metrics$7[3],()=>this.forwardSearchExploredMap.get(r.cube.getHash()));if(a)return e(this.createSolution(a,r,n));if(a=this.measurer.add(Metrics$7[3],()=>this.reverseSearchExploredMap.get(s.cube.getHash())),a)return e(this.createSolution(s,a,n));this.measurer.add(Metrics$7[4],()=>this.forwardSearchExploredMap.set(s.cube.getHash(),s)),this.measurer.add(Metrics$7[4],()=>this.reverseSearchExploredMap.set(r.cube.getHash(),r)),this.applyRotations(this.forwardSearchToExploreList,this.forwardSearchExploredMap,s),this.applyRotations(this.reverseSearchToExploreList,this.reverseSearchExploredMap,r)}return t()})}applyRotations(e,t,s){this.actions.forEach(r=>{const n=this.measurer.add(Metrics$7[5],()=>s.cube.rotateFace(r));this.measurer.add(Metrics$7[3],()=>t.has(n.getHash()))||this.measurer.add(Metrics$7[0],()=>{e.push({cube:n,rotation:r,parent:s})})})}createSolution(e,t,s){this.measurer.finish();const r=[];let n=e;for(;n&&n.rotation;)r.unshift(n.rotation),n=n.parent;for(n=t;n&&n.rotation;){const a={...n.rotation};a.counterClockwiseDirection=!a.counterClockwiseDirection,r.push(a),n=n.parent}return{rotations:r,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:Metrics$7[6]}),iterations:this.iterations,visitedNodes:s}}}buildSolvedCubeFromCornerCubelet(e,t){const s=new Map;return e.stickers.forEach(r=>{s.set(r.side,r.color),s.set(getOppositeSide(r.side),getOppositeColor(r.color))}),new RubiksCube({colorMap:s,dimension:t})}}var Metrics$6=(o=>(o[o.ADD_CANDIDATE=0]="ADD_CANDIDATE",o[o.POP_CANDIDATE=1]="POP_CANDIDATE",o[o.CHECK_SOLUTION=2]="CHECK_SOLUTION",o[o.BREATHING_TIME=3]="BREATHING_TIME",o[o.HASH_CALCULATION=4]="HASH_CALCULATION",o[o.VISISTED_LIST_CHECK=5]="VISISTED_LIST_CHECK",o[o.ADD_TO_VISISTED_LIST_CHECK=6]="ADD_TO_VISISTED_LIST_CHECK",o[o.PERFORM_ROTATION=7]="PERFORM_ROTATION",o[o.NOT_MEASURED=8]="NOT_MEASURED",o))(Metrics$6||{});class BreadthFirstSearchSolver{constructor(e){l(this,"measurer");l(this,"candidates");l(this,"visitedChecklist");l(this,"actions");l(this,"aborted");this.measurer=new ProcedureMeasurer,this.visitedChecklist=new Map,this.candidates=new doubleLinkedList,this.aborted=!1;const t={cube:e,rotation:void 0,parent:void 0};this.candidates.push(t),this.actions=this.createActions()}abort(){this.aborted=!0}async findSolution(){return new Promise((e,t)=>{this.measurer.start();let s,r=0,n=0;for(;this.candidates.length>0;){if(this.aborted)return t();if(++r,s=this.measurer.add(Metrics$6[1],()=>this.candidates.shift()),!this.measurer.add(Metrics$6[5],()=>this.visitedChecklist.has(s.cube.getHash()))){if(++n,this.measurer.add(Metrics$6[2],()=>s.cube.isSolved()))return this.measurer.finish(),e(this.createSolution(s,r,n));this.measurer.add(Metrics$6[6],()=>this.visitedChecklist.set(s.cube.getHash(),!0)),this.applyRotations(s)}}t(Error("No more candidates to explore"))})}createSolution(e,t,s){const r=[];let n=e;for(;n&&n.rotation;)r.unshift(n.rotation),n=n.parent;return{rotations:r,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:Metrics$6[8]}),visitedNodes:t,differentNodes:s}}}createActions(){const e=[],t=[Sides.RIGHT,Sides.LEFT][Math.floor(Math.random()*2)],s=[Sides.UP,Sides.DOWN][Math.floor(Math.random()*2)],r=[Sides.FRONT,Sides.BACK][Math.floor(Math.random()*2)];return[t,s,r].map(n=>[!0,!1].map(a=>{e.push({side:n,counterClockwiseDirection:a,layer:0})})),e}applyRotations(e){this.actions.forEach(t=>{const s=this.measurer.add(Metrics$6[7],()=>e.cube.rotateFace(t));this.measurer.add(Metrics$6[5],()=>this.visitedChecklist.has(s.getHash()))||this.measurer.add(Metrics$6[0],()=>{const r={cube:s,rotation:t,parent:e};this.candidates.push(r)})})}}var Metrics$5=(o=>(o[o.ADD_CANDIDATE=0]="ADD_CANDIDATE",o[o.POP_CANDIDATE=1]="POP_CANDIDATE",o[o.CHECK_SOLUTION=2]="CHECK_SOLUTION",o[o.BREATHING_TIME=3]="BREATHING_TIME",o[o.HASH_CALCULATION=4]="HASH_CALCULATION",o[o.VISISTED_LIST_CHECK=5]="VISISTED_LIST_CHECK",o[o.ADD_TO_VISISTED_LIST_CHECK=6]="ADD_TO_VISISTED_LIST_CHECK",o[o.PERFORM_ROTATION=7]="PERFORM_ROTATION",o[o.NOT_MEASURED=8]="NOT_MEASURED",o[o.CYCLE_AVOIDANCE_CHECK=9]="CYCLE_AVOIDANCE_CHECK",o))(Metrics$5||{});class InterativeDeepeningAStarSolver{constructor(e){l(this,"measurer");l(this,"actions");l(this,"goalStateHash");l(this,"root");l(this,"numberOfStickersMovedInOneTwist");l(this,"iterations");l(this,"minBoundGrow",1.25);l(this,"currentPath");l(this,"bound");l(this,"visitedNodes");l(this,"aborted");this.iterations=[],this.measurer=new ProcedureMeasurer,this.currentPath=[],this.visitedNodes=0,this.aborted=!1,this.actions=[],[Sides.FRONT,Sides.UP,Sides.RIGHT].map(n=>[!0,!1].map(a=>{this.actions.push({side:n,counterClockwiseDirection:a,layer:0})}));const t=e.getCubeletsBySides(Sides.BACK,Sides.LEFT,Sides.DOWN)[0],s=this.buildSolvedPocketCubeFromCornerCubelet(t,e.getDimension());this.goalStateHash=s.getHash();const r=e.getDimension();this.numberOfStickersMovedInOneTwist=r*r+r*getAdjacentSides(Sides.UP).length,this.bound=this.calculateDistanceToFinalState(e),this.root={cube:e,rotation:void 0,parent:void 0}}abort(){this.aborted=!0}async findSolution(){let e=0;return new Promise((t,s)=>{for(this.measurer.start();!this.aborted;){this.currentPath=[this.root.cube.getHash()];const r=this.search(this.root,0);if(r.solution)return t(this.createSolution(r.solution));if(r.aborted)break;{const n=this.visitedNodes-e;this.iterations.push({newNodesVisited:n,bound:this.bound}),e=this.visitedNodes,this.bound=Math.max(r.cost,this.bound+this.minBoundGrow)}}s(Error("Aborted"))})}search(e,t){if(++this.visitedNodes,this.aborted)return{aborted:!0};let s=this.calculateDistanceToFinalState(e.cube);if(e.cube.isSolved())return{solution:e};let r=1/0;const n=this.applyRotations(e);for(let a of n){const u=t+s;if(u>this.bound)return{cost:u};const g=a.cube.getHash();if(this.measurer.add(Metrics$5[9],()=>this.currentPath.every(p=>p!==g))){this.currentPath.push(g);const p=this.search(a,t+1);if(p.solution||p.aborted)return p;s=Math.min(s,p.cost-1),r=Math.min(p.cost,r),this.currentPath.pop()}}return{cost:r}}createSolution(e){this.measurer.finish();const t=[];let s=e;for(;s&&s.rotation;)t.unshift(s.rotation),s=s.parent;return{rotations:t,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:Metrics$5[8]}),visitedNodes:this.visitedNodes,iterations:this.iterations}}}applyRotations(e){const t=[];return this.actions.forEach(s=>{const r=this.measurer.add(Metrics$5[7],()=>e.cube.rotateFace(s));this.measurer.add(Metrics$5[0],()=>{t.push({cube:r,rotation:s,parent:e})})}),t}calculateDistanceToFinalState(e){return e.getConfiguration().split("").filter((s,r)=>s!==this.goalStateHash[r]).length/this.numberOfStickersMovedInOneTwist}buildSolvedPocketCubeFromCornerCubelet(e,t){const s=new Map;return e.stickers.forEach(r=>{s.set(r.side,r.color),s.set(getOppositeSide(r.side),getOppositeColor(r.color))}),new RubiksCube({colorMap:s,dimension:t})}}var Metrics$4=(o=>(o[o.ADD_CANDIDATE=0]="ADD_CANDIDATE",o[o.POP_CANDIDATE=1]="POP_CANDIDATE",o[o.CHECK_SOLUTION=2]="CHECK_SOLUTION",o[o.BREATHING_TIME=3]="BREATHING_TIME",o[o.HASH_CALCULATION=4]="HASH_CALCULATION",o[o.VISISTED_LIST_CHECK=5]="VISISTED_LIST_CHECK",o[o.ADD_TO_VISISTED_LIST_CHECK=6]="ADD_TO_VISISTED_LIST_CHECK",o[o.PERFORM_ROTATION=7]="PERFORM_ROTATION",o[o.NOT_MEASURED=8]="NOT_MEASURED",o))(Metrics$4||{});class InterativeDeepeningDepthFirstSearchSolver{constructor(e){l(this,"measurer");l(this,"actions");l(this,"root");l(this,"currentMaxDepth");l(this,"visitedNodes");l(this,"aborted");this.measurer=new ProcedureMeasurer,this.visitedNodes=0,this.aborted=!1,this.actions=this.createActions();const t=e.getCubeletsBySides(Sides.BACK,Sides.LEFT,Sides.DOWN)[0],s=this.buildSolvedPocketCubeFromCornerCubelet(t,e.getDimension());this.currentMaxDepth=this.calculateDistanceToFinalState(e,s.getConfiguration()),this.root={cube:e,rotation:void 0,parent:void 0}}abort(){this.aborted=!0}async findSolution(){return new Promise((e,t)=>{for(this.measurer.start();!this.aborted;){const s=this.beginSearch(this.root,0);if(s)return this.measurer.finish(),e(this.createSolution(s));++this.currentMaxDepth}t(Error("Aborted"))})}beginSearch(e,t){if(++this.visitedNodes,!this.aborted){if(t<this.currentMaxDepth){const s=this.applyRotations(e);for(let r of s){const n=this.beginSearch(r,t+1);if(n)return n}}else if(t===this.currentMaxDepth&&e.cube.isSolved())return e}}createActions(){const e=[];return[Sides.FRONT,Sides.UP,Sides.RIGHT].map(t=>[!0,!1].map(s=>{e.push({side:t,counterClockwiseDirection:s,layer:0})})),e}createSolution(e){const t=[];let s=e;for(;s&&s.rotation;)t.unshift(s.rotation),s=s.parent;return{rotations:t,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:Metrics$4[8]}),visitedNodes:this.visitedNodes}}}applyRotations(e){const t=[];return this.actions.forEach(s=>{const r=this.measurer.add(Metrics$4[7],()=>e.cube.rotateFace(s));this.measurer.add(Metrics$4[0],()=>{t.push({cube:r,rotation:s,parent:e})})}),t}calculateDistanceToFinalState(e,t){const s=e.getDimension()*e.getDimension()+e.getDimension()*4,r=e.getConfiguration();return Math.ceil(r.split("").filter((n,a)=>n!==t[a]).length/s)}buildSolvedPocketCubeFromCornerCubelet(e,t){const s=new Map;return e.stickers.forEach(r=>{s.set(r.side,r.color),s.set(getOppositeSide(r.side),getOppositeColor(r.color))}),new RubiksCube({colorMap:s,dimension:t})}}var heapExports$1={},heap$1={get exports(){return heapExports$1},set exports(o){heapExports$1=o}},heapExports={},heap={get exports(){return heapExports},set exports(o){heapExports=o}};(function(o,e){(function(){var t,s,r,n,a,u,g,p,S,m,I,A,D,_,w;r=Math.floor,m=Math.min,s=function(d,c){return d<c?-1:d>c?1:0},S=function(d,c,h,f,T){var C;if(h==null&&(h=0),T==null&&(T=s),h<0)throw new Error("lo must be non-negative");for(f==null&&(f=d.length);h<f;)C=r((h+f)/2),T(c,d[C])<0?f=C:h=C+1;return[].splice.apply(d,[h,h-h].concat(c)),c},u=function(d,c,h){return h==null&&(h=s),d.push(c),_(d,0,d.length-1,h)},a=function(d,c){var h,f;return c==null&&(c=s),h=d.pop(),d.length?(f=d[0],d[0]=h,w(d,0,c)):f=h,f},p=function(d,c,h){var f;return h==null&&(h=s),f=d[0],d[0]=c,w(d,0,h),f},g=function(d,c,h){var f;return h==null&&(h=s),d.length&&h(d[0],c)<0&&(f=[d[0],c],c=f[0],d[0]=f[1],w(d,0,h)),c},n=function(d,c){var h,f,T,C,b,E;for(c==null&&(c=s),C=function(){E=[];for(var O=0,v=r(d.length/2);0<=v?O<v:O>v;0<=v?O++:O--)E.push(O);return E}.apply(this).reverse(),b=[],f=0,T=C.length;f<T;f++)h=C[f],b.push(w(d,h,c));return b},D=function(d,c,h){var f;if(h==null&&(h=s),f=d.indexOf(c),f!==-1)return _(d,0,f,h),w(d,f,h)},I=function(d,c,h){var f,T,C,b,E;if(h==null&&(h=s),T=d.slice(0,c),!T.length)return T;for(n(T,h),E=d.slice(c),C=0,b=E.length;C<b;C++)f=E[C],g(T,f,h);return T.sort(h).reverse()},A=function(d,c,h){var f,T,C,b,E,O,v,L,y;if(h==null&&(h=s),c*10<=d.length){if(C=d.slice(0,c).sort(h),!C.length)return C;for(T=C[C.length-1],v=d.slice(c),b=0,O=v.length;b<O;b++)f=v[b],h(f,T)<0&&(S(C,f,0,null,h),C.pop(),T=C[C.length-1]);return C}for(n(d,h),y=[],E=0,L=m(c,d.length);0<=L?E<L:E>L;0<=L?++E:--E)y.push(a(d,h));return y},_=function(d,c,h,f){var T,C,b;for(f==null&&(f=s),T=d[h];h>c;){if(b=h-1>>1,C=d[b],f(T,C)<0){d[h]=C,h=b;continue}break}return d[h]=T},w=function(d,c,h){var f,T,C,b,E;for(h==null&&(h=s),T=d.length,E=c,C=d[c],f=2*c+1;f<T;)b=f+1,b<T&&!(h(d[f],d[b])<0)&&(f=b),d[c]=d[f],c=f,f=2*c+1;return d[c]=C,_(d,E,c,h)},t=function(){d.push=u,d.pop=a,d.replace=p,d.pushpop=g,d.heapify=n,d.updateItem=D,d.nlargest=I,d.nsmallest=A;function d(c){this.cmp=c??s,this.nodes=[]}return d.prototype.push=function(c){return u(this.nodes,c,this.cmp)},d.prototype.pop=function(){return a(this.nodes,this.cmp)},d.prototype.peek=function(){return this.nodes[0]},d.prototype.contains=function(c){return this.nodes.indexOf(c)!==-1},d.prototype.replace=function(c){return p(this.nodes,c,this.cmp)},d.prototype.pushpop=function(c){return g(this.nodes,c,this.cmp)},d.prototype.heapify=function(){return n(this.nodes,this.cmp)},d.prototype.updateItem=function(c){return D(this.nodes,c,this.cmp)},d.prototype.clear=function(){return this.nodes=[]},d.prototype.empty=function(){return this.nodes.length===0},d.prototype.size=function(){return this.nodes.length},d.prototype.clone=function(){var c;return c=new d,c.nodes=this.nodes.slice(0),c},d.prototype.toArray=function(){return this.nodes.slice(0)},d.prototype.insert=d.prototype.push,d.prototype.top=d.prototype.peek,d.prototype.front=d.prototype.peek,d.prototype.has=d.prototype.contains,d.prototype.copy=d.prototype.clone,d}(),function(d,c){return o.exports=c()}(this,function(){return t})}).call(commonjsGlobal)})(heap),function(o){o.exports=heapExports}(heap$1);var Heap=getDefaultExportFromCjs(heapExports$1),Metrics$3=(o=>(o[o.ADD_CANDIDATE=0]="ADD_CANDIDATE",o[o.POP_CANDIDATE=1]="POP_CANDIDATE",o[o.CHECK_SOLUTION=2]="CHECK_SOLUTION",o[o.BREATHING_TIME=3]="BREATHING_TIME",o[o.HASH_CALCULATION=4]="HASH_CALCULATION",o[o.VISISTED_LIST_CHECK=5]="VISISTED_LIST_CHECK",o[o.ADD_TO_VISISTED_LIST_CHECK=6]="ADD_TO_VISISTED_LIST_CHECK",o[o.PERFORM_ROTATION=7]="PERFORM_ROTATION",o[o.NOT_MEASURED=8]="NOT_MEASURED",o[o.HEURISTIC_CALCULATION=9]="HEURISTIC_CALCULATION",o[o.GET_ALL_CUBELETS=10]="GET_ALL_CUBELETS",o[o.CUBELET_FINAL_POSITION=11]="CUBELET_FINAL_POSITION",o[o.CUBELET_SIMILARITY=12]="CUBELET_SIMILARITY",o[o.ITERATION=13]="ITERATION",o[o.SOLUTION_CREATION=14]="SOLUTION_CREATION",o[o.MEASUREMENT_OVERHEAD=15]="MEASUREMENT_OVERHEAD",o[o.ITERATIONS_COUNTER_INCREMENT=16]="ITERATIONS_COUNTER_INCREMENT",o[o.ABORTED_VERIFICATION=17]="ABORTED_VERIFICATION",o[o.BUILD_SOLUTION=18]="BUILD_SOLUTION",o))(Metrics$3||{});class WeightedAStarSolver{constructor(e){l(this,"measurer");l(this,"candidates");l(this,"visitedChecklist");l(this,"actions");l(this,"dimension");l(this,"goalStateHash");l(this,"aborted");this.aborted=!1,this.dimension=e.getDimension(),this.candidates=new Heap((n,a)=>n.cost+WeightedAStarAlgorithmConfig.heuristicWeight*n.heuristicValue-(a.cost+WeightedAStarAlgorithmConfig.heuristicWeight*a.heuristicValue)),this.visitedChecklist=new Map;const t={cost:0,heuristicValue:0,cube:e,rotation:void 0,parentHash:void 0,hash:e.getHash()};this.candidates.push(t),this.actions=[];const s=e.getCubeletsBySides(Sides.BACK,Sides.LEFT,Sides.DOWN)[0],r=this.buildSolvedPocketCubeFromCornerCubelet(s);this.goalStateHash=r.getHash(),[Sides.FRONT,Sides.UP,Sides.RIGHT].map(n=>[!0,!1].map(a=>{this.actions.push({side:n,counterClockwiseDirection:a,layer:0})})),this.measurer=new ProcedureMeasurer(Configuration.metrics.enabled)}async findSolution(){return new Promise((e,t)=>{this.measurer.start();let s,r=0,n=0;for(;this.measurer.add(Metrics$3[16],()=>this.candidates.size()>0);){if(this.measurer.add(Metrics$3[17],()=>this.aborted))return t();if(this.measurer.add(Metrics$3[16],()=>++r),s=this.measurer.add(Metrics$3[1],()=>this.candidates.pop()),!this.measurer.add(Metrics$3[5],()=>this.visitedChecklist.has(s.hash))){if(++n,this.measurer.add(Metrics$3[2],()=>s.hash===this.goalStateHash))return e(this.measurer.add(Metrics$3[14],()=>this.createSolution(s,r,n)));this.measurer.add(Metrics$3[6],()=>this.visitedChecklist.set(s.hash,s)),this.applyRotations(s)}}t(Error("No more candidates to explore"))})}abort(){this.aborted=!0}createSolution(e,t,s){const r=[];let n=e;return this.measurer.add(Metrics$3[18],()=>{for(;n&&n.rotation;)r.unshift(n.rotation),n=this.visitedChecklist.get(n.parentHash)}),this.measurer.finish(),this.candidates.clear(),{rotations:r,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:Metrics$3[8],measurementOverheadLabel:Metrics$3[15]}),visitedNodes:t,differentNodes:s}}}applyRotations(e){for(let t of this.actions){const s=this.measurer.add(Metrics$3[7],()=>e.cube.rotateFace(t)),r=s.getHash(),n=this.measurer.add(Metrics$3[9],()=>this.calculateDistanceToFinalState(s)),a={cost:e.cost+1,cube:s,rotation:t,heuristicValue:n,parentHash:e.hash,hash:r};this.measurer.add(Metrics$3[5],()=>this.visitedChecklist.get(r))||this.measurer.add(Metrics$3[0],()=>{this.candidates.push(a)})}}calculateDistanceToFinalState(e){const t=this.dimension*this.dimension+this.dimension*4;return e.getConfiguration().split("").filter((r,n)=>r!==this.goalStateHash[n]).length/t}buildSolvedPocketCubeFromCornerCubelet(e){const t=new Map;return e.stickers.forEach(s=>{t.set(s.side,s.color),t.set(getOppositeSide(s.side),getOppositeColor(s.color))}),new RubiksCube({colorMap:t,dimension:this.dimension})}}class CubeScrambler{constructor(e=30){l(this,"moves");this.moves=e}scramble(e){let t;const s=Math.floor(e.getDimension()/2),r=getAllSides(),n=[];return Array.from(new Array(this.moves)).forEach(()=>{const a=Math.floor(Math.random()*6)===0,u=Math.floor(Math.random()*2)===0,g=Math.floor(Math.random()*s);let p=Math.floor(Math.random()*r.length),S={side:p,counterClockwiseDirection:u,layer:g};for(;t!==void 0&&t.side===S.side&&t.layer===S.layer;)p=Math.floor(Math.random()*r.length),S={side:p,counterClockwiseDirection:u,layer:g};t=S,a&&(S.counterClockwiseDirection=!1,n.push(S)),n.push(S)}),n.filter((a,u)=>u<this.moves)}}class GeneticAlgorithm{constructor(e,t,s){l(this,"orientationList");l(this,"mutationList");l(this,"original");l(this,"generationsCounter");this.original=e,this.mutationList=t,this.orientationList=s,this.generationsCounter=0}createNextGeneration(e){if(++this.generationsCounter,!e)return this.createNewPopulationFromScratch();const t=e.sort((r,n)=>{const a=r.score-n.score;return a===0?r.genes.length-n.genes.length:a});if(this.generationsCounter%GeneticAlgorithmConfig.armageddonThreshold===0)return console.log(`armageddon. best: ${t[0].score}/${t[t.length-1].score}, moves list: ${t[0].genes.length}`),this.createNewPopulationFromScratch();const s=t.filter((r,n)=>n<GeneticAlgorithmConfig.elitism);return Array.from(Array(GeneticAlgorithmConfig.populationPerGeneration)).map(()=>this.reproduceCitizens(s))}getGenerationsCounter(){return this.generationsCounter}createNewPopulationFromScratch(){return Array.from(new Array(GeneticAlgorithmConfig.populationPerGeneration)).map(()=>({cube:this.original.clone(),genes:[],score:NaN,newGenes:new CubeScrambler(GeneticAlgorithmConfig.numberOfInitialScrambleMovements).scramble(this.original)}))}reproduceCitizens(e){const t=e[Math.floor(Math.random()*e.length)],s=[],r=()=>this.mutationList[Math.floor(Math.random()*this.mutationList.length)],n=()=>this.orientationList[Math.floor(Math.random()*this.orientationList.length)];switch(Math.floor(Math.random()*5)){case 0:s.push(...r());break;case 1:s.push(...r()),s.push(...r());break;case 2:s.push(...n()),s.push(...r());break;case 3:s.push(...n()),s.push(...n()),s.push(...r());break;case 4:s.push(...r());break}return{cube:t.cube.clone(),genes:[...t.genes.slice(0)],newGenes:s,score:NaN}}}var srcExports={},src={get exports(){return srcExports},set exports(o){srcExports=o}};(function(module){var colorList={reset:[0,0],bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],inverse:[7,27],hidden:[8,28],strikethrough:[9,29],black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],gray:[90,39],grey:[90,39],redBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39],bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],blackBG:[40,49],redBG:[41,49],greenBG:[42,49],yellowBG:[43,49],blueBG:[44,49],magentaBG:[45,49],cyanBG:[46,49],whiteBG:[47,49],bgBlackBright:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]};if(typeof process>"u"||!process.env)var process={env:{},argv:["--color"]};var isDisabled={}.NO_COLOR||process.argv.includes("--no-color"),isSupported=!isDisabled&&({}.FORCE_COLOR||process.platform==="win32"||process.argv.includes("--color")||eval("require('tty')").isatty(1)&&{}.TERM!=="dumb"||{}.CI),TObject=typeof Reflect>"u"?Object:Reflect,fncache={};function extend(o,e){var t=e.join("");return Object.keys(colorList).forEach(function(s){var r=t+s;TObject.defineProperty(o,s,{get(){return fncache[r]||(fncache[r]=extend(function(a){return o(color[s](a))},e.concat(s))),fncache[r]}})}),o}function replaceClose(o,e,t,s){var r=o.substring(s+t.length),n=r.indexOf(t);return o.substring(0,s)+e+(~n?replaceClose(r,e,t,n):r)}function getFn(o){var e=colorList[o];if(!e||!isSupported)return function(r){return String(r)};var t=e[0],s=e[1];return function(r){if(r===""||r==null)return"";r=""+r;var n=r.indexOf(s,t.length);return t+(n>-1&&n<r.length-1?replaceClose(r,t,s,n):r)+s}}function color(o,e){return getFn(e)(o)}color.list=colorList;function init(){Object.keys(colorList).forEach(function(o){clc[o]=color[o]=extend(getFn(o),[o])})}for(var clc={color,list:colorList,log(o,e){console.log(color(o,e))},isSupported(){return isSupported},enable(){isSupported=!0,init()},disable(){isSupported=!1,init()},strip(o){return o.replace(/\x1b\[\d+m/gm,"")}},i=0;i<256;i++)colorList["c"+i]=["38;5;"+i,0],colorList["bg"+i]=["48;5;"+i,0];Object.keys(colorList).forEach(function(o){colorList[o]=colorList[o].map(function(e){return"\x1B["+e+"m"}),clc.log[o]=function(){for(var e=[],t=0;t<arguments.length;t++)e.push(arguments[t]);console.log(color[o](e.join(" ")))}}),init(),module.exports=clc})(src);var clc=srcExports;const{log,color,list,isSupported,disable,enable,strip,reset,bold,dim,italic,underline,inverse,hidden,strikethrough,black,red,green,yellow,blue,magenta,cyan,white,gray,grey,redBright,greenBright,yellowBright,blueBright,magentaBright,cyanBright,whiteBright,bgBlack,bgRed,bgGreen,bgYellow,bgBlue,bgMagenta,bgCyan,bgWhite,blackBG,redBG,greenBG,yellowBG,blueBG,magentaBG,cyanBG,whiteBG,bgBlackBright,bgRedBright,bgGreenBright,bgYellowBright,bgBlueBright,bgMagentaBright,bgCyanBright,bgWhiteBright}=clc,rotationsAreEqual=(o,e)=>o.layer===e.layer&&o.side===e.side&&o.counterClockwiseDirection===e.counterClockwiseDirection,rotationsCancel=(o,e)=>o.layer===e.layer&&o.side===e.side&&o.counterClockwiseDirection!==e.counterClockwiseDirection,getOppositeRotation=o=>({layer:o.layer,side:o.side,counterClockwiseDirection:!o.counterClockwiseDirection});class HumanTranslator{translateSide(e,t){const s=t.getAllCubelets(),r=t.getDimension(),n=10,a=(g,p,S)=>{for(const m of s){const I=m.stickers.find(A=>A.side===g&&A.x===p&&A.y===S);if(I)return I}console.log(`Sticker not found: ${Sides[g]}, ${p}, ${S}`)},u=[];u.push(`${(Sides[e]+Array.from(new Array(n)).fill(" ").join("")).substring(0,n)}`);for(let g=0;g<r;++g){let p="";for(let S=0;S<r;++S){const m=a(e,S,g),I=Colors[m.color].substring(0,1)+HumanTranslator.mapToSubscript(`${("  "+m.id).slice(-2)}  `);let A=Colors[m.color].toLowerCase();A==="white"&&(A="gray"),A==="orange"&&(A="redBright");const D=color[A](I);p+=D}u.push(p)}return u}printCube(e){const t=e.getDimension(),s=this.translateSide(Sides.UP,e),r=this.translateSide(Sides.LEFT,e),n=this.translateSide(Sides.FRONT,e),a=this.translateSide(Sides.RIGHT,e),u=this.translateSide(Sides.BACK,e),g=this.translateSide(Sides.DOWN,e);let p="";const S=Array.from(new Array(s[1].length/3)).fill(" ").join("");s.forEach(m=>{p+=S+m+`
`}),p+=r[0],p+=(S+n[0]).slice(-S.length),p+=(S+a[0]).slice(-S.length),p+=(S+u[0]).slice(-S.length)+`
`;for(let m=1;m<t+1;++m)p+=r[m],p+=n[m],p+=a[m],p+=u[m]+`
`;g.forEach(m=>{p+=S+m+`
`}),console.log(p)}convertStringToFaceRotations(e){return e.length===0?[]:e.match(/((\d?)(\w)(\d?)('?))\s*/g).reduce((t,s)=>{const[r,n,a,u,g]=s.match(/(\d?)(\w)(\d?)('?)\s*/),p={side:Sides.UP,counterClockwiseDirection:(g==null?void 0:g.length)>0,layer:Number((u==null?void 0:u.length)>0)};switch(a.toLowerCase()){case"u":p.side=Sides.UP;break;case"l":p.side=Sides.LEFT;break;case"f":p.side=Sides.FRONT;break;case"r":p.side=Sides.RIGHT;break;case"b":p.side=Sides.BACK;break;case"d":p.side=Sides.DOWN;break;default:return t}return(n==null?void 0:n.length)>0?t.push([p,p]):t.push([p]),t},[])}translateRotations(e,t){const s=[...e];let r=0,n="";t!=null&&t.showNumberOfMoves&&(r++,n+=`${e.length}:      `.substring(0,4));let a=s.shift();for(;a;){const u=s[0];let g=" ";u&&rotationsAreEqual(u,a)&&(s.shift(),g="2");let p="";if(t&&t.showLayer){let m=1;a.layer!==void 0&&(m=a.layer+1),p=m.toString(),t.subscript&&(p=HumanTranslator.mapToSubscript(m.toString()))}const S=a.counterClockwiseDirection;n+=`${g}${Sides[a.side].substring(0,1)}${S?"'":" "}${p}  `,(t==null?void 0:t.lineBreak)!==void 0&&r%(t==null?void 0:t.lineBreak)===(t==null?void 0:t.lineBreak)-1&&(n+=`
`),++r,a=s.shift()}return n}translateCubelets(e){let t="";return e.map(s=>{s.stickers.map(r=>{const n=Colors[r.color],a=Sides[r.side],u=HumanTranslator.mapToSmallTopLetters(r.id.toString()),g=`${HumanTranslator.mapToSubscript("("+r.x+","+r.y+")")}`;t+=`${n.substring(0,1).toUpperCase().concat(n.substring(1).toLowerCase())}: ${a}${u}${g};  `}),t+=`
`}),t}static mapToSmallTopLetters(e){const t=new Map;return t.set("0","⁰"),t.set("1","¹"),t.set("2","²"),t.set("3","³"),t.set("4","⁴"),t.set("5","⁵"),t.set("6","⁶"),t.set("7","⁷"),t.set("8","⁸"),t.set("9","⁹"),t.set(",","﹐"),e.split("").map(s=>t.has(s)?t.get(s):s).join("")}static mapToSubscript(e){const t=new Map;return t.set("0","₀"),t.set("1","₁"),t.set("2","₂"),t.set("3","₃"),t.set("4","₄"),t.set("5","₅"),t.set("6","₆"),t.set("7","₇"),t.set("8","₈"),t.set("9","₉"),t.set("0","₀"),t.set("(","₍"),t.set(")","₎"),e.split("").map(s=>t.has(s)?t.get(s):s).join("")}}class RotationsTuner{tune(e){const t=[];let s,r=!1,n=1;for(let a of e){if(s&&rotationsCancel(a,s))t.pop(),r=!0,n=0;else{if(s)if(rotationsAreEqual(s,a)){if(++n,n===3){t.pop(),t.pop(),t.push(getOppositeRotation(a)),n=0,r=!0;continue}}else rotationsAreEqual(s,a)||(n=1);t.push(a)}s=a}return r?this.tune(t):t}}var Metrics$2=(o=>(o[o.NOT_MEASURED=0]="NOT_MEASURED",o[o.RUN_CITIZEN_ROTATIONS=1]="RUN_CITIZEN_ROTATIONS",o[o.CALCULATE_CITIZEN_SCORE=2]="CALCULATE_CITIZEN_SCORE",o[o.ROTATIONS_TUNING=3]="ROTATIONS_TUNING",o))(Metrics$2||{});const orientations=["F F2 F3","F' F2' F3'","2F 2F2 2F3","R R2 R3","R' R2' R3'","2R 2R2 2R3","U U2 U3","U' U2' U3'","2U 2U2 2U3"],supervisedPermutations=["2R2 2F2 2F2","F' L' B' R' U' R U' B L F R U R' U","F R B L U L' U B' R' F' L' U' L U'","2U B 2U B' 2R F R' F' 2U F' 2U F R'","2U R 2U R' 2F L F' L' 2U L' 2U L F'","U' 2B 2D L' 2F 2D 2B R' U'","U 2B 2D R 2F 2D 2B L U","D' R' D 2R U' R 2B L U' L' 2B U 2R","D L D' 2L U L' 2B R' U R 2B U' 2L","R' U L' 2U R U' L R' U L' 2U R U' L U'","L U' R 2U L' U R' L U' R 2U L' U R' U","F' U B U' F U B' U'","F U' B' U F' U' B U","L' 2U L R' 2F R","R' 2U R L' 2B L","2R2 U 2R2 2U 2R2 U 2R2"];class GeneticAlgorithmSolver{constructor(e){l(this,"measurer");l(this,"initialState");l(this,"geneticAlgorithm");l(this,"citizens");l(this,"aborted");l(this,"armageddonCounter");this.measurer=new ProcedureMeasurer,this.initialState=e.clone(),this.aborted=!1,this.armageddonCounter=0;const t=new HumanTranslator;this.geneticAlgorithm=new GeneticAlgorithm(this.initialState,supervisedPermutations.flatMap(s=>t.convertStringToFaceRotations(s)),orientations.flatMap(s=>t.convertStringToFaceRotations(s))),this.citizens=this.geneticAlgorithm.createNextGeneration()}async findSolution(){return this.measurer.start(),new Promise((e,t)=>{for(;;){if(this.aborted)return t();const s=[];for(let r of this.citizens){const n=this.runCitizen(r);if(n.score===0)return e(this.createSolution(n));s.push(n)}this.citizens=this.geneticAlgorithm.createNextGeneration(s)}})}abort(){this.aborted=!0}runCitizen(e){let t=e.genes.slice(),s=e.cube.clone(),r={genes:t,score:1/0,newGenes:[],cube:s.clone()};for(let n of e.newGenes){t.push(n),s=s.rotateFace(n);const a=this.calculateCitizenScore(e.cube);if(a<r.score){if(a===0)return r;r={genes:t,score:a,newGenes:[],cube:s.clone()}}}return r}calculateCitizenScore(e){return this.measurer.add(Metrics$2[2],()=>{const t=e.getConfiguration(),s=this.buildSolvedCubeFromCenterCubelets(e).getConfiguration();return t.split("").filter((r,n)=>r!==s[n]).length})}createSolution(e){const t=this.measurer.add(Metrics$2[3],()=>new RotationsTuner().tune(e.genes));return this.measurer.finish(),{rotations:t,totalTime:this.measurer.getTotalTime(),data:{armageddonCounter:this.armageddonCounter,metrics:this.measurer.getData({notMeasuredLabel:Metrics$2[0]}),generations:this.geneticAlgorithm.getGenerationsCounter()}}}buildSolvedCubeFromCenterCubelets(e){const t=e.getAllColorlessCubelets().filter(r=>r.stickers.length===1).map(r=>r.stickers[0].id),s=new Map;return getAllSides().forEach((r,n)=>{s.set(r,e.getColorOfIndex(t[n]))}),new RubiksCube({colorMap:s,dimension:this.initialState.getDimension()})}}class NeuroGeneticAlgorithm{constructor(e,t){l(this,"mutationRate");l(this,"populationPerGeneration");l(this,"generationsCounter");this.generationsCounter=0,this.mutationRate=e,this.populationPerGeneration=t}createNextGeneration(e){++this.generationsCounter;const t=e.reduce((r,n)=>({bestScore:Math.max(r.bestScore,n.score),score:r.score+n.score,movesLength:r.movesLength+n.genes.length}),{score:0,movesLength:0,bestScore:0});this.generationsCounter%10===0&&console.log(`${this.generationsCounter} >. score sum: ${t.score}. best: ${t.bestScore}. moves length: ${t.movesLength/e.length}`);const s=e.map(r=>({genes:r.genes,score:parseFloat(r.score.toString())/t.score}));return Array.from(Array(this.populationPerGeneration)).map(()=>this.createNewCitizen(this.pickOne(s),this.pickOne(s)))}getGenerationsCounter(){return this.generationsCounter}createNewCitizen(e,t){const s=Math.floor(Math.random()*e.genes.length);return{genes:e.genes.map((n,a)=>{let u=e.genes[a];return a>s&&(u=t.genes[a]),Math.random()<this.mutationRate&&(u*=Math.random()*2-1),u}),score:NaN}}pickOne(e){let t=0,s=Math.random();for(;s>0;)s-=e[t].score,++t;return--t,e[t]}}class NeuralNetwork{constructor(e,t){l(this,"weights");l(this,"config");if(this.config=e,t)this.weights=t;else{let s=this.config.inputs+this.config.outputs;this.config.bias!==void 0&&(s+=1);const r=s*this.config.hiddenNeurons;this.weights=Array.from(Array(r)).map(()=>Math.random()*2-1)}}getWeights(){return this.weights}doTheMagic(e){if(e.length!==this.config.inputs)throw new Error(`Amount of function argument '${e.length}' should match configuration inputs quantity '${this.config.inputs}'`);const t=[...e,this.config.bias],s=NeuralNetwork.processLayer(t,this.weights.filter((r,n)=>n>=0&&n<this.config.inputs*this.config.hiddenNeurons),this.config.hiddenNeurons);return NeuralNetwork.processLayer(s,this.weights.filter((r,n)=>n>=this.config.inputs*this.config.hiddenNeurons),this.config.outputs)}static processLayer(e,t,s){const r=Array.from(Array(s)).map(()=>0);return t.reduce((n,a,u)=>(n[u%s]+=a*e[u%e.length],n),r).map(n=>Math.tanh(n))}}var Metrics$1=(o=>(o[o.NOT_MEASURED=0]="NOT_MEASURED",o[o.RUN_NEURAL_NETWORK=1]="RUN_NEURAL_NETWORK",o[o.CALCULATE_CITIZEN_SCORE=2]="CALCULATE_CITIZEN_SCORE",o[o.ROTATIONS_TUNING=3]="ROTATIONS_TUNING",o[o.MEASUREMENT_OVERHEAD=4]="MEASUREMENT_OVERHEAD",o))(Metrics$1||{});class NeuroEvolutionarySolver{constructor(e){l(this,"measurer");l(this,"inputs");l(this,"initialState");l(this,"goalStateHash");l(this,"actions");l(this,"neuroGeneticAlgorithm");l(this,"citizens");l(this,"aborted");l(this,"armageddonCounter");this.aborted=!1,this.measurer=new ProcedureMeasurer,this.armageddonCounter=0,this.neuroGeneticAlgorithm=new NeuroGeneticAlgorithm(NeuroEvolutionaryConfig.geneticData.mutationRate,NeuroEvolutionaryConfig.geneticData.populationPerGeneration),this.initialState=e.clone(),this.inputs=e.getConfiguration().length,this.actions=[];const t=e.getCubeletsBySides(Sides.BACK,Sides.LEFT,Sides.DOWN)[0],s=this.buildSolvedPocketCubeFromCornerCubelet(t);this.goalStateHash=s.getHash(),[Sides.FRONT,Sides.UP,Sides.RIGHT].map(r=>[!0,!1].map(n=>{this.actions.push({side:r,counterClockwiseDirection:n,layer:0})})),this.citizens=this.createNewPopulationFromScratch()}async findSolution(){return this.measurer.start(),new Promise((e,t)=>{for(;;){if(this.aborted)return t();for(let s of this.citizens)if(this.runCitizen(s))return e(this.createSolution(s));if(this.neuroGeneticAlgorithm.getGenerationsCounter()>NeuroEvolutionaryConfig.geneticData.armageddonThreshold){++this.armageddonCounter;const s=this.citizens.reduce((r,n)=>Math.max(this.calculateCitizenScore(n.cube),r),0);console.log(`armageddon. best score from generation: ${s}`),this.citizens=this.createNewPopulationFromScratch()}else this.citizens=this.createNewPopulationFromPreviousOne()}})}abort(){this.aborted=!0}createNewPopulationFromScratch(){return this.neuroGeneticAlgorithm=new NeuroGeneticAlgorithm(NeuroEvolutionaryConfig.geneticData.mutationRate,NeuroEvolutionaryConfig.geneticData.populationPerGeneration),Array.from(new Array(NeuroEvolutionaryConfig.geneticData.populationPerGeneration)).map(()=>{const e=new NeuralNetwork({inputs:this.inputs,hiddenNeurons:NeuroEvolutionaryConfig.neuralNetworkData.hiddenNeurons,outputs:this.actions.length,bias:1});return{genes:e.getWeights(),neuralNetwork:e,cube:this.initialState.clone(),moves:[]}})}createNewPopulationFromPreviousOne(){return this.neuroGeneticAlgorithm.createNextGeneration(this.citizens.map(e=>({genes:e.genes,score:this.calculateCitizenScore(e.cube)}))).map(e=>{const t=new NeuralNetwork({inputs:this.inputs,hiddenNeurons:NeuroEvolutionaryConfig.neuralNetworkData.hiddenNeurons,outputs:this.actions.length,bias:1},e.genes);return{genes:e.genes,neuralNetwork:t,cube:this.initialState.clone(),moves:[]}})}runCitizen(e){return Array.from(new Array(NeuroEvolutionaryConfig.neuralNetworkData.iterations)).reduce(t=>t||this.measurer.add(Metrics$1[1],()=>{const r=e.cube.getConfiguration().split("").map(u=>mapStringInitialToColor(u));let a=e.neuralNetwork.doTheMagic(r).reduce((u,g,p)=>((u.index===-1||g>u.value)&&(u.value=g,u.index=p),u),{index:-1,value:0});if(a.value>.5){const u=this.actions[a.index];if(e.cube=e.cube.rotateFace(u),console.log(u),e.moves.push(u),e.cube.isSolved())return!0}return!1}),!1)}calculateCitizenScore(e){return this.measurer.add(Metrics$1[2],()=>e.getConfiguration().split("").filter((s,r)=>s===this.goalStateHash[r]).length)}createSolution(e){const t=this.measurer.add(Metrics$1[3],()=>new RotationsTuner().tune(e.moves));return this.measurer.finish(),{rotations:t,totalTime:this.measurer.getTotalTime(),data:{armageddonCounter:this.armageddonCounter,genes:e.genes,neuralNetworkWeights:e.neuralNetwork.getWeights(),metrics:this.measurer.getData({notMeasuredLabel:Metrics$1[0],measurementOverheadLabel:Metrics$1[4]}),generations:this.neuroGeneticAlgorithm.getGenerationsCounter()}}}buildSolvedPocketCubeFromCornerCubelet(e){const t=new Map;return e.stickers.forEach(s=>{t.set(s.side,s.color),t.set(getOppositeSide(s.side),getOppositeColor(s.color))}),new RubiksCube({colorMap:t,dimension:this.initialState.getDimension()})}}class CornersInOrbitStep{constructor(e){l(this,"stepRotations");l(this,"goalXAxisColors");l(this,"goalYSliceColors");const t=new HumanTranslator;this.stepRotations=t.convertStringToFaceRotations("L R F B L' R' F' B' 2U 2D");const r=e.getAllCubelets().filter(n=>n.stickers.length===1);this.goalXAxisColors=r.filter(n=>n.stickers.some(a=>[Sides.RIGHT,Sides.LEFT].includes(a.side))).map(n=>n.stickers[0].color),this.goalYSliceColors=r.filter(n=>n.stickers.some(a=>[Sides.FRONT,Sides.BACK].includes(a.side))).map(n=>n.stickers[0].color).concat(this.goalXAxisColors),console.log(this.goalXAxisColors.map(n=>Colors[n])),console.log(this.goalYSliceColors.map(n=>Colors[n]))}getAllowedMoves(){return this.stepRotations}iterate(e){const t=e.getAllCubelets().filter(a=>a.stickers.length===3).filter(a=>{const u=a.stickers.find(g=>this.goalXAxisColors.includes(g.color));return![Sides.RIGHT,Sides.LEFT].includes(u.side)}).length,s=e.getAllCubelets().filter(a=>a.stickers.length===2).filter(a=>a.stickers.every(u=>!this.goalXAxisColors.includes(u.color))).filter(a=>!!a.stickers.find(g=>[Sides.RIGHT,Sides.LEFT].includes(g.side))).length;t+s===0&&console.log("Yaaay");const r=4,n=4;return{stepFinished:t+s===0,nextStepSolver:void 0,minMovesToFinishSteps:Math.max(t/r,s/n),data:{}}}}class EdgesInOrbitStep{constructor(e){l(this,"goalStateEdgeCubelets");l(this,"stepRotations");l(this,"goalState");this.goalState=e.clone(),this.goalStateEdgeCubelets=this.goalState.getAllCubelets().filter(s=>s.stickers.length===2);const t=new HumanTranslator;this.stepRotations=t.convertStringToFaceRotations("L R F B U D L' R' F' B' U' D'")}getAllowedMoves(){return this.stepRotations}iterate(e){const s=this.countFrontAndBackEdgesInOrbit(e),r=this.countLeftAndRightEdgesInOrbit(e);let n;const a=this.goalStateEdgeCubelets.length-(s+r),u=a===0;return u&&(n=new CornersInOrbitStep(this.goalState)),{stepFinished:u,nextStepSolver:n,minMovesToFinishSteps:a/4,data:{}}}countLeftAndRightEdgesInOrbit(e){return this.goalStateEdgeCubelets.filter(t=>t.stickers.every(s=>![Sides.FRONT,Sides.BACK].includes(s.side))).filter(t=>{const s=t.stickers.find(u=>[Sides.LEFT,Sides.RIGHT].includes(u.side)).color,r=t.stickers.map(u=>u.color),n=e.getCubeletsByColors(...r).filter(u=>u.stickers.length===2)[0],a=n.stickers.find(u=>u.color===s).side;if([Sides.FRONT,Sides.BACK].includes(a))return!1;if([Sides.UP,Sides.DOWN].includes(a)){const u=n.stickers.find(g=>![Sides.UP,Sides.DOWN].includes(g.side)).side;if(![Sides.FRONT,Sides.BACK].includes(u))return!1}return!0}).length}countFrontAndBackEdgesInOrbit(e){return this.goalStateEdgeCubelets.filter(t=>t.stickers.some(s=>[Sides.FRONT,Sides.BACK].includes(s.side))).filter(t=>{const s=t.stickers.find(u=>[Sides.FRONT,Sides.BACK].includes(u.side)).color,r=t.stickers.map(u=>u.color),n=e.getCubeletsByColors(...r).filter(u=>u.stickers.length===2)[0],a=n.stickers.find(u=>u.color===s).side;if([Sides.LEFT,Sides.RIGHT].includes(a))return!1;if([Sides.UP,Sides.DOWN].includes(a)){const u=n.stickers.find(g=>![Sides.UP,Sides.DOWN].includes(g.side)).side;if(![Sides.LEFT,Sides.RIGHT].includes(u))return!1}return!0}).length}}var Metrics=(o=>(o[o.ADD_CANDIDATE=0]="ADD_CANDIDATE",o[o.POP_CANDIDATE=1]="POP_CANDIDATE",o[o.CHECK_SOLUTION=2]="CHECK_SOLUTION",o[o.BREATHING_TIME=3]="BREATHING_TIME",o[o.HASH_CALCULATION=4]="HASH_CALCULATION",o[o.VISISTED_LIST_CHECK=5]="VISISTED_LIST_CHECK",o[o.ADD_TO_VISISTED_LIST_CHECK=6]="ADD_TO_VISISTED_LIST_CHECK",o[o.PERFORM_ROTATION=7]="PERFORM_ROTATION",o[o.NOT_MEASURED=8]="NOT_MEASURED",o[o.CYCLE_AVOIDANCE_CHECK=9]="CYCLE_AVOIDANCE_CHECK",o))(Metrics||{});class ThistlethwaiteSolver{constructor(e){l(this,"measurer");l(this,"goalState");l(this,"iterations");l(this,"minBoundGrow",1.25);l(this,"stepInitialState");l(this,"bound");l(this,"visitedNodes");l(this,"aborted");l(this,"currentSolver");l(this,"currentPath");l(this,"data");this.iterations=[],this.measurer=new ProcedureMeasurer,this.visitedNodes=0,this.currentPath=[],this.aborted=!1,this.goalState=this.buildSolvedCubeFromCentersCubelets(e),this.currentSolver=new EdgesInOrbitStep(this.goalState),this.bound=this.currentSolver.iterate(e).minMovesToFinishSteps,this.stepInitialState={cube:e,rotations:[],parent:void 0},console.log(this.bound)}abort(){this.aborted=!0}async findSolution(){let e=0;return new Promise((t,s)=>{this.measurer.start();let r=this.stepInitialState;for(;!this.aborted;){this.currentPath=[r.cube.getHash()];const n=this.search(r,0);if(n.aborted)break;if(n.stepOutput)if(console.log("next step. is solved: "+n.candidate.cube.isSolved()),n.stepOutput.nextStepSolver)console.log(n.stepOutput.nextStepSolver.constructor.name),this.currentSolver=n.stepOutput.nextStepSolver,this.bound=this.currentSolver.iterate(r.cube).minMovesToFinishSteps,r=n.candidate,new HumanTranslator().printCube(r.cube);else return t(this.createSolution(n.candidate));else{const a=this.visitedNodes-e;this.iterations.push({newNodesVisited:a,bound:this.bound}),e=this.visitedNodes,this.bound=Math.max(n.minGreaterValue,this.bound+this.minBoundGrow),console.log(this.bound,a)}}s(Error("Aborted"))})}search(e,t){if(++this.visitedNodes,this.aborted)return{aborted:!0};const s=this.currentSolver.iterate(e.cube);let r=s.minMovesToFinishSteps;if(s.stepFinished)return this.currentSolver=s.nextStepSolver,console.log("step is over"),{candidate:e,stepOutput:s};let n=1/0;const a=this.applyRotations(e);for(let u of a){const g=t+r;if(g>this.bound)return{minGreaterValue:g};const p=this.search(u,t+1),S=u.cube.getHash();if(this.measurer.add(Metrics[9],()=>this.currentPath.every(m=>m!==S))){if(this.currentPath.push(S),p.candidate||p.aborted)return p;r=Math.min(r,p.minGreaterValue-1),n=Math.min(p.minGreaterValue,n),this.currentPath.pop()}}return{aborted:!1,candidate:void 0,minGreaterValue:n}}createSolution(e){const t=[];let s=e;for(;s&&s.rotations.length>0;)t.unshift(...s.rotations),s=s.parent;return this.measurer.finish(),{rotations:new RotationsTuner().tune(t),totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:Metrics[8]}),visitedNodes:this.visitedNodes}}}applyRotations(e){const t=[];return this.currentSolver.getAllowedMoves().forEach(r=>{const n=r.reduce((a,u)=>a.rotateFace(u),e.cube);this.measurer.add(Metrics[0],()=>{t.push({cube:n,rotations:r,parent:e})})}),t}buildSolvedCubeFromCentersCubelets(e){const t=e.getAllCubelets().filter(r=>r.stickers.length===1),s=new Map;return t.forEach(r=>r.stickers.forEach(n=>{s.set(n.side,n.color),s.set(getOppositeSide(n.side),getOppositeColor(n.color))})),new RubiksCube({colorMap:s,dimension:e.getDimension()})}}class KeyboardInterpreter{readKeys(e,t){let s;switch(e.key.toLowerCase()){case"w":s=Sides.UP;break;case"a":s=Sides.LEFT;break;case"s":s=Sides.FRONT;break;case"d":s=Sides.RIGHT;break;case"f":s=Sides.BACK;break;case"x":s=Sides.DOWN;break}if(s!==void 0)return{side:s,counterClockwiseDirection:e.shiftKey,layer:t}}}class HumanSolver{constructor(e){l(this,"moves");l(this,"findSolutionResolve");l(this,"findSolutionReject");l(this,"cube");l(this,"startTime");l(this,"keyboardInterpreter");this.cube=e,this.moves=[],this.keyboardInterpreter=new KeyboardInterpreter}async findSolution(){return this.startTime=Date.now(),new Promise((e,t)=>{this.findSolutionResolve=e,this.findSolutionReject=t})}abort(){this.findSolutionReject()}async readKeys(e){if(this.cube.isSolved())return;const t=this.keyboardInterpreter.readKeys(e);if(t!==void 0)return this.moves.push(t),this.cube=this.cube.rotateFace(t),this.cube.isSolved()&&this.findSolutionResolve({rotations:this.moves,totalTime:Date.now()-this.startTime,data:{human:!0}}),t}}const WeightedAStarAlgorithmConfig={heuristicWeight:50},NeuroEvolutionaryConfig={geneticData:{mutationRate:.01,populationPerGeneration:200,armageddonThreshold:500},neuralNetworkData:{hiddenNeurons:10,iterations:1}},GeneticAlgorithmConfig={populationPerGeneration:500,elitism:50,armageddonThreshold:300,numberOfInitialScrambleMovements:25},Configuration={metrics:{enabled:!1},world:{debug:!1,scrambleMoves:15,scrambleRotationDuration:100,cubesCircleRay:4.5,camera:{closeDistance:20,farDistance:55}},renderers:{translationDuration:500,rotationDuration:250,titleDistance:8.5,cubeSize:2.5},initiallySelectedCubeTypeIndex:1,cubeTypes:[{label:"2x2",dimension:2,instantiator:()=>new RubiksCube({dimension:2}),methods:[{key:"Human",instantiator:o=>new HumanSolver(new RubiksCube({clone:o})),checked:!1,info:"Use keys 'WASDFX' combined with 'shift' to rotate cube faces"},{key:"IDDFS",instantiator:o=>new InterativeDeepeningDepthFirstSearchSolver(new RubiksCube({clone:o})),checked:!1,info:"Interative-deepening depth-first-search. Brute force"},{key:"BFS",instantiator:o=>new BreadthFirstSearchSolver(new RubiksCube({clone:o})),checked:!1,info:"Breadth-first-search. Brute force"},{key:"NE",instantiator:o=>new NeuroEvolutionarySolver(new RubiksCube({clone:o})),checked:!1,info:`Neuro Evolutionary. Uses number of misplaced stickers as fitness function. Internal neurons: ${NeuroEvolutionaryConfig.neuralNetworkData.hiddenNeurons}. Population: ${NeuroEvolutionaryConfig.geneticData.populationPerGeneration}. No elitism`},{key:"IDA*",instantiator:o=>new InterativeDeepeningAStarSolver(new RubiksCube({clone:o})),checked:!0,info:"Interative-deepening A star. Uses number of misplaced stickers as heuristic."},{key:"WA*",instantiator:o=>new WeightedAStarSolver(new RubiksCube({clone:o})),checked:!0,info:`Weighted A star. No re-expansions. Uses number of misplaced stickers as heuristic and weights the heuristic (${WeightedAStarAlgorithmConfig.heuristicWeight} * h(x)) value.`},{key:"BiBFS",instantiator:o=>new BidirectionalBreadthFirstSearchSolver(new RubiksCube({clone:o})),checked:!0,info:"BiDirectional Breadth-first-search. Brute force."}]},{label:"3x3",dimension:3,instantiator:()=>new RubiksCube({dimension:3}),methods:[{key:"Human",instantiator:o=>new HumanSolver(new RubiksCube({clone:o})),checked:!1,info:"Use keys 'WASDFX' combined with 'shift' to rotate cube faces"},{key:"Thisttlethwait",instantiator:o=>new ThistlethwaiteSolver(new RubiksCube({clone:o})),checked:!0,info:"Thisttlethwait multi step method"},{key:"GA",instantiator:o=>new GeneticAlgorithmSolver(new RubiksCube({clone:o})),checked:!1,info:`Predefined macro movements combined with genetic algorithm. Uses number of misplaced stickers as fitness function. Population: ${GeneticAlgorithmConfig.populationPerGeneration}. Elitism ${GeneticAlgorithmConfig.elitism}. Asexual reproduction`}]},{label:"4x4",dimension:4,instantiator:()=>new RubiksCube({dimension:4}),methods:[{key:"Human",instantiator:o=>new HumanSolver(new RubiksCube({clone:o})),checked:!1,info:"Use keys 'WASDFX' combined with 'shift' and numbers to rotate cube faces"}]},{label:"5x5",dimension:5,instantiator:()=>new RubiksCube({dimension:5}),methods:[{key:"Human",instantiator:o=>new HumanSolver(new RubiksCube({clone:o})),checked:!1,info:"Use keys 'WASDFX' combined with 'shift' and numbers to rotate cube faces"}]}]},solverMethodFinder=o=>{for(let e of Configuration.cubeTypes)if(e.label.toLowerCase()===o.label.toLowerCase()){for(let t of e.methods)if(t.key.toLowerCase()===o.solverTag.toLowerCase())return t;return}};let solver;self.onmessage=async o=>{if(o.data.abort)solver.abort();else{const e=o.data.solverTag.toLowerCase(),t=solverMethodFinder(o.data);if(e&&t)if(o.data.cube)try{solver=t.instantiator(o.data.cube);const s=await solver.findSolution();self.postMessage({solution:JSON.stringify(s),solverKey:e})}catch(s){console.log(`Solver '${o.data.label}.${e}' aborted`,s),self.postMessage({error:`Solver '${o.data.label}.${e}' aborted`,solverTag:o.data.solverTag})}else if(o.data.keyboardEvent){if(solver instanceof HumanSolver){const s=await solver.readKeys(o.data.keyboardEvent);s!==void 0&&self.postMessage({faceRotation:s,solverKey:e})}}else self.postMessage({error:`Command for '${o.data}' not found`,solverTag:o.data.solverTag});else self.postMessage({error:`Solver '${o.data.solverTag}' not found`,solverTag:o.data.solverTag})}}})();
