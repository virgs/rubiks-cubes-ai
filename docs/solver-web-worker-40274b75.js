var L=Object.defineProperty;var k=(R,A,r)=>A in R?L(R,A,{enumerable:!0,configurable:!0,writable:!0,value:r}):R[A]=r;var l=(R,A,r)=>(k(R,typeof A!="symbol"?A+"":A,r),r);(function(){"use strict";var Sides=(r=>(r[r.UP=0]="UP",r[r.LEFT=1]="LEFT",r[r.FRONT=2]="FRONT",r[r.RIGHT=3]="RIGHT",r[r.BACK=4]="BACK",r[r.DOWN=5]="DOWN",r))(Sides||{});const getAllSides=()=>Object.keys(Sides).filter(r=>!isNaN(Number(r))).map(r=>Number(r)),getAdjacentSides=r=>Object.keys(Sides).filter(e=>!isNaN(Number(e))).map(e=>Number(e)).filter(e=>e!==r&&e!==getOppositeSide(r)),getOppositeSide=r=>{switch(r){case 0:return 5;case 5:return 0;case 1:return 3;case 3:return 1;case 2:return 4;case 4:return 2}};var Colors=(r=>(r[r.YELLOW=0]="YELLOW",r[r.ORANGE=1]="ORANGE",r[r.BLUE=2]="BLUE",r[r.RED=3]="RED",r[r.GREEN=4]="GREEN",r[r.WHITE=5]="WHITE",r))(Colors||{});const getOppositeColor=r=>{switch(r){case 2:return 4;case 4:return 2;case 3:return 1;case 1:return 3;case 0:return 5;case 5:return 0}},colorToStringMap=new Map;colorToStringMap.set(0,"y"),colorToStringMap.set(1,"o"),colorToStringMap.set(2,"b"),colorToStringMap.set(3,"r"),colorToStringMap.set(4,"g"),colorToStringMap.set(5,"w");const mapColorInitialsToString=r=>colorToStringMap.get(r),stringToColorMap=new Map;stringToColorMap.set("y",0),stringToColorMap.set("o",1),stringToColorMap.set("b",2),stringToColorMap.set("r",3),stringToColorMap.set("g",4),stringToColorMap.set("w",5);const mapStringInitialToColor=r=>stringToColorMap.get(r),R=class{constructor(e){l(this,"dimension");l(this,"stickers");l(this,"cubeletCounter");this.dimension=e,this.stickers=[],this.cubeletCounter=0}create(){if(R.cubeletsCreatorMap.has(this.dimension))return R.cubeletsCreatorMap.get(this.dimension);{let e=0;getAllSides().map(d=>{for(let f=0;f<this.dimension;++f)for(let g=0;g<this.dimension;++g)this.stickers.push({side:d,x:g,y:f,id:e++})});const t=this.extractCenters(),s=this.extractCorners(),o=this.extractEdges(),n=[...s,...o,...t];return R.cubeletsCreatorMap.set(this.dimension,n),n}}cubeletsMerger(e){const t={stickers:[],id:++this.cubeletCounter};return e.forEach(s=>{this.stickers.forEach((o,n,d)=>{o.side===s.side&&s.x===o.x&&s.y===o.y&&t.stickers.push(...d.splice(n,1))})}),t}extractEdges(){const e=this.dimension-1,t=[];for(let s=1;s<this.dimension-1;++s)t.push(this.cubeletsMerger([{side:Sides.FRONT,x:0,y:s},{side:Sides.LEFT,x:e,y:s}])),t.push(this.cubeletsMerger([{side:Sides.FRONT,x:e,y:s},{side:Sides.RIGHT,x:0,y:s}])),t.push(this.cubeletsMerger([{side:Sides.FRONT,x:s,y:0},{side:Sides.UP,x:s,y:e}])),t.push(this.cubeletsMerger([{side:Sides.FRONT,x:s,y:e},{side:Sides.DOWN,x:s,y:0}])),t.push(this.cubeletsMerger([{side:Sides.BACK,x:e,y:s},{side:Sides.LEFT,x:0,y:s}])),t.push(this.cubeletsMerger([{side:Sides.BACK,x:0,y:s},{side:Sides.RIGHT,x:e,y:s}])),t.push(this.cubeletsMerger([{side:Sides.BACK,x:s,y:0},{side:Sides.UP,x:e-s,y:0}])),t.push(this.cubeletsMerger([{side:Sides.BACK,x:s,y:e},{side:Sides.DOWN,x:e-s,y:e}])),t.push(this.cubeletsMerger([{side:Sides.RIGHT,x:s,y:0},{side:Sides.UP,x:e,y:e-s}])),t.push(this.cubeletsMerger([{side:Sides.RIGHT,x:s,y:e},{side:Sides.DOWN,x:e,y:s}])),t.push(this.cubeletsMerger([{side:Sides.LEFT,x:s,y:0},{side:Sides.UP,x:0,y:s}])),t.push(this.cubeletsMerger([{side:Sides.LEFT,x:s,y:e},{side:Sides.DOWN,x:0,y:e-s}]));return t}extractCenters(){const e=this.dimension-1,t=[];return this.stickers.filter(s=>s.x!==0&&s.x!==e&&s.y!==0&&s.y!==e).forEach(s=>{t.push({stickers:[s],id:++this.cubeletCounter})}),t}extractCorners(){const e=[],t=this.dimension-1;return e.push(this.cubeletsMerger([{side:Sides.FRONT,x:0,y:0},{side:Sides.UP,x:0,y:t},{side:Sides.LEFT,x:t,y:0}])),e.push(this.cubeletsMerger([{side:Sides.FRONT,x:t,y:0},{side:Sides.UP,x:t,y:t},{side:Sides.RIGHT,x:0,y:0}])),e.push(this.cubeletsMerger([{side:Sides.FRONT,x:0,y:t},{side:Sides.DOWN,x:0,y:0},{side:Sides.LEFT,x:t,y:t}])),e.push(this.cubeletsMerger([{side:Sides.FRONT,x:t,y:t},{side:Sides.DOWN,x:t,y:0},{side:Sides.RIGHT,x:0,y:t}])),e.push(this.cubeletsMerger([{side:Sides.BACK,x:0,y:0},{side:Sides.UP,x:t,y:0},{side:Sides.RIGHT,x:t,y:0}])),e.push(this.cubeletsMerger([{side:Sides.BACK,x:t,y:0},{side:Sides.UP,x:0,y:0},{side:Sides.LEFT,x:0,y:0}])),e.push(this.cubeletsMerger([{side:Sides.BACK,x:0,y:t},{side:Sides.DOWN,x:t,y:t},{side:Sides.RIGHT,x:t,y:t}])),e.push(this.cubeletsMerger([{side:Sides.BACK,x:t,y:t},{side:Sides.DOWN,x:0,y:t},{side:Sides.LEFT,x:0,y:t}])),e}};let CubeletsCreator=R;l(CubeletsCreator,"cubeletsCreatorMap",new Map);const A=class{constructor(e){l(this,"dimension");if(this.dimension=e,!A.faceRotatorMap.has(this.dimension)){const t=new Map;for(let s=0;s<this.dimension;++s){const o=this.createUpFaceClockwiseRotator(s),n=this.createLeftFaceClockwiseRotator(s),d=this.createFrontFaceClockwiseRotator(s),f=this.createRightFaceClockwiseRotator(s),g=this.createBackFaceClockwiseRotator(s),c=this.createDownFaceClockwiseRotator(s),m=new Map;m.set(Sides.UP,o.map(S=>this.faceStickerMapper(S))),m.set(Sides.LEFT,n.map(S=>this.faceStickerMapper(S))),m.set(Sides.FRONT,d.map(S=>this.faceStickerMapper(S))),m.set(Sides.RIGHT,f.map(S=>this.faceStickerMapper(S))),m.set(Sides.BACK,g.map(S=>this.faceStickerMapper(S))),m.set(Sides.DOWN,c.map(S=>this.faceStickerMapper(S))),t.set(s,m)}A.faceRotatorMap.set(this.dimension,t)}}rotate(e,t){const s=new RubiksCube({clone:e.getConfiguration()}),o=[];return A.faceRotatorMap.get(this.dimension).get(t.layer||0).get(t.side).forEach(n=>{t.counterClockwiseDirection?o.push({index:n.source,color:e.getColorOfIndex(n.destination)}):o.push({index:n.destination,color:e.getColorOfIndex(n.source)})}),s.setColorsOfIndexes(o),s}idMapper(e){let t=e.side*this.dimension*this.dimension;return t+=this.dimension*e.y,t+=e.x,t}faceStickerMapper(e){return{source:this.idMapper(e.source),destination:this.idMapper(e.destination)}}createSideLidClockwiseRotator(e){const t=[];for(let s=0;s<this.dimension*this.dimension;++s){const o=s%this.dimension,n=Math.floor(s/this.dimension),d=this.dimension-1-n,f=o;t.push({source:{side:e,x:o,y:n},destination:{side:e,x:d,y:f}})}return t}createUpFaceClockwiseRotator(e){this.dimension-1;const t=[];e===0&&t.push(...this.createSideLidClockwiseRotator(Sides.UP));for(let s=0;s<this.dimension;++s)t.push({source:{side:Sides.FRONT,x:s,y:e},destination:{side:Sides.LEFT,x:s,y:e}}),t.push({source:{side:Sides.LEFT,x:s,y:e},destination:{side:Sides.BACK,x:s,y:e}}),t.push({source:{side:Sides.BACK,x:s,y:e},destination:{side:Sides.RIGHT,x:s,y:e}}),t.push({source:{side:Sides.RIGHT,x:s,y:e},destination:{side:Sides.FRONT,x:s,y:e}});return t}createLeftFaceClockwiseRotator(e){const t=this.dimension-1,s=[];e===0&&s.push(...this.createSideLidClockwiseRotator(Sides.LEFT));for(let o=0;o<this.dimension;++o)s.push({source:{side:Sides.FRONT,x:e,y:o},destination:{side:Sides.DOWN,x:e,y:o}}),s.push({source:{side:Sides.DOWN,x:e,y:o},destination:{side:Sides.BACK,x:t-e,y:t-o}}),s.push({source:{side:Sides.BACK,x:t-e,y:t-o},destination:{side:Sides.UP,x:e,y:o}}),s.push({source:{side:Sides.UP,x:e,y:o},destination:{side:Sides.FRONT,x:e,y:o}});return s}createFrontFaceClockwiseRotator(e){const t=this.dimension-1,s=[];e===0&&s.push(...this.createSideLidClockwiseRotator(Sides.FRONT));for(let o=0;o<this.dimension;++o)s.push({source:{side:Sides.UP,x:o,y:t-e},destination:{side:Sides.RIGHT,x:e,y:o}}),s.push({source:{side:Sides.RIGHT,x:e,y:o},destination:{side:Sides.DOWN,x:t-o,y:e}}),s.push({source:{side:Sides.DOWN,x:t-o,y:e},destination:{side:Sides.LEFT,x:t-e,y:t-o}}),s.push({source:{side:Sides.LEFT,x:t-e,y:t-o},destination:{side:Sides.UP,x:o,y:t-e}});return s}createRightFaceClockwiseRotator(e){const t=this.dimension-1,s=[];e===0&&s.push(...this.createSideLidClockwiseRotator(Sides.RIGHT));for(let o=0;o<this.dimension;++o)s.push({source:{side:Sides.UP,x:t-e,y:o},destination:{side:Sides.BACK,x:e,y:t-o}}),s.push({source:{side:Sides.BACK,x:e,y:t-o},destination:{side:Sides.DOWN,x:t-e,y:o}}),s.push({source:{side:Sides.DOWN,x:t-e,y:o},destination:{side:Sides.FRONT,x:t-e,y:o}}),s.push({source:{side:Sides.FRONT,x:t-e,y:o},destination:{side:Sides.UP,x:t-e,y:o}});return s}createBackFaceClockwiseRotator(e){const t=this.dimension-1,s=[];e===0&&s.push(...this.createSideLidClockwiseRotator(Sides.BACK));for(let o=0;o<this.dimension;++o)s.push({source:{side:Sides.LEFT,x:e,y:o},destination:{side:Sides.DOWN,x:o,y:t-e}}),s.push({source:{side:Sides.DOWN,x:o,y:t-e},destination:{side:Sides.RIGHT,x:t-e,y:t-o}}),s.push({source:{side:Sides.RIGHT,x:t-e,y:t-o},destination:{side:Sides.UP,x:t-o,y:e}}),s.push({source:{side:Sides.UP,x:t-o,y:e},destination:{side:Sides.LEFT,x:e,y:o}});return s}createDownFaceClockwiseRotator(e){const t=this.dimension-1,s=[];e===0&&s.push(...this.createSideLidClockwiseRotator(Sides.DOWN));for(let o=0;o<this.dimension;++o)s.push({source:{side:Sides.LEFT,x:o,y:t-e},destination:{side:Sides.FRONT,x:o,y:t-e}}),s.push({source:{side:Sides.FRONT,x:o,y:t-e},destination:{side:Sides.RIGHT,x:o,y:t-e}}),s.push({source:{side:Sides.RIGHT,x:o,y:t-e},destination:{side:Sides.BACK,x:o,y:t-e}}),s.push({source:{side:Sides.BACK,x:o,y:t-e},destination:{side:Sides.LEFT,x:o,y:t-e}});return s}};let RubiksCubeFaceRotator=A;l(RubiksCubeFaceRotator,"faceRotatorMap",new Map);const defaultColorMap=new Map;defaultColorMap.set(Sides.FRONT,Colors.BLUE),defaultColorMap.set(Sides.UP,Colors.YELLOW),defaultColorMap.set(Sides.RIGHT,Colors.RED),defaultColorMap.set(Sides.LEFT,Colors.ORANGE),defaultColorMap.set(Sides.BACK,Colors.GREEN),defaultColorMap.set(Sides.DOWN,Colors.WHITE);class RubiksCube{constructor(e){l(this,"configuration");l(this,"dimension");l(this,"faceRotator");l(this,"colorlessCubelets");if(this.dimension=e==null?void 0:e.dimension,e!=null&&e.clone)this.dimension=Math.sqrt(e.clone.length/6),this.configuration=e.clone.slice();else{const t=this.dimension*this.dimension,s=(e==null?void 0:e.colorMap)||defaultColorMap,o=getAllSides();this.configuration="";for(let n=0;n<o.length;++n){const d=s.get(n),f=mapColorInitialsToString(d);this.configuration+=f.repeat(t)}}this.faceRotator=new RubiksCubeFaceRotator(this.dimension),this.colorlessCubelets=new CubeletsCreator(this.dimension).create()}clone(){return new RubiksCube({clone:this.configuration})}getDimension(){return this.dimension}getConfiguration(){return this.configuration}getHash(){return this.configuration}isSolved(){const e=this.dimension*this.dimension,t=getAllSides(),s=Array.from(new Array(e));return t.every((o,n)=>s.every((d,f)=>this.configuration[n*e+f]===this.configuration[n*e]))}rotateFace(e){return this.faceRotator.rotate(this,e)}getAllCubelets(){return this.addColorToCubelets(this.colorlessCubelets)}getAllColorlessCubelets(){return this.colorlessCubelets}getSideOfIndex(e){const t=getAllSides().length;return e/t}getColorlessCubeletOfIndex(e){return this.colorlessCubelets.find(t=>t.stickers.some(s=>s.id===e))}getCubeletsBySides(...e){const t=this.colorlessCubelets.filter(s=>s.stickers.every(o=>e.includes(o.side)));return this.addColorToCubelets(t)}getCubeletsByColors(...e){const t=this.colorlessCubelets.filter(s=>s.stickers.every(o=>e.includes(mapStringInitialToColor(this.configuration[o.id]))));return this.addColorToCubelets(t)}getColorOfIndex(e){return mapStringInitialToColor(this.configuration[e])}setColorsOfIndexes(e){const t=this.configuration.split("");e.forEach(s=>{t[s.index]=mapColorInitialsToString(s.color)}),this.configuration=t.join("")}addColorToCubelets(e){return e.map(t=>({stickers:t.stickers.map(s=>({...s,color:mapStringInitialToColor(this.configuration[s.id])}))}))}}var commonjsGlobal=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function getDefaultExportFromCjs(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}var doubleLinkedList=LinkedList;function LinkedList(){this._start=null,this._end=null,this.length=0}LinkedList.prototype.unShift=function(r){if(this._start===null)this._start=makeNode(r),this._end=this._start;else{var e=this._start;this._start.previous=makeNode(r),this._start=this._start.previous,this._start.next=e}this.length++},LinkedList.prototype.push=function(r){if(this._start===null)this._start=makeNode(r),this._end=this._start;else{var e=this._end;this._end.next=makeNode(r),this._end=this._end.next,this._end.previous=e}this.length++},LinkedList.prototype.add=function(r,e){if(r%1===0)if(r<=0)this.unShift(e);else if(r>=this.length)this.push(e);else{var t=findNode.call(this,r);if(t){var s=t.previous,o=t,n=makeNode(e);n.previous=s,s.next=n,n.next=o,o.previous=n,this.length++}}},LinkedList.prototype.shift=function(){if(this._start){var r=this._start.data;return this._start.next===null?(this._end=null,this._start=null):(this._start=this._start.next,this._start.previous=null),this.length--,r}else return},LinkedList.prototype.pop=function(){if(this._end){var r=this._end.data;return this._end.previous===null?(this._end=null,this._start=null):(this._end=this._end.previous,this._end.next=null),this.length--,r}else return},LinkedList.prototype.remove=function(r){if(r===0)return this.shift();if(r===this.length-1)return this.pop();var e=findNode.call(this,r);if(e){var t=e.previous,s=e.next;t.next=s,s.previous=t,this.length--}else return},LinkedList.prototype.first=function(){if(this._start)return this._start.data},LinkedList.prototype.last=function(){if(this._end)return this._end.data},LinkedList.prototype.get=function(r){var e=findNode.call(this,r);if(e)return e.data},LinkedList.prototype.toString=function(){for(var r=this._start,e="",t=0;t<this.length;t++)typeof r.data=="object"?e+=JSON.stringify(r.data):e+=r.data,t!==this.length-1&&(e+=", "),r=r.next;return e};function makeNode(r){return{data:r,previous:null,next:null}}function findNode(r){var e,t;if(r>=this.length||r<0||r%1!==0)e=null;else if(r<this.length/2)for(e=this._start,t=0;t<r;t++)e=e.next;else for(e=this._end,t=this.length-1;t>r;t--)e=e.previous;return e}class ProcedureMeasurer{constructor(e=Configuration.metrics.enabled){l(this,"map");l(this,"enabled");l(this,"measurerOverhead");l(this,"startTime");l(this,"totalTime");this.map=new Map,this.enabled=e,this.measurerOverhead=0}add(e,t){const s=performance.now();if(!this.enabled)return t();const o=t(),n=performance.now(),d=this.map.get(e)||{elapsedTime:0,calls:0,stack:"",stackSize:0};return d.elapsedTime+=n-s,++d.calls,this.map.set(e,d),this.measurerOverhead+=performance.now()-n,o}start(){this.startTime=performance.now()}finish(){this.startTime&&(this.totalTime=performance.now()-this.startTime)}getTotalTime(){return this.totalTime}getData(e){const t=[];if(this.totalTime){let s=0;Array.from(this.map.entries()).forEach(o=>{const[n,d]=o;s+=d.elapsedTime,t.push(this.createSummary(d.elapsedTime,d.calls,n))}),e!=null&&e.measurementOverheadLabel&&(t.push(this.createSummary(this.measurerOverhead,0,e.measurementOverheadLabel)),s+=this.measurerOverhead),e!=null&&e.notMeasuredLabel&&t.push(this.createSummary(this.totalTime-s,0,e.notMeasuredLabel))}return t}createSummary(e,t,s){const o=100*e/this.totalTime;return{label:s,totalTime:e,totalRelativeTime:Math.trunc(100*o)/100+"%",numOfCalls:t,avgTimePerCall:e*1/(t||1)}}}var Metrics$5=(r=>(r[r.ADD_CANDIDATE=0]="ADD_CANDIDATE",r[r.POP_CANDIDATE=1]="POP_CANDIDATE",r[r.HASH_CALCULATION=2]="HASH_CALCULATION",r[r.VISISTED_LIST_CHECK=3]="VISISTED_LIST_CHECK",r[r.ADD_TO_VISISTED_LIST_CHECK=4]="ADD_TO_VISISTED_LIST_CHECK",r[r.PERFORM_ROTATION=5]="PERFORM_ROTATION",r[r.NOT_MEASURED=6]="NOT_MEASURED",r[r.MEASUREMENT_OVERHEAD=7]="MEASUREMENT_OVERHEAD",r))(Metrics$5||{});class BidirectionalBreadthFirstSearchSolver{constructor(e){l(this,"measurer");l(this,"forwardSearchToExploreList");l(this,"forwardSearchExploredMap");l(this,"reverseSearchToExploreList");l(this,"reverseSearchExploredMap");l(this,"actions");l(this,"iterations");l(this,"aborted");this.forwardSearchToExploreList=new doubleLinkedList,this.reverseSearchToExploreList=new doubleLinkedList,this.actions=[],this.iterations=0,this.measurer=new ProcedureMeasurer,this.forwardSearchExploredMap=new Map,this.reverseSearchExploredMap=new Map,this.aborted=!1;const t={cube:e,rotation:void 0,parent:void 0};this.forwardSearchToExploreList.push(t);const s=[],o=[Sides.RIGHT,Sides.LEFT][Math.floor(Math.random()*2)],n=[Sides.UP,Sides.DOWN][Math.floor(Math.random()*2)],d=[Sides.FRONT,Sides.BACK][Math.floor(Math.random()*2)];[o,n,d].map(m=>[!0,!1].map(S=>{s.push(getOppositeSide(m)),this.actions.push({side:m,counterClockwiseDirection:S,layer:0})}));const f=e.getCubeletsBySides(...s)[0],c={cube:this.buildSolvedCubeFromCornerCubelet(f,e.getDimension()),rotation:void 0,parent:void 0};this.reverseSearchToExploreList.push(c)}abort(){this.aborted=!0}async findSolution(){return new Promise((e,t)=>{this.measurer.start();let s,o,n=0;for(;this.forwardSearchToExploreList.length>0&&this.reverseSearchToExploreList.length>0;){if(++this.iterations,this.aborted)return t();do s=this.measurer.add(Metrics$5[1],()=>this.forwardSearchToExploreList.shift());while(this.measurer.add(Metrics$5[3],()=>this.forwardSearchExploredMap.has(s.cube.getHash())));do o=this.measurer.add(Metrics$5[1],()=>this.reverseSearchToExploreList.shift());while(this.measurer.add(Metrics$5[3],()=>this.reverseSearchExploredMap.has(o.cube.getHash())));++n;let d=this.measurer.add(Metrics$5[3],()=>this.forwardSearchExploredMap.get(o.cube.getHash()));if(d)return e(this.createSolution(d,o,n));if(d=this.measurer.add(Metrics$5[3],()=>this.reverseSearchExploredMap.get(s.cube.getHash())),d)return e(this.createSolution(s,d,n));this.measurer.add(Metrics$5[4],()=>this.forwardSearchExploredMap.set(s.cube.getHash(),s)),this.measurer.add(Metrics$5[4],()=>this.reverseSearchExploredMap.set(o.cube.getHash(),o)),this.applyRotations(this.forwardSearchToExploreList,this.forwardSearchExploredMap,s),this.applyRotations(this.reverseSearchToExploreList,this.reverseSearchExploredMap,o)}return t()})}applyRotations(e,t,s){this.actions.forEach(o=>{const n=this.measurer.add(Metrics$5[5],()=>s.cube.rotateFace(o));this.measurer.add(Metrics$5[3],()=>t.has(n.getHash()))||this.measurer.add(Metrics$5[0],()=>{e.push({cube:n,rotation:o,parent:s})})})}createSolution(e,t,s){this.measurer.finish();const o=[];let n=e;for(;n&&n.rotation;)o.unshift(n.rotation),n=n.parent;for(n=t;n&&n.rotation;){const d={...n.rotation};d.counterClockwiseDirection=!d.counterClockwiseDirection,o.push(d),n=n.parent}return{rotations:o,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:Metrics$5[6],measurementOverheadLabel:Metrics$5[7]}),iterations:this.iterations,visitedNodes:s}}}buildSolvedCubeFromCornerCubelet(e,t){const s=new Map;return e.stickers.forEach(o=>{s.set(o.side,o.color),s.set(getOppositeSide(o.side),getOppositeColor(o.color))}),new RubiksCube({colorMap:s,dimension:t})}}var Metrics$4=(r=>(r[r.ADD_CANDIDATE=0]="ADD_CANDIDATE",r[r.POP_CANDIDATE=1]="POP_CANDIDATE",r[r.CHECK_SOLUTION=2]="CHECK_SOLUTION",r[r.BREATHING_TIME=3]="BREATHING_TIME",r[r.HASH_CALCULATION=4]="HASH_CALCULATION",r[r.VISISTED_LIST_CHECK=5]="VISISTED_LIST_CHECK",r[r.ADD_TO_VISISTED_LIST_CHECK=6]="ADD_TO_VISISTED_LIST_CHECK",r[r.PERFORM_ROTATION=7]="PERFORM_ROTATION",r[r.NOT_MEASURED=8]="NOT_MEASURED",r))(Metrics$4||{});class BreadthFirstSearchSolver{constructor(e){l(this,"measurer");l(this,"candidates");l(this,"visitedChecklist");l(this,"actions");l(this,"aborted");this.measurer=new ProcedureMeasurer,this.visitedChecklist=new Map,this.candidates=new doubleLinkedList,this.aborted=!1;const t={cube:e,rotation:void 0,parent:void 0};this.candidates.push(t),this.actions=this.createActions()}abort(){this.aborted=!0}async findSolution(){return new Promise((e,t)=>{this.measurer.start();let s,o=0,n=0;for(;this.candidates.length>0;){if(this.aborted)return t();if(++o,s=this.measurer.add(Metrics$4[1],()=>this.candidates.shift()),!this.measurer.add(Metrics$4[5],()=>this.visitedChecklist.has(s.cube.getHash()))){if(++n,this.measurer.add(Metrics$4[2],()=>s.cube.isSolved()))return this.measurer.finish(),e(this.createSolution(s,o,n));this.measurer.add(Metrics$4[6],()=>this.visitedChecklist.set(s.cube.getHash(),!0)),this.applyRotations(s)}}t(Error("No more candidates to explore"))})}createSolution(e,t,s){const o=[];let n=e;for(;n&&n.rotation;)o.unshift(n.rotation),n=n.parent;return{rotations:o,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:Metrics$4[8]}),visitedNodes:t,differentNodes:s}}}createActions(){const e=[],t=[Sides.RIGHT,Sides.LEFT][Math.floor(Math.random()*2)],s=[Sides.UP,Sides.DOWN][Math.floor(Math.random()*2)],o=[Sides.FRONT,Sides.BACK][Math.floor(Math.random()*2)];return[t,s,o].map(n=>[!0,!1].map(d=>{e.push({side:n,counterClockwiseDirection:d,layer:0})})),e}applyRotations(e){this.actions.forEach(t=>{const s=this.measurer.add(Metrics$4[7],()=>e.cube.rotateFace(t));this.measurer.add(Metrics$4[5],()=>this.visitedChecklist.has(s.getHash()))||this.measurer.add(Metrics$4[0],()=>{const o={cube:s,rotation:t,parent:e};this.candidates.push(o)})})}}var Metrics$3=(r=>(r[r.ADD_CANDIDATE=0]="ADD_CANDIDATE",r[r.POP_CANDIDATE=1]="POP_CANDIDATE",r[r.CHECK_SOLUTION=2]="CHECK_SOLUTION",r[r.BREATHING_TIME=3]="BREATHING_TIME",r[r.HASH_CALCULATION=4]="HASH_CALCULATION",r[r.VISISTED_LIST_CHECK=5]="VISISTED_LIST_CHECK",r[r.ADD_TO_VISISTED_LIST_CHECK=6]="ADD_TO_VISISTED_LIST_CHECK",r[r.PERFORM_ROTATION=7]="PERFORM_ROTATION",r[r.NOT_MEASURED=8]="NOT_MEASURED",r[r.CYCLE_AVOIDANCE_CHECK=9]="CYCLE_AVOIDANCE_CHECK",r))(Metrics$3||{});class InterativeDeepeningAStarSolver{constructor(e){l(this,"measurer");l(this,"actions");l(this,"goalStateHash");l(this,"root");l(this,"numberOfStickersMovedInOneTwist");l(this,"iterations");l(this,"minBoundGrow",1.25);l(this,"currentPath");l(this,"bound");l(this,"visitedNodes");l(this,"aborted");this.iterations=[],this.measurer=new ProcedureMeasurer,this.currentPath=[],this.visitedNodes=0,this.aborted=!1,this.actions=[],[Sides.FRONT,Sides.UP,Sides.RIGHT].map(n=>[!0,!1].map(d=>{this.actions.push({side:n,counterClockwiseDirection:d,layer:0})}));const t=e.getCubeletsBySides(Sides.BACK,Sides.LEFT,Sides.DOWN)[0],s=this.buildSolvedPocketCubeFromCornerCubelet(t,e.getDimension());this.goalStateHash=s.getHash();const o=e.getDimension();this.numberOfStickersMovedInOneTwist=o*o+o*getAdjacentSides(Sides.UP).length,this.bound=this.calculateDistanceToFinalState(e),this.root={cube:e,rotation:void 0,parent:void 0}}abort(){this.aborted=!0}async findSolution(){let e=0;return new Promise((t,s)=>{for(this.measurer.start();!this.aborted;){this.currentPath=[this.root.cube.getHash()];const o=this.search(this.root,0);if(o.solution)return t(this.createSolution(o.solution));if(o.aborted)break;{const n=this.visitedNodes-e;this.iterations.push({newNodesVisited:n,bound:this.bound}),e=this.visitedNodes,this.bound=Math.max(o.cost,this.bound+this.minBoundGrow)}}s(Error("Aborted"))})}search(e,t){if(++this.visitedNodes,this.aborted)return{aborted:!0};let s=this.calculateDistanceToFinalState(e.cube);if(e.cube.isSolved())return{solution:e};let o=1/0;const n=this.applyRotations(e);for(let d of n){const f=t+s;if(f>this.bound)return{cost:f};const g=d.cube.getHash();if(this.measurer.add(Metrics$3[9],()=>this.currentPath.every(c=>c!==g))){this.currentPath.push(g);const c=this.search(d,t+1);if(c.solution||c.aborted)return c;s=Math.min(s,c.cost-1),o=Math.min(c.cost,o),this.currentPath.pop()}}return{cost:o}}createSolution(e){this.measurer.finish();const t=[];let s=e;for(;s&&s.rotation;)t.unshift(s.rotation),s=s.parent;return{rotations:t,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:Metrics$3[8]}),visitedNodes:this.visitedNodes,iterations:this.iterations}}}applyRotations(e){const t=[];return this.actions.forEach(s=>{const o=this.measurer.add(Metrics$3[7],()=>e.cube.rotateFace(s));this.measurer.add(Metrics$3[0],()=>{t.push({cube:o,rotation:s,parent:e})})}),t}calculateDistanceToFinalState(e){return e.getConfiguration().split("").filter((s,o)=>s!==this.goalStateHash[o]).length/this.numberOfStickersMovedInOneTwist}buildSolvedPocketCubeFromCornerCubelet(e,t){const s=new Map;return e.stickers.forEach(o=>{s.set(o.side,o.color),s.set(getOppositeSide(o.side),getOppositeColor(o.color))}),new RubiksCube({colorMap:s,dimension:t})}}var Metrics$2=(r=>(r[r.ADD_CANDIDATE=0]="ADD_CANDIDATE",r[r.POP_CANDIDATE=1]="POP_CANDIDATE",r[r.CHECK_SOLUTION=2]="CHECK_SOLUTION",r[r.BREATHING_TIME=3]="BREATHING_TIME",r[r.HASH_CALCULATION=4]="HASH_CALCULATION",r[r.VISISTED_LIST_CHECK=5]="VISISTED_LIST_CHECK",r[r.ADD_TO_VISISTED_LIST_CHECK=6]="ADD_TO_VISISTED_LIST_CHECK",r[r.PERFORM_ROTATION=7]="PERFORM_ROTATION",r[r.NOT_MEASURED=8]="NOT_MEASURED",r))(Metrics$2||{});class InterativeDeepeningDepthFirstSearchSolver{constructor(e){l(this,"measurer");l(this,"actions");l(this,"root");l(this,"currentMaxDepth");l(this,"visitedNodes");l(this,"aborted");this.measurer=new ProcedureMeasurer,this.visitedNodes=0,this.aborted=!1,this.actions=this.createActions();const t=e.getCubeletsBySides(Sides.BACK,Sides.LEFT,Sides.DOWN)[0],s=this.buildSolvedPocketCubeFromCornerCubelet(t,e.getDimension());this.currentMaxDepth=this.calculateDistanceToFinalState(e,s.getConfiguration()),this.root={cube:e,rotation:void 0,parent:void 0}}abort(){this.aborted=!0}async findSolution(){return new Promise((e,t)=>{for(this.measurer.start();!this.aborted;){const s=this.beginSearch(this.root,0);if(s)return this.measurer.finish(),e(this.createSolution(s));++this.currentMaxDepth}t(Error("Aborted"))})}beginSearch(e,t){if(++this.visitedNodes,!this.aborted){if(t<this.currentMaxDepth){const s=this.applyRotations(e);for(let o of s){const n=this.beginSearch(o,t+1);if(n)return n}}else if(t===this.currentMaxDepth&&e.cube.isSolved())return e}}createActions(){const e=[];return[Sides.FRONT,Sides.UP,Sides.RIGHT].map(t=>[!0,!1].map(s=>{e.push({side:t,counterClockwiseDirection:s,layer:0})})),e}createSolution(e){const t=[];let s=e;for(;s&&s.rotation;)t.unshift(s.rotation),s=s.parent;return{rotations:t,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:Metrics$2[8]}),visitedNodes:this.visitedNodes}}}applyRotations(e){const t=[];return this.actions.forEach(s=>{const o=this.measurer.add(Metrics$2[7],()=>e.cube.rotateFace(s));this.measurer.add(Metrics$2[0],()=>{t.push({cube:o,rotation:s,parent:e})})}),t}calculateDistanceToFinalState(e,t){const s=e.getDimension()*e.getDimension()+e.getDimension()*4,o=e.getConfiguration();return Math.ceil(o.split("").filter((n,d)=>n!==t[d]).length/s)}buildSolvedPocketCubeFromCornerCubelet(e,t){const s=new Map;return e.stickers.forEach(o=>{s.set(o.side,o.color),s.set(getOppositeSide(o.side),getOppositeColor(o.color))}),new RubiksCube({colorMap:s,dimension:t})}}var heapExports$1={},heap$1={get exports(){return heapExports$1},set exports(r){heapExports$1=r}},heapExports={},heap={get exports(){return heapExports},set exports(r){heapExports=r}};(function(r,e){(function(){var t,s,o,n,d,f,g,c,m,S,v,O,w,x,D;o=Math.floor,S=Math.min,s=function(a,u){return a<u?-1:a>u?1:0},m=function(a,u,h,p,T){var C;if(h==null&&(h=0),T==null&&(T=s),h<0)throw new Error("lo must be non-negative");for(p==null&&(p=a.length);h<p;)C=o((h+p)/2),T(u,a[C])<0?p=C:h=C+1;return[].splice.apply(a,[h,h-h].concat(u)),u},f=function(a,u,h){return h==null&&(h=s),a.push(u),x(a,0,a.length-1,h)},d=function(a,u){var h,p;return u==null&&(u=s),h=a.pop(),a.length?(p=a[0],a[0]=h,D(a,0,u)):p=h,p},c=function(a,u,h){var p;return h==null&&(h=s),p=a[0],a[0]=u,D(a,0,h),p},g=function(a,u,h){var p;return h==null&&(h=s),a.length&&h(a[0],u)<0&&(p=[a[0],u],u=p[0],a[0]=p[1],D(a,0,h)),u},n=function(a,u){var h,p,T,C,b,E;for(u==null&&(u=s),C=function(){E=[];for(var I=0,N=o(a.length/2);0<=N?I<N:I>N;0<=N?I++:I--)E.push(I);return E}.apply(this).reverse(),b=[],p=0,T=C.length;p<T;p++)h=C[p],b.push(D(a,h,u));return b},w=function(a,u,h){var p;if(h==null&&(h=s),p=a.indexOf(u),p!==-1)return x(a,0,p,h),D(a,p,h)},v=function(a,u,h){var p,T,C,b,E;if(h==null&&(h=s),T=a.slice(0,u),!T.length)return T;for(n(T,h),E=a.slice(u),C=0,b=E.length;C<b;C++)p=E[C],g(T,p,h);return T.sort(h).reverse()},O=function(a,u,h){var p,T,C,b,E,I,N,_,y;if(h==null&&(h=s),u*10<=a.length){if(C=a.slice(0,u).sort(h),!C.length)return C;for(T=C[C.length-1],N=a.slice(u),b=0,I=N.length;b<I;b++)p=N[b],h(p,T)<0&&(m(C,p,0,null,h),C.pop(),T=C[C.length-1]);return C}for(n(a,h),y=[],E=0,_=S(u,a.length);0<=_?E<_:E>_;0<=_?++E:--E)y.push(d(a,h));return y},x=function(a,u,h,p){var T,C,b;for(p==null&&(p=s),T=a[h];h>u;){if(b=h-1>>1,C=a[b],p(T,C)<0){a[h]=C,h=b;continue}break}return a[h]=T},D=function(a,u,h){var p,T,C,b,E;for(h==null&&(h=s),T=a.length,E=u,C=a[u],p=2*u+1;p<T;)b=p+1,b<T&&!(h(a[p],a[b])<0)&&(p=b),a[u]=a[p],u=p,p=2*u+1;return a[u]=C,x(a,E,u,h)},t=function(){a.push=f,a.pop=d,a.replace=c,a.pushpop=g,a.heapify=n,a.updateItem=w,a.nlargest=v,a.nsmallest=O;function a(u){this.cmp=u??s,this.nodes=[]}return a.prototype.push=function(u){return f(this.nodes,u,this.cmp)},a.prototype.pop=function(){return d(this.nodes,this.cmp)},a.prototype.peek=function(){return this.nodes[0]},a.prototype.contains=function(u){return this.nodes.indexOf(u)!==-1},a.prototype.replace=function(u){return c(this.nodes,u,this.cmp)},a.prototype.pushpop=function(u){return g(this.nodes,u,this.cmp)},a.prototype.heapify=function(){return n(this.nodes,this.cmp)},a.prototype.updateItem=function(u){return w(this.nodes,u,this.cmp)},a.prototype.clear=function(){return this.nodes=[]},a.prototype.empty=function(){return this.nodes.length===0},a.prototype.size=function(){return this.nodes.length},a.prototype.clone=function(){var u;return u=new a,u.nodes=this.nodes.slice(0),u},a.prototype.toArray=function(){return this.nodes.slice(0)},a.prototype.insert=a.prototype.push,a.prototype.top=a.prototype.peek,a.prototype.front=a.prototype.peek,a.prototype.has=a.prototype.contains,a.prototype.copy=a.prototype.clone,a}(),function(a,u){return r.exports=u()}(this,function(){return t})}).call(commonjsGlobal)})(heap),function(r){r.exports=heapExports}(heap$1);var Heap=getDefaultExportFromCjs(heapExports$1),Metrics$1=(r=>(r[r.ADD_CANDIDATE=0]="ADD_CANDIDATE",r[r.POP_CANDIDATE=1]="POP_CANDIDATE",r[r.CHECK_SOLUTION=2]="CHECK_SOLUTION",r[r.BREATHING_TIME=3]="BREATHING_TIME",r[r.HASH_CALCULATION=4]="HASH_CALCULATION",r[r.VISISTED_LIST_CHECK=5]="VISISTED_LIST_CHECK",r[r.ADD_TO_VISISTED_LIST_CHECK=6]="ADD_TO_VISISTED_LIST_CHECK",r[r.PERFORM_ROTATION=7]="PERFORM_ROTATION",r[r.NOT_MEASURED=8]="NOT_MEASURED",r[r.HEURISTIC_CALCULATION=9]="HEURISTIC_CALCULATION",r[r.GET_ALL_CUBELETS=10]="GET_ALL_CUBELETS",r[r.CUBELET_FINAL_POSITION=11]="CUBELET_FINAL_POSITION",r[r.CUBELET_SIMILARITY=12]="CUBELET_SIMILARITY",r[r.ITERATION=13]="ITERATION",r[r.SOLUTION_CREATION=14]="SOLUTION_CREATION",r[r.MEASUREMENT_OVERHEAD=15]="MEASUREMENT_OVERHEAD",r[r.ITERATIONS_COUNTER_INCREMENT=16]="ITERATIONS_COUNTER_INCREMENT",r[r.ABORTED_VERIFICATION=17]="ABORTED_VERIFICATION",r[r.BUILD_SOLUTION=18]="BUILD_SOLUTION",r))(Metrics$1||{});class WeightedAStarSolver{constructor(e){l(this,"measurer");l(this,"candidates");l(this,"visitedChecklist");l(this,"actions");l(this,"dimension");l(this,"goalStateHash");l(this,"aborted");this.aborted=!1,this.dimension=e.getDimension(),this.candidates=new Heap((n,d)=>n.cost+WeightedAStarAlgorithmConfig.heuristicWeight*n.heuristicValue-(d.cost+WeightedAStarAlgorithmConfig.heuristicWeight*d.heuristicValue)),this.visitedChecklist=new Map;const t={cost:0,heuristicValue:0,cube:e,rotation:void 0,parentHash:void 0,hash:e.getHash()};this.candidates.push(t),this.actions=[];const s=e.getCubeletsBySides(Sides.BACK,Sides.LEFT,Sides.DOWN)[0],o=this.buildSolvedPocketCubeFromCornerCubelet(s);this.goalStateHash=o.getHash(),[Sides.FRONT,Sides.UP,Sides.RIGHT].map(n=>[!0,!1].map(d=>{this.actions.push({side:n,counterClockwiseDirection:d,layer:0})})),this.measurer=new ProcedureMeasurer}async findSolution(){return new Promise((e,t)=>{this.measurer.start();let s,o=0,n=0;for(;this.measurer.add(Metrics$1[16],()=>this.candidates.size()>0);){if(this.measurer.add(Metrics$1[17],()=>this.aborted))return t();if(this.measurer.add(Metrics$1[16],()=>++o),s=this.measurer.add(Metrics$1[1],()=>this.candidates.pop()),!this.measurer.add(Metrics$1[5],()=>this.visitedChecklist.has(s.hash))){if(++n,this.measurer.add(Metrics$1[2],()=>s.hash===this.goalStateHash))return e(this.measurer.add(Metrics$1[14],()=>this.createSolution(s,o,n)));this.measurer.add(Metrics$1[6],()=>this.visitedChecklist.set(s.hash,s)),this.applyRotations(s)}}t(Error("No more candidates to explore"))})}abort(){this.aborted=!0}createSolution(e,t,s){const o=[];let n=e;return this.measurer.add(Metrics$1[18],()=>{for(;n&&n.rotation;)o.unshift(n.rotation),n=this.visitedChecklist.get(n.parentHash)}),this.measurer.finish(),this.candidates.clear(),{rotations:o,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:Metrics$1[8],measurementOverheadLabel:Metrics$1[15]}),visitedNodes:t,differentNodes:s}}}applyRotations(e){for(let t of this.actions){const s=this.measurer.add(Metrics$1[7],()=>e.cube.rotateFace(t)),o=s.getHash(),n=this.measurer.add(Metrics$1[9],()=>this.calculateDistanceToFinalState(s)),d={cost:e.cost+1,cube:s,rotation:t,heuristicValue:n,parentHash:e.hash,hash:o};this.measurer.add(Metrics$1[5],()=>this.visitedChecklist.get(o))||this.measurer.add(Metrics$1[0],()=>{this.candidates.push(d)})}}calculateDistanceToFinalState(e){const t=this.dimension*this.dimension+this.dimension*4;return e.getConfiguration().split("").filter((o,n)=>o!==this.goalStateHash[n]).length/t}buildSolvedPocketCubeFromCornerCubelet(e){const t=new Map;return e.stickers.forEach(s=>{t.set(s.side,s.color),t.set(getOppositeSide(s.side),getOppositeColor(s.color))}),new RubiksCube({colorMap:t,dimension:this.dimension})}}class GeneticAlgorithm{constructor(e,t){l(this,"numberOfActions");l(this,"numOfGenes");l(this,"generationsCounter");l(this,"armageddonCounter");this.numberOfActions=e,this.numOfGenes=t,this.generationsCounter=0,this.armageddonCounter=0}createNextGeneration(e){if(++this.generationsCounter,!e)return this.createNewPopulationFromScratch();if(this.generationsCounter%GeneticAlgorithmConfig.armageddonThreshold===0)return console.log("Armageddon: "+this.armageddonCounter),++this.armageddonCounter,this.createNextGeneration();const t=e.sort((s,o)=>o.score-s.score).filter((s,o)=>o<GeneticAlgorithmConfig.elitism);return Array.from(new Array(GeneticAlgorithmConfig.populationPerGeneration)).map(()=>this.reproduceCitizens(t))}getArmageddonCounter(){return this.armageddonCounter}getGenerationsCounter(){return this.generationsCounter}pickOne(e,t){let s;do s=Math.floor(Math.random()*e.length);while(t.includes(s));return{chromosome:e[s],index:s}}createNewPopulationFromScratch(){return Array.from(new Array(GeneticAlgorithmConfig.populationPerGeneration)).map(()=>({genes:Array.from(new Array(this.numOfGenes)).map(()=>Math.floor(Math.random()*this.numberOfActions)),score:NaN}))}reproduceCitizens(e){const t=this.pickOne(e,[]),s=this.pickOne(e,[t.index]),o=Math.floor(t.chromosome.genes.length*.25+Math.random()*t.chromosome.genes.length*.5);return{genes:t.chromosome.genes.map((d,f)=>{let g=d;return f>o&&(g=s.chromosome.genes[f]),Math.random()<GeneticAlgorithmConfig.mutationRate&&(g=Math.floor(Math.random()*this.numberOfActions)),g}),score:NaN}}}const rotationsAreEqual=(r,e)=>r.layer===e.layer&&r.side===e.side&&r.counterClockwiseDirection===e.counterClockwiseDirection,rotationsCancel=(r,e)=>r.layer===e.layer&&r.side===e.side&&r.counterClockwiseDirection!==e.counterClockwiseDirection,getOppositeRotation=r=>({layer:r.layer,side:r.side,counterClockwiseDirection:!r.counterClockwiseDirection});class RotationsTuner{tune(e){const t=[];let s,o=!1,n=1;for(let d of e){if(s&&rotationsCancel(d,s))t.pop(),o=!0,n=0;else{if(s)if(rotationsAreEqual(s,d)){if(++n,n===3){t.pop(),t.pop(),t.push(getOppositeRotation(d)),n=0,o=!0;continue}}else rotationsAreEqual(s,d)||(n=1);t.push(d)}s=d}return o?this.tune(t):t}}var srcExports={},src={get exports(){return srcExports},set exports(r){srcExports=r}};(function(module){var colorList={reset:[0,0],bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],inverse:[7,27],hidden:[8,28],strikethrough:[9,29],black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],gray:[90,39],grey:[90,39],redBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39],bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],blackBG:[40,49],redBG:[41,49],greenBG:[42,49],yellowBG:[43,49],blueBG:[44,49],magentaBG:[45,49],cyanBG:[46,49],whiteBG:[47,49],bgBlackBright:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]};if(typeof process>"u"||!process.env)var process={env:{},argv:["--color"]};var isDisabled={}.NO_COLOR||process.argv.includes("--no-color"),isSupported=!isDisabled&&({}.FORCE_COLOR||process.platform==="win32"||process.argv.includes("--color")||eval("require('tty')").isatty(1)&&{}.TERM!=="dumb"||{}.CI),TObject=typeof Reflect>"u"?Object:Reflect,fncache={};function extend(r,e){var t=e.join("");return Object.keys(colorList).forEach(function(s){var o=t+s;TObject.defineProperty(r,s,{get(){return fncache[o]||(fncache[o]=extend(function(d){return r(color[s](d))},e.concat(s))),fncache[o]}})}),r}function replaceClose(r,e,t,s){var o=r.substring(s+t.length),n=o.indexOf(t);return r.substring(0,s)+e+(~n?replaceClose(o,e,t,n):o)}function getFn(r){var e=colorList[r];if(!e||!isSupported)return function(o){return String(o)};var t=e[0],s=e[1];return function(o){if(o===""||o==null)return"";o=""+o;var n=o.indexOf(s,t.length);return t+(n>-1&&n<o.length-1?replaceClose(o,t,s,n):o)+s}}function color(r,e){return getFn(e)(r)}color.list=colorList;function init(){Object.keys(colorList).forEach(function(r){clc[r]=color[r]=extend(getFn(r),[r])})}for(var clc={color,list:colorList,log(r,e){console.log(color(r,e))},isSupported(){return isSupported},enable(){isSupported=!0,init()},disable(){isSupported=!1,init()},strip(r){return r.replace(/\x1b\[\d+m/gm,"")}},i=0;i<256;i++)colorList["c"+i]=["38;5;"+i,0],colorList["bg"+i]=["48;5;"+i,0];Object.keys(colorList).forEach(function(r){colorList[r]=colorList[r].map(function(e){return"\x1B["+e+"m"}),clc.log[r]=function(){for(var e=[],t=0;t<arguments.length;t++)e.push(arguments[t]);console.log(color[r](e.join(" ")))}}),init(),module.exports=clc})(src);var clc=srcExports;const{log,color,list,isSupported,disable,enable,strip,reset,bold,dim,italic,underline,inverse,hidden,strikethrough,black,red,green,yellow,blue,magenta,cyan,white,gray,grey,redBright,greenBright,yellowBright,blueBright,magentaBright,cyanBright,whiteBright,bgBlack,bgRed,bgGreen,bgYellow,bgBlue,bgMagenta,bgCyan,bgWhite,blackBG,redBG,greenBG,yellowBG,blueBG,magentaBG,cyanBG,whiteBG,bgBlackBright,bgRedBright,bgGreenBright,bgYellowBright,bgBlueBright,bgMagentaBright,bgCyanBright,bgWhiteBright}=clc;class HumanTranslator{translateSide(e,t){const s=t.getAllCubelets(),o=t.getDimension(),n=10,d=(g,c,m)=>{for(const S of s){const v=S.stickers.find(O=>O.side===g&&O.x===c&&O.y===m);if(v)return v}console.log(`Sticker not found: ${Sides[g]}, ${c}, ${m}`)},f=[];f.push(`${(Sides[e]+Array.from(new Array(n)).fill(" ").join("")).substring(0,n)}`);for(let g=0;g<o;++g){let c="";for(let m=0;m<o;++m){const S=d(e,m,g),v=Colors[S.color].substring(0,1)+HumanTranslator.mapToSubscript(`${("  "+S.id).slice(-2)}  `);let O=Colors[S.color].toLowerCase();O==="white"&&(O="gray"),O==="orange"&&(O="redBright");const w=color[O](v);c+=w}f.push(c)}return f}printCube(e){const t=e.getDimension(),s=this.translateSide(Sides.UP,e),o=this.translateSide(Sides.LEFT,e),n=this.translateSide(Sides.FRONT,e),d=this.translateSide(Sides.RIGHT,e),f=this.translateSide(Sides.BACK,e),g=this.translateSide(Sides.DOWN,e);let c="";const m=Array.from(new Array(s[1].length/3)).fill(" ").join("");s.forEach(S=>{c+=m+S+`
`}),c+=o[0],c+=(m+n[0]).slice(-m.length),c+=(m+d[0]).slice(-m.length),c+=(m+f[0]).slice(-m.length)+`
`;for(let S=1;S<t+1;++S)c+=o[S],c+=n[S],c+=d[S],c+=f[S]+`
`;g.forEach(S=>{c+=m+S+`
`}),console.log(c)}convertStringToFaceRotations(e){return e.length===0?[]:e.match(/((\d?)(\w)(\d?)('?))\s*/g).reduce((t,s)=>{const[o,n,d,f,g]=s.match(/(\d?)(\w)(\d?)('?)\s*/),c={side:Sides.UP,counterClockwiseDirection:(g==null?void 0:g.length)>0,layer:Number((f==null?void 0:f.length)>0)};switch(d.toLowerCase()){case"u":c.side=Sides.UP;break;case"l":c.side=Sides.LEFT;break;case"f":c.side=Sides.FRONT;break;case"r":c.side=Sides.RIGHT;break;case"b":c.side=Sides.BACK;break;case"d":c.side=Sides.DOWN;break;default:return t}return(n==null?void 0:n.length)>0?t.push([c,c]):t.push([c]),t},[])}translateRotations(e,t){const s=[...e];let o=0,n="";t!=null&&t.showNumberOfMoves&&(o++,n+=`${e.length}:      `.substring(0,4));let d=s.shift();for(;d;){const f=s[0];let g=" ";f&&rotationsAreEqual(f,d)&&(s.shift(),g="2");let c="";if(t&&t.showLayer){let S=1;d.layer!==void 0&&(S=d.layer+1),c=S.toString(),t.subscript&&(c=HumanTranslator.mapToSubscript(S.toString()))}const m=d.counterClockwiseDirection;n+=`${g}${Sides[d.side].substring(0,1)}${m?"'":" "}${c}  `,(t==null?void 0:t.lineBreak)!==void 0&&o%(t==null?void 0:t.lineBreak)===(t==null?void 0:t.lineBreak)-1&&(n+=`
`),++o,d=s.shift()}return n}translateCubelets(e){let t="";return e.map(s=>{s.stickers.map(o=>{const n=Colors[o.color],d=Sides[o.side],f=HumanTranslator.mapToSmallTopLetters(o.id.toString()),g=`${HumanTranslator.mapToSubscript("("+o.x+","+o.y+")")}`;t+=`${n.substring(0,1).toUpperCase().concat(n.substring(1).toLowerCase())}: ${d}${f}${g};  `}),t+=`
`}),t}static mapToSmallTopLetters(e){const t=new Map;return t.set("0","⁰"),t.set("1","¹"),t.set("2","²"),t.set("3","³"),t.set("4","⁴"),t.set("5","⁵"),t.set("6","⁶"),t.set("7","⁷"),t.set("8","⁸"),t.set("9","⁹"),t.set(",","﹐"),e.split("").map(s=>t.has(s)?t.get(s):s).join("")}static mapToSubscript(e){const t=new Map;return t.set("0","₀"),t.set("1","₁"),t.set("2","₂"),t.set("3","₃"),t.set("4","₄"),t.set("5","₅"),t.set("6","₆"),t.set("7","₇"),t.set("8","₈"),t.set("9","₉"),t.set("0","₀"),t.set("(","₍"),t.set(")","₎"),e.split("").map(s=>t.has(s)?t.get(s):s).join("")}}var Metrics=(r=>(r[r.NOT_MEASURED=0]="NOT_MEASURED",r[r.RUN_CITIZEN_ROTATIONS=1]="RUN_CITIZEN_ROTATIONS",r[r.CALCULATE_CITIZEN_SCORE=2]="CALCULATE_CITIZEN_SCORE",r[r.APPLYING_ROTATIONS=3]="APPLYING_ROTATIONS",r[r.CREATE_NEXT_GENERATION=4]="CREATE_NEXT_GENERATION",r[r.COMPUTE_GENE=5]="COMPUTE_GENE",r[r.AGGREGATE_CURRENT_GENERATION=6]="AGGREGATE_CURRENT_GENERATION",r[r.CHECK_SOLUTION=7]="CHECK_SOLUTION",r[r.MEASUREMENT_OVERHEAD=8]="MEASUREMENT_OVERHEAD",r))(Metrics||{});class GeneticAlgorithmSolver{constructor(e){l(this,"measurer");l(this,"initialState");l(this,"goalStateHash");l(this,"geneticAlgorithm");l(this,"citizens");l(this,"aborted");l(this,"actions");this.measurer=new ProcedureMeasurer,this.initialState=e.clone(),this.aborted=!1,this.actions=[];const t=e.getCubeletsBySides(Sides.BACK,Sides.LEFT,Sides.DOWN)[0],s=this.buildSolvedPocketCubeFromCornerCubelet(t);this.goalStateHash=s.getHash(),[Sides.FRONT,Sides.UP,Sides.RIGHT].map(o=>[!0,!1].map(n=>{this.actions.push({side:o,counterClockwiseDirection:n,layer:0})})),this.geneticAlgorithm=new GeneticAlgorithm(this.actions.length,GeneticAlgorithmConfig.maxNumOfRotations),this.citizens=this.geneticAlgorithm.createNextGeneration()}async findSolution(){return this.measurer.start(),new Promise((e,t)=>{for(;;){if(this.aborted)return t();const s=[];for(let o of this.citizens){const n=this.runCitizen(o);if(n.score===this.goalStateHash.length)return e(this.createSolution(n));this.measurer.add(Metrics[6],()=>s.push(n))}this.citizens=this.measurer.add(Metrics[4],()=>this.geneticAlgorithm.createNextGeneration(s))}})}abort(){this.aborted=!0}runCitizen(e){let t=this.initialState.clone();return e.genes.reduce((s,o)=>this.measurer.add(Metrics[7],()=>s.score===this.goalStateHash.length)?(console.log(t.isSolved(),s.score,this.goalStateHash.length,this.goalStateHash.split("").length),s):(t=this.measurer.add(Metrics[3],()=>t.rotateFace(this.actions[o])),this.measurer.add(Metrics[5],()=>s.genes.push(o)),s.score=this.measurer.add(Metrics[2],()=>this.calculateCitizenScore(t)),s),{score:0,genes:[]})}calculateCitizenScore(e){return e.getConfiguration().split("").filter((s,o)=>s===this.goalStateHash[o]).length}createSolution(e){new HumanTranslator().translateRotations(e.genes.map(s=>this.actions[s]));const t=new RotationsTuner().tune(e.genes.map(s=>this.actions[s]));return this.measurer.finish(),{rotations:t,totalTime:this.measurer.getTotalTime(),data:{armageddonCounter:this.geneticAlgorithm.getArmageddonCounter(),metrics:this.measurer.getData({notMeasuredLabel:Metrics[0],measurementOverheadLabel:Metrics[8]}),generations:this.geneticAlgorithm.getGenerationsCounter()}}}buildSolvedPocketCubeFromCornerCubelet(e){const t=new Map;return e.stickers.forEach(s=>{t.set(s.side,s.color),t.set(getOppositeSide(s.side),getOppositeColor(s.color))}),new RubiksCube({colorMap:t,dimension:this.initialState.getDimension()})}}class KeyboardInterpreter{readKeys(e,t){let s;switch(e.key.toLowerCase()){case"w":s=Sides.UP;break;case"a":s=Sides.LEFT;break;case"s":s=Sides.FRONT;break;case"d":s=Sides.RIGHT;break;case"f":s=Sides.BACK;break;case"x":s=Sides.DOWN;break}if(s!==void 0)return{side:s,counterClockwiseDirection:e.shiftKey,layer:t}}}class HumanSolver{constructor(e){l(this,"moves");l(this,"findSolutionResolve");l(this,"findSolutionReject");l(this,"cube");l(this,"startTime");l(this,"keyboardInterpreter");this.cube=e,this.moves=[],this.keyboardInterpreter=new KeyboardInterpreter}async findSolution(){return this.startTime=Date.now(),new Promise((e,t)=>{this.findSolutionResolve=e,this.findSolutionReject=t})}abort(){this.findSolutionReject()}async readKeys(e){if(this.cube.isSolved())return;const t=this.keyboardInterpreter.readKeys(e);if(t!==void 0)return this.moves.push(t),this.cube=this.cube.rotateFace(t),this.cube.isSolved()&&this.findSolutionResolve({rotations:this.moves,totalTime:Date.now()-this.startTime,data:{human:!0}}),t}}const WeightedAStarAlgorithmConfig={heuristicWeight:50},GeneticAlgorithmConfig={mutationRate:.1,populationPerGeneration:100,maxNumOfRotations:30,elitism:15,armageddonThreshold:5e3},Configuration={metrics:{enabled:!1},world:{debug:!1,scrambleMoves:15,scrambleRotationDuration:100,cubesCircleRay:4.5,camera:{closeDistance:20,farDistance:55}},renderers:{translationDuration:500,rotationDuration:250,titleDistance:8.5,cubeSize:2.5},initiallySelectedCubeTypeIndex:1,cubeTypes:[{label:"2x2",dimension:2,instantiator:()=>new RubiksCube({dimension:2}),methods:[{key:"Human",instantiator:r=>new HumanSolver(new RubiksCube({clone:r})),checked:!1,info:"Use keys 'WASDFX' combined with 'shift' to rotate cube faces"},{key:"IDDFS",instantiator:r=>new InterativeDeepeningDepthFirstSearchSolver(new RubiksCube({clone:r})),checked:!1,info:"Interative-deepening depth-first-search. Brute force"},{key:"BFS",instantiator:r=>new BreadthFirstSearchSolver(new RubiksCube({clone:r})),checked:!1,info:"Breadth-first-search. Brute force"},{key:"IDA*",instantiator:r=>new InterativeDeepeningAStarSolver(new RubiksCube({clone:r})),checked:!0,info:"Interative-deepening A star. Uses number of misplaced stickers as heuristic."},{key:"GA",instantiator:r=>new GeneticAlgorithmSolver(new RubiksCube({clone:r})),checked:!1,info:`Random movements improved by genetic algorithm. Uses number of misplaced stickers as fitness function. Population: ${GeneticAlgorithmConfig.populationPerGeneration}. Elitism ${GeneticAlgorithmConfig.elitism}.  Mutation rate ${GeneticAlgorithmConfig.mutationRate}. `},{key:"WA*",instantiator:r=>new WeightedAStarSolver(new RubiksCube({clone:r})),checked:!0,info:`Weighted A star. No re-expansions. Uses number of misplaced stickers as heuristic and weights the heuristic (${WeightedAStarAlgorithmConfig.heuristicWeight} * h(x)) value.`},{key:"BiBFS",instantiator:r=>new BidirectionalBreadthFirstSearchSolver(new RubiksCube({clone:r})),checked:!0,info:"BiDirectional Breadth-first-search. Brute force."}]},{label:"3x3",dimension:3,instantiator:()=>new RubiksCube({dimension:3}),methods:[{key:"Human",instantiator:r=>new HumanSolver(new RubiksCube({clone:r})),checked:!1,info:"Use keys 'WASDFX' combined with 'shift' to rotate cube faces"}]},{label:"4x4",dimension:4,instantiator:()=>new RubiksCube({dimension:4}),methods:[{key:"Human",instantiator:r=>new HumanSolver(new RubiksCube({clone:r})),checked:!1,info:"Use keys 'WASDFX' combined with 'shift' and numbers to rotate cube faces"}]},{label:"5x5",dimension:5,instantiator:()=>new RubiksCube({dimension:5}),methods:[{key:"Human",instantiator:r=>new HumanSolver(new RubiksCube({clone:r})),checked:!1,info:"Use keys 'WASDFX' combined with 'shift' and numbers to rotate cube faces"}]}]},solverMethodFinder=r=>{for(let e of Configuration.cubeTypes)if(e.label.toLowerCase()===r.label.toLowerCase()){for(let t of e.methods)if(t.key.toLowerCase()===r.solverTag.toLowerCase())return t;return}};let solver;self.onmessage=async r=>{if(r.data.abort)solver.abort();else{const e=r.data.solverTag.toLowerCase(),t=solverMethodFinder(r.data);if(e&&t)if(r.data.cube)try{solver=t.instantiator(r.data.cube);const s=await solver.findSolution();self.postMessage({solution:JSON.stringify(s),solverKey:e})}catch(s){console.log(`Solver '${r.data.label}.${e}' aborted`,s),self.postMessage({error:`Solver '${r.data.label}.${e}' aborted`,solverTag:r.data.solverTag})}else if(r.data.keyboardEvent){if(solver instanceof HumanSolver){const s=await solver.readKeys(r.data.keyboardEvent);s!==void 0&&self.postMessage({faceRotation:s,solverKey:e})}}else self.postMessage({error:`Command for '${r.data}' not found`,solverTag:r.data.solverTag});else self.postMessage({error:`Solver '${r.data.solverTag}' not found`,solverTag:r.data.solverTag})}}})();
