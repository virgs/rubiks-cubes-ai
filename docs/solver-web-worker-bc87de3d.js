var k=Object.defineProperty;var F=(N,R,r)=>R in N?k(N,R,{enumerable:!0,configurable:!0,writable:!0,value:r}):N[R]=r;var a=(N,R,r)=>(F(N,typeof R!="symbol"?R+"":R,r),r);(function(){"use strict";var Sides=(r=>(r[r.UP=0]="UP",r[r.LEFT=1]="LEFT",r[r.FRONT=2]="FRONT",r[r.RIGHT=3]="RIGHT",r[r.BACK=4]="BACK",r[r.DOWN=5]="DOWN",r))(Sides||{});const getAllSides=()=>Object.keys(Sides).filter(r=>!isNaN(Number(r))).map(r=>Number(r)),getOppositeSide=r=>{switch(r){case 0:return 5;case 5:return 0;case 1:return 3;case 3:return 1;case 2:return 4;case 4:return 2}};var Colors=(r=>(r[r.YELLOW=0]="YELLOW",r[r.ORANGE=1]="ORANGE",r[r.BLUE=2]="BLUE",r[r.RED=3]="RED",r[r.GREEN=4]="GREEN",r[r.WHITE=5]="WHITE",r))(Colors||{});const getOppositeColor=r=>{switch(r){case 2:return 4;case 4:return 2;case 3:return 1;case 1:return 3;case 0:return 5;case 5:return 0}},colorToStringMap=new Map;colorToStringMap.set(0,"y"),colorToStringMap.set(1,"o"),colorToStringMap.set(2,"b"),colorToStringMap.set(3,"r"),colorToStringMap.set(4,"g"),colorToStringMap.set(5,"w");const mapColorInitialsToString=r=>colorToStringMap.get(r),stringToColorMap=new Map;stringToColorMap.set("y",0),stringToColorMap.set("o",1),stringToColorMap.set("b",2),stringToColorMap.set("r",3),stringToColorMap.set("g",4),stringToColorMap.set("w",5);const mapStringInitialToColor=r=>stringToColorMap.get(r),N=class{constructor(e){a(this,"dimension");a(this,"stickers");a(this,"cubeletCounter");this.dimension=e,this.stickers=[],this.cubeletCounter=0}create(){if(N.cubeletsCreatorMap.has(this.dimension))return N.cubeletsCreatorMap.get(this.dimension);{let e=0;getAllSides().map(l=>{for(let m=0;m<this.dimension;++m)for(let f=0;f<this.dimension;++f)this.stickers.push({side:l,x:f,y:m,id:e++})});const s=this.extractCenters(),t=this.extractCorners(),o=this.extractEdges(),n=[...t,...o,...s];return N.cubeletsCreatorMap.set(this.dimension,n),n}}cubeletsMerger(e){const s={stickers:[],id:++this.cubeletCounter};return e.forEach(t=>{this.stickers.forEach((o,n,l)=>{o.side===t.side&&t.x===o.x&&t.y===o.y&&s.stickers.push(...l.splice(n,1))})}),s}extractEdges(){const e=this.dimension-1,s=[];for(let t=1;t<this.dimension-1;++t)s.push(this.cubeletsMerger([{side:Sides.FRONT,x:0,y:t},{side:Sides.LEFT,x:e,y:t}])),s.push(this.cubeletsMerger([{side:Sides.FRONT,x:e,y:t},{side:Sides.RIGHT,x:0,y:t}])),s.push(this.cubeletsMerger([{side:Sides.FRONT,x:t,y:0},{side:Sides.UP,x:t,y:e}])),s.push(this.cubeletsMerger([{side:Sides.FRONT,x:t,y:e},{side:Sides.DOWN,x:t,y:0}])),s.push(this.cubeletsMerger([{side:Sides.BACK,x:e,y:t},{side:Sides.LEFT,x:0,y:t}])),s.push(this.cubeletsMerger([{side:Sides.BACK,x:0,y:t},{side:Sides.RIGHT,x:e,y:t}])),s.push(this.cubeletsMerger([{side:Sides.BACK,x:t,y:0},{side:Sides.UP,x:e-t,y:0}])),s.push(this.cubeletsMerger([{side:Sides.BACK,x:t,y:e},{side:Sides.DOWN,x:e-t,y:e}])),s.push(this.cubeletsMerger([{side:Sides.RIGHT,x:t,y:0},{side:Sides.UP,x:e,y:e-t}])),s.push(this.cubeletsMerger([{side:Sides.RIGHT,x:t,y:e},{side:Sides.DOWN,x:e,y:t}])),s.push(this.cubeletsMerger([{side:Sides.LEFT,x:t,y:0},{side:Sides.UP,x:0,y:t}])),s.push(this.cubeletsMerger([{side:Sides.LEFT,x:t,y:e},{side:Sides.DOWN,x:0,y:e-t}]));return s}extractCenters(){const e=this.dimension-1,s=[];return this.stickers.filter(t=>t.x!==0&&t.x!==e&&t.y!==0&&t.y!==e).forEach(t=>{s.push({stickers:[t],id:++this.cubeletCounter})}),s}extractCorners(){const e=[],s=this.dimension-1;return e.push(this.cubeletsMerger([{side:Sides.FRONT,x:0,y:0},{side:Sides.UP,x:0,y:s},{side:Sides.LEFT,x:s,y:0}])),e.push(this.cubeletsMerger([{side:Sides.FRONT,x:s,y:0},{side:Sides.UP,x:s,y:s},{side:Sides.RIGHT,x:0,y:0}])),e.push(this.cubeletsMerger([{side:Sides.FRONT,x:0,y:s},{side:Sides.DOWN,x:0,y:0},{side:Sides.LEFT,x:s,y:s}])),e.push(this.cubeletsMerger([{side:Sides.FRONT,x:s,y:s},{side:Sides.DOWN,x:s,y:0},{side:Sides.RIGHT,x:0,y:s}])),e.push(this.cubeletsMerger([{side:Sides.BACK,x:0,y:0},{side:Sides.UP,x:s,y:0},{side:Sides.RIGHT,x:s,y:0}])),e.push(this.cubeletsMerger([{side:Sides.BACK,x:s,y:0},{side:Sides.UP,x:0,y:0},{side:Sides.LEFT,x:0,y:0}])),e.push(this.cubeletsMerger([{side:Sides.BACK,x:0,y:s},{side:Sides.DOWN,x:s,y:s},{side:Sides.RIGHT,x:s,y:s}])),e.push(this.cubeletsMerger([{side:Sides.BACK,x:s,y:s},{side:Sides.DOWN,x:0,y:s},{side:Sides.LEFT,x:0,y:s}])),e}};let CubeletsCreator=N;a(CubeletsCreator,"cubeletsCreatorMap",new Map);const R=class{constructor(e){a(this,"dimension");if(this.dimension=e,!R.faceRotatorMap.has(this.dimension)){const s=new Map;for(let t=0;t<this.dimension;++t){const o=this.createUpFaceClockwiseRotator(t),n=this.createLeftFaceClockwiseRotator(t),l=this.createFrontFaceClockwiseRotator(t),m=this.createRightFaceClockwiseRotator(t),f=this.createBackFaceClockwiseRotator(t),S=this.createDownFaceClockwiseRotator(t),T=new Map;T.set(Sides.UP,o.map(g=>this.faceStickerMapper(g))),T.set(Sides.LEFT,n.map(g=>this.faceStickerMapper(g))),T.set(Sides.FRONT,l.map(g=>this.faceStickerMapper(g))),T.set(Sides.RIGHT,m.map(g=>this.faceStickerMapper(g))),T.set(Sides.BACK,f.map(g=>this.faceStickerMapper(g))),T.set(Sides.DOWN,S.map(g=>this.faceStickerMapper(g))),s.set(t,T)}R.faceRotatorMap.set(this.dimension,s)}}rotate(e,s){const t=new RubiksCube({clone:e.getConfiguration()}),o=[];return R.faceRotatorMap.get(this.dimension).get(s.layer||0).get(s.side).forEach(n=>{s.counterClockwiseDirection?o.push({index:n.source,color:e.getColorOfIndex(n.destination)}):o.push({index:n.destination,color:e.getColorOfIndex(n.source)})}),t.setColorsOfIndexes(o),t}idMapper(e){let s=e.side*this.dimension*this.dimension;return s+=this.dimension*e.y,s+=e.x,s}faceStickerMapper(e){return{source:this.idMapper(e.source),destination:this.idMapper(e.destination)}}createSideLidClockwiseRotator(e){const s=[];for(let t=0;t<this.dimension*this.dimension;++t){const o=t%this.dimension,n=Math.floor(t/this.dimension),l=this.dimension-1-n,m=o;s.push({source:{side:e,x:o,y:n},destination:{side:e,x:l,y:m}})}return s}createUpFaceClockwiseRotator(e){this.dimension-1;const s=[];e===0&&s.push(...this.createSideLidClockwiseRotator(Sides.UP));for(let t=0;t<this.dimension;++t)s.push({source:{side:Sides.FRONT,x:t,y:e},destination:{side:Sides.LEFT,x:t,y:e}}),s.push({source:{side:Sides.LEFT,x:t,y:e},destination:{side:Sides.BACK,x:t,y:e}}),s.push({source:{side:Sides.BACK,x:t,y:e},destination:{side:Sides.RIGHT,x:t,y:e}}),s.push({source:{side:Sides.RIGHT,x:t,y:e},destination:{side:Sides.FRONT,x:t,y:e}});return s}createLeftFaceClockwiseRotator(e){const s=this.dimension-1,t=[];e===0&&t.push(...this.createSideLidClockwiseRotator(Sides.LEFT));for(let o=0;o<this.dimension;++o)t.push({source:{side:Sides.FRONT,x:e,y:o},destination:{side:Sides.DOWN,x:e,y:o}}),t.push({source:{side:Sides.DOWN,x:e,y:o},destination:{side:Sides.BACK,x:s-e,y:s-o}}),t.push({source:{side:Sides.BACK,x:s-e,y:s-o},destination:{side:Sides.UP,x:e,y:o}}),t.push({source:{side:Sides.UP,x:e,y:o},destination:{side:Sides.FRONT,x:e,y:o}});return t}createFrontFaceClockwiseRotator(e){const s=this.dimension-1,t=[];e===0&&t.push(...this.createSideLidClockwiseRotator(Sides.FRONT));for(let o=0;o<this.dimension;++o)t.push({source:{side:Sides.UP,x:o,y:s-e},destination:{side:Sides.RIGHT,x:e,y:o}}),t.push({source:{side:Sides.RIGHT,x:e,y:o},destination:{side:Sides.DOWN,x:s-o,y:e}}),t.push({source:{side:Sides.DOWN,x:s-o,y:e},destination:{side:Sides.LEFT,x:s-e,y:s-o}}),t.push({source:{side:Sides.LEFT,x:s-e,y:s-o},destination:{side:Sides.UP,x:o,y:s-e}});return t}createRightFaceClockwiseRotator(e){const s=this.dimension-1,t=[];e===0&&t.push(...this.createSideLidClockwiseRotator(Sides.RIGHT));for(let o=0;o<this.dimension;++o)t.push({source:{side:Sides.UP,x:s-e,y:o},destination:{side:Sides.BACK,x:e,y:s-o}}),t.push({source:{side:Sides.BACK,x:e,y:s-o},destination:{side:Sides.DOWN,x:s-e,y:o}}),t.push({source:{side:Sides.DOWN,x:s-e,y:o},destination:{side:Sides.FRONT,x:s-e,y:o}}),t.push({source:{side:Sides.FRONT,x:s-e,y:o},destination:{side:Sides.UP,x:s-e,y:o}});return t}createBackFaceClockwiseRotator(e){const s=this.dimension-1,t=[];e===0&&t.push(...this.createSideLidClockwiseRotator(Sides.BACK));for(let o=0;o<this.dimension;++o)t.push({source:{side:Sides.LEFT,x:e,y:o},destination:{side:Sides.DOWN,x:o,y:s-e}}),t.push({source:{side:Sides.DOWN,x:o,y:s-e},destination:{side:Sides.RIGHT,x:s-e,y:s-o}}),t.push({source:{side:Sides.RIGHT,x:s-e,y:s-o},destination:{side:Sides.UP,x:s-o,y:e}}),t.push({source:{side:Sides.UP,x:s-o,y:e},destination:{side:Sides.LEFT,x:e,y:o}});return t}createDownFaceClockwiseRotator(e){const s=this.dimension-1,t=[];e===0&&t.push(...this.createSideLidClockwiseRotator(Sides.DOWN));for(let o=0;o<this.dimension;++o)t.push({source:{side:Sides.LEFT,x:o,y:s-e},destination:{side:Sides.FRONT,x:o,y:s-e}}),t.push({source:{side:Sides.FRONT,x:o,y:s-e},destination:{side:Sides.RIGHT,x:o,y:s-e}}),t.push({source:{side:Sides.RIGHT,x:o,y:s-e},destination:{side:Sides.BACK,x:o,y:s-e}}),t.push({source:{side:Sides.BACK,x:o,y:s-e},destination:{side:Sides.LEFT,x:o,y:s-e}});return t}};let RubiksCubeFaceRotator=R;a(RubiksCubeFaceRotator,"faceRotatorMap",new Map);const defaultColorMap=new Map;defaultColorMap.set(Sides.FRONT,Colors.BLUE),defaultColorMap.set(Sides.UP,Colors.YELLOW),defaultColorMap.set(Sides.RIGHT,Colors.RED),defaultColorMap.set(Sides.LEFT,Colors.ORANGE),defaultColorMap.set(Sides.BACK,Colors.GREEN),defaultColorMap.set(Sides.DOWN,Colors.WHITE);class RubiksCube{constructor(e){a(this,"configuration");a(this,"dimension");a(this,"faceRotator");a(this,"colorlessCubelets");if(this.dimension=e==null?void 0:e.dimension,e!=null&&e.clone)this.dimension=Math.sqrt(e.clone.length/6),this.configuration=e.clone.slice();else{const s=this.dimension*this.dimension,t=(e==null?void 0:e.colorMap)||defaultColorMap,o=getAllSides();this.configuration="";for(let n=0;n<o.length;++n){const l=t.get(n),m=mapColorInitialsToString(l);this.configuration+=m.repeat(s)}}this.faceRotator=new RubiksCubeFaceRotator(this.dimension),this.colorlessCubelets=new CubeletsCreator(this.dimension).create()}clone(){return new RubiksCube({clone:this.configuration})}getDimension(){return this.dimension}getConfiguration(){return this.configuration}getHash(){return this.configuration}isSolved(){const e=this.dimension*this.dimension,s=getAllSides(),t=Array.from(new Array(e));return s.every((o,n)=>t.every((l,m)=>this.configuration[n*e+m]===this.configuration[n*e]))}rotateFace(e){return this.faceRotator.rotate(this,e)}getAllCubelets(){return this.addColorToCubelets(this.colorlessCubelets)}getAllColorlessCubelets(){return this.colorlessCubelets}getSideOfIndex(e){const s=getAllSides().length;return e/s}getColorlessCubeletOfIndex(e){return this.colorlessCubelets.find(s=>s.stickers.some(t=>t.id===e))}getCubeletsBySides(...e){const s=this.colorlessCubelets.filter(t=>t.stickers.every(o=>e.includes(o.side)));return this.addColorToCubelets(s)}getCubeletsByColors(...e){const s=this.colorlessCubelets.filter(t=>t.stickers.every(o=>e.includes(mapStringInitialToColor(this.configuration[o.id]))));return this.addColorToCubelets(s)}getColorOfIndex(e){return mapStringInitialToColor(this.configuration[e])}setColorsOfIndexes(e){const s=this.configuration.split("");e.forEach(t=>{s[t.index]=mapColorInitialsToString(t.color)}),this.configuration=s.join("")}addColorToCubelets(e){return e.map(s=>({stickers:s.stickers.map(t=>({...t,color:mapStringInitialToColor(this.configuration[t.id])}))}))}}var commonjsGlobal=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function getDefaultExportFromCjs(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}var doubleLinkedList=LinkedList;function LinkedList(){this._start=null,this._end=null,this.length=0}LinkedList.prototype.unShift=function(r){if(this._start===null)this._start=makeNode(r),this._end=this._start;else{var e=this._start;this._start.previous=makeNode(r),this._start=this._start.previous,this._start.next=e}this.length++},LinkedList.prototype.push=function(r){if(this._start===null)this._start=makeNode(r),this._end=this._start;else{var e=this._end;this._end.next=makeNode(r),this._end=this._end.next,this._end.previous=e}this.length++},LinkedList.prototype.add=function(r,e){if(r%1===0)if(r<=0)this.unShift(e);else if(r>=this.length)this.push(e);else{var s=findNode.call(this,r);if(s){var t=s.previous,o=s,n=makeNode(e);n.previous=t,t.next=n,n.next=o,o.previous=n,this.length++}}},LinkedList.prototype.shift=function(){if(this._start){var r=this._start.data;return this._start.next===null?(this._end=null,this._start=null):(this._start=this._start.next,this._start.previous=null),this.length--,r}else return},LinkedList.prototype.pop=function(){if(this._end){var r=this._end.data;return this._end.previous===null?(this._end=null,this._start=null):(this._end=this._end.previous,this._end.next=null),this.length--,r}else return},LinkedList.prototype.remove=function(r){if(r===0)return this.shift();if(r===this.length-1)return this.pop();var e=findNode.call(this,r);if(e){var s=e.previous,t=e.next;s.next=t,t.previous=s,this.length--}else return},LinkedList.prototype.first=function(){if(this._start)return this._start.data},LinkedList.prototype.last=function(){if(this._end)return this._end.data},LinkedList.prototype.get=function(r){var e=findNode.call(this,r);if(e)return e.data},LinkedList.prototype.toString=function(){for(var r=this._start,e="",s=0;s<this.length;s++)typeof r.data=="object"?e+=JSON.stringify(r.data):e+=r.data,s!==this.length-1&&(e+=", "),r=r.next;return e};function makeNode(r){return{data:r,previous:null,next:null}}function findNode(r){var e,s;if(r>=this.length||r<0||r%1!==0)e=null;else if(r<this.length/2)for(e=this._start,s=0;s<r;s++)e=e.next;else for(e=this._end,s=this.length-1;s>r;s--)e=e.previous;return e}class ProcedureMeasurer{constructor(e=Configuration.metrics.enabled){a(this,"map");a(this,"enabled");a(this,"measurerOverhead");a(this,"startTime");a(this,"totalTime");this.map=new Map,this.enabled=e,this.measurerOverhead=0}add(e,s){const t=performance.now();if(!this.enabled)return s();const o=s(),n=performance.now(),l=this.map.get(e)||{elapsedTime:0,calls:0,stack:"",stackSize:0};return l.elapsedTime+=n-t,++l.calls,this.map.set(e,l),this.measurerOverhead+=performance.now()-n,o}start(){this.startTime=performance.now()}finish(){this.startTime&&(this.totalTime=performance.now()-this.startTime)}getTotalTime(){return this.totalTime}getData(e){const s=[];if(this.totalTime){let t=0;Array.from(this.map.entries()).forEach(o=>{const[n,l]=o;t+=l.elapsedTime,s.push(this.createSummary(l.elapsedTime,l.calls,n))}),e!=null&&e.measurementOverheadLabel&&(s.push(this.createSummary(this.measurerOverhead,0,e.measurementOverheadLabel)),t+=this.measurerOverhead),e!=null&&e.notMeasuredLabel&&s.push(this.createSummary(this.totalTime-t,0,e.notMeasuredLabel))}return s.sort((t,o)=>o.totalTime-t.totalTime)}createSummary(e,s,t){const o=100*e/this.totalTime;return{label:t,totalTime:e,totalRelativeTime:Math.trunc(100*o)/100+"%",numOfCalls:s,avgTimePerCall:e*1/(s||1)}}}const rotationsAreEqual=(r,e)=>r.layer===e.layer&&r.side===e.side&&r.counterClockwiseDirection===e.counterClockwiseDirection,rotationsCancel=(r,e)=>r.layer===e.layer&&r.side===e.side&&r.counterClockwiseDirection!==e.counterClockwiseDirection,getOppositeRotation=r=>({layer:r.layer,side:r.side,counterClockwiseDirection:!r.counterClockwiseDirection});var Metrics$6=(r=>(r[r.ADD_CANDIDATE=0]="ADD_CANDIDATE",r[r.POP_CANDIDATE=1]="POP_CANDIDATE",r[r.HASH_CALCULATION=2]="HASH_CALCULATION",r[r.VISISTED_LIST_CHECK=3]="VISISTED_LIST_CHECK",r[r.ADD_TO_VISISTED_LIST_CHECK=4]="ADD_TO_VISISTED_LIST_CHECK",r[r.PERFORM_ROTATION=5]="PERFORM_ROTATION",r[r.NOT_MEASURED=6]="NOT_MEASURED",r[r.MEASUREMENT_OVERHEAD=7]="MEASUREMENT_OVERHEAD",r))(Metrics$6||{});class BidirectionalBreadthFirstSearchSolver{constructor(e){a(this,"measurer");a(this,"forwardSearchToExploreList");a(this,"forwardSearchExploredMap");a(this,"reverseSearchToExploreList");a(this,"reverseSearchExploredMap");a(this,"actions");a(this,"iterations");a(this,"aborted");this.forwardSearchToExploreList=new doubleLinkedList,this.reverseSearchToExploreList=new doubleLinkedList,this.actions=[],this.iterations=0,this.measurer=new ProcedureMeasurer,this.forwardSearchExploredMap=new Map,this.reverseSearchExploredMap=new Map,this.aborted=!1;const s={cube:e,rotation:void 0,parent:void 0};this.forwardSearchToExploreList.push(s);const t=[];[Sides.RIGHT,Sides.UP,Sides.FRONT].map(m=>[!0,!1].map(f=>{t.push(getOppositeSide(m)),this.actions.push({side:m,counterClockwiseDirection:f,layer:0})}));const o=e.getCubeletsBySides(...t)[0],l={cube:this.buildSolvedCubeFromCornerCubelet(o,e.getDimension()),rotation:void 0,parent:void 0};this.reverseSearchToExploreList.push(l)}abort(){this.aborted=!0}async findSolution(){return new Promise((e,s)=>{this.measurer.start();let t,o,n=0;for(;this.forwardSearchToExploreList.length>0&&this.reverseSearchToExploreList.length>0;){if(++this.iterations,this.aborted)return s();do t=this.measurer.add(Metrics$6[1],()=>this.forwardSearchToExploreList.shift());while(this.measurer.add(Metrics$6[3],()=>this.forwardSearchExploredMap.has(t.cube.getHash())));do o=this.measurer.add(Metrics$6[1],()=>this.reverseSearchToExploreList.shift());while(this.measurer.add(Metrics$6[3],()=>this.reverseSearchExploredMap.has(o.cube.getHash())));++n;let l=this.measurer.add(Metrics$6[3],()=>this.forwardSearchExploredMap.get(o.cube.getHash()));if(l)return e(this.createSolution(l,o,n));if(l=this.measurer.add(Metrics$6[3],()=>this.reverseSearchExploredMap.get(t.cube.getHash())),l)return e(this.createSolution(t,l,n));this.measurer.add(Metrics$6[4],()=>this.forwardSearchExploredMap.set(t.cube.getHash(),t)),this.measurer.add(Metrics$6[4],()=>this.reverseSearchExploredMap.set(o.cube.getHash(),o)),this.applyRotations(this.forwardSearchToExploreList,this.forwardSearchExploredMap,t),this.applyRotations(this.reverseSearchToExploreList,this.reverseSearchExploredMap,o)}return s()})}applyRotations(e,s,t){this.actions.forEach(o=>{if(t.rotation&&(rotationsCancel(t.rotation,o)||t.parent&&t.parent.rotation&&rotationsAreEqual(t.rotation,o)&&rotationsAreEqual(t.parent.rotation,o)))return;const n=this.measurer.add(Metrics$6[5],()=>t.cube.rotateFace(o));this.measurer.add(Metrics$6[3],()=>s.has(n.getHash()))||this.measurer.add(Metrics$6[0],()=>{e.push({cube:n,rotation:o,parent:t})})})}createSolution(e,s,t){this.measurer.finish();const o=[];let n=e;for(;n&&n.rotation;)o.unshift(n.rotation),n=n.parent;for(n=s;n&&n.rotation;){const l={...n.rotation};l.counterClockwiseDirection=!l.counterClockwiseDirection,o.push(l),n=n.parent}return{rotations:o,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:Metrics$6[6],measurementOverheadLabel:Metrics$6[7]}),iterations:this.iterations,visitedNodes:t}}}buildSolvedCubeFromCornerCubelet(e,s){const t=new Map;return e.stickers.forEach(o=>{t.set(o.side,o.color),t.set(getOppositeSide(o.side),getOppositeColor(o.color))}),new RubiksCube({colorMap:t,dimension:s})}}class RotationsTuner{tune(e){let s=[...e];for(;;){const t=this.removeTwoConsecutiveOppositeRotations(s);if(s=t.result,t.modifiedFlag)continue;const o=this.replaceThreeConsecutiveRotations(s);if(s=o.result,!o.modifiedFlag)break}return s}removeTwoConsecutiveOppositeRotations(e){if(e.length===1)return{modifiedFlag:!1,result:e};let s=!1;const t=[];for(let o=0;o<e.length;++o)t.length>0&&rotationsCancel(e[o],t[t.length-1])?(s=!0,t.pop()):t.push({...e[o]});return{modifiedFlag:s,result:t}}replaceThreeConsecutiveRotations(e){if(e.length<=2)return{modifiedFlag:!1,result:e};let s=!1;const t=[];for(let o=0;o<e.length;++o)t.length>1&&rotationsAreEqual(e[o],t[t.length-1])&&rotationsAreEqual(e[o],t[t.length-2])?(s=!0,t.pop(),t.pop(),t.push({...getOppositeRotation(e[o])})):t.push({...e[o]});return{modifiedFlag:s,result:t}}}class GeneticAlgorithm{constructor(e,s){a(this,"numberOfActions");a(this,"numOfGenes");a(this,"generationsCounter");a(this,"armageddonCounter");this.numberOfActions=e,this.numOfGenes=s,this.generationsCounter=0,this.armageddonCounter=0}createNextGeneration(e){if(++this.generationsCounter,!e)return this.createNewPopulationFromScratch();if(this.generationsCounter%GeneticAlgorithmConfig.armageddonThreshold===0)return console.log("Armageddon: "+ ++this.armageddonCounter),this.createNextGeneration();const s=e.sort((t,o)=>o.score-t.score).filter((t,o)=>o<GeneticAlgorithmConfig.elitism);return Array.from(new Array(GeneticAlgorithmConfig.populationPerGeneration)).map(()=>this.reproduceCitizens(s))}getArmageddonCounter(){return this.armageddonCounter}getGenerationsCounter(){return this.generationsCounter}pickOne(e,s){let t;do t=Math.floor(Math.random()*e.length);while(s.includes(t));return{chromosome:e[t],index:t}}createNewPopulationFromScratch(){return Array.from(new Array(GeneticAlgorithmConfig.populationPerGeneration)).map(()=>({genes:Array.from(new Array(this.numOfGenes)).map(()=>Math.floor(Math.random()*this.numberOfActions)),score:NaN}))}reproduceCitizens(e){const s=this.pickOne(e,[]),t=this.pickOne(e,[s.index]),o=Math.floor(s.chromosome.genes.length*.25+Math.random()*s.chromosome.genes.length*.5);return{genes:s.chromosome.genes.map((l,m)=>{let f=l;return m>o&&(f=t.chromosome.genes[m]),Math.random()<GeneticAlgorithmConfig.mutationRate&&(f=Math.floor(Math.random()*this.numberOfActions)),f}),score:NaN}}}var Metrics$5=(r=>(r[r.NOT_MEASURED=0]="NOT_MEASURED",r[r.RUN_CITIZEN_ROTATIONS=1]="RUN_CITIZEN_ROTATIONS",r[r.CALCULATE_CITIZEN_SCORE=2]="CALCULATE_CITIZEN_SCORE",r[r.APPLYING_ROTATIONS=3]="APPLYING_ROTATIONS",r[r.CREATE_NEXT_GENERATION=4]="CREATE_NEXT_GENERATION",r[r.COMPUTE_GENE=5]="COMPUTE_GENE",r[r.AGGREGATE_CURRENT_GENERATION=6]="AGGREGATE_CURRENT_GENERATION",r[r.CHECK_SOLUTION=7]="CHECK_SOLUTION",r[r.MEASUREMENT_OVERHEAD=8]="MEASUREMENT_OVERHEAD",r))(Metrics$5||{});class GeneticAlgorithmSolver{constructor(e){a(this,"measurer");a(this,"initialState");a(this,"goalStateHash");a(this,"geneticAlgorithm");a(this,"citizens");a(this,"aborted");a(this,"actions");this.measurer=new ProcedureMeasurer,this.initialState=e.clone(),this.aborted=!1,this.actions=[];const s=e.getCubeletsBySides(Sides.BACK,Sides.LEFT,Sides.DOWN)[0],t=this.buildSolvedPocketCubeFromCornerCubelet(s);this.goalStateHash=t.getHash(),[Sides.FRONT,Sides.UP,Sides.RIGHT].map(o=>[!0,!1].map(n=>{this.actions.push({side:o,counterClockwiseDirection:n,layer:0})})),this.geneticAlgorithm=new GeneticAlgorithm(this.actions.length,GeneticAlgorithmConfig.maxNumOfRotations),this.citizens=this.geneticAlgorithm.createNextGeneration()}async findSolution(){return this.measurer.start(),new Promise((e,s)=>{for(;;){if(this.aborted)return s();const t=[];for(let o of this.citizens){const n=this.runCitizen(o);if(n.score===this.goalStateHash.length)return e(this.createSolution(n));this.measurer.add(Metrics$5[6],()=>t.push(n))}this.citizens=this.measurer.add(Metrics$5[4],()=>this.geneticAlgorithm.createNextGeneration(t))}})}abort(){this.aborted=!0}runCitizen(e){let s=this.initialState.clone();return e.genes.reduce((t,o)=>(this.measurer.add(Metrics$5[7],()=>t.score===this.goalStateHash.length)||(s=this.measurer.add(Metrics$5[3],()=>s.rotateFace(this.actions[o])),this.measurer.add(Metrics$5[5],()=>t.genes.push(o)),t.score=this.measurer.add(Metrics$5[2],()=>this.calculateCitizenScore(s))),t),{score:0,genes:[]})}calculateCitizenScore(e){return e.getConfiguration().split("").filter((t,o)=>t===this.goalStateHash[o]).length}createSolution(e){const s=new RotationsTuner().tune(e.genes.map(t=>this.actions[t]));return this.measurer.finish(),{rotations:s,totalTime:this.measurer.getTotalTime(),data:{armageddonCounter:this.geneticAlgorithm.getArmageddonCounter(),generations:this.geneticAlgorithm.getGenerationsCounter(),metrics:this.measurer.getData({notMeasuredLabel:Metrics$5[0],measurementOverheadLabel:Metrics$5[8]})}}}buildSolvedPocketCubeFromCornerCubelet(e){const s=new Map;return e.stickers.forEach(t=>{s.set(t.side,t.color),s.set(getOppositeSide(t.side),getOppositeColor(t.color))}),new RubiksCube({colorMap:s,dimension:this.initialState.getDimension()})}}var Metrics$4=(r=>(r[r.ADD_CANDIDATE=0]="ADD_CANDIDATE",r[r.POP_CANDIDATE=1]="POP_CANDIDATE",r[r.CHECK_SOLUTION=2]="CHECK_SOLUTION",r[r.BREATHING_TIME=3]="BREATHING_TIME",r[r.HASH_CALCULATION=4]="HASH_CALCULATION",r[r.VISISTED_LIST_CHECK=5]="VISISTED_LIST_CHECK",r[r.ADD_TO_VISISTED_LIST_CHECK=6]="ADD_TO_VISISTED_LIST_CHECK",r[r.PERFORM_ROTATION=7]="PERFORM_ROTATION",r[r.NOT_MEASURED=8]="NOT_MEASURED",r[r.CYCLE_AVOIDANCE_CHECK=9]="CYCLE_AVOIDANCE_CHECK",r))(Metrics$4||{});class InterativeDeepeningAStarSolver{constructor(e){a(this,"measurer");a(this,"actions");a(this,"goalStateHash");a(this,"root");a(this,"numberOfStickersThatChangeFaceInOneTwist");a(this,"iterations");a(this,"minBoundGrow",1.25);a(this,"bound");a(this,"visitedNodes");a(this,"aborted");this.iterations=[],this.measurer=new ProcedureMeasurer,this.visitedNodes=0,this.aborted=!1,this.actions=[],[Sides.FRONT,Sides.UP,Sides.RIGHT].map(n=>[!0,!1].map(l=>{this.actions.push({side:n,counterClockwiseDirection:l,layer:0})}));const s=e.getCubeletsBySides(Sides.BACK,Sides.LEFT,Sides.DOWN)[0],t=this.buildSolvedPocketCubeFromCornerCubelet(s,e.getDimension());this.goalStateHash=t.getHash();const o=e.getDimension();this.numberOfStickersThatChangeFaceInOneTwist=o*4,this.bound=Math.max(this.calculateDistanceToFinalState(e),8),this.root={cube:e,rotation:void 0,parent:void 0}}abort(){this.aborted=!0}async findSolution(){return new Promise((e,s)=>{for(this.measurer.start();!this.aborted;){const t=this.search(this.root,0);if(t.solution)return e(this.createSolution(t.solution));if(t.aborted)break;this.iterations.push({visitedNodes:this.visitedNodes,bound:this.bound}),this.bound=Math.max(t.cost,this.bound+this.minBoundGrow),this.visitedNodes=0}s(Error("Aborted"))})}search(e,s){if(++this.visitedNodes,this.aborted)return{aborted:!0};let t=this.calculateDistanceToFinalState(e.cube);if(e.cube.isSolved())return{solution:e};let o=1/0;const n=this.applyRotations(e);for(let l of n){const m=s+t;if(m>this.bound)return{cost:m};const f=this.search(l,s+1);if(f.solution||f.aborted)return f;t=Math.min(t,f.cost-1),o=Math.min(f.cost,o)}return{cost:o}}createSolution(e){this.measurer.finish();const s=[];let t=e;for(;t&&t.rotation;)s.unshift(t.rotation),t=t.parent;return{rotations:s,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:Metrics$4[8]}),visitedNodes:this.iterations.reduce((o,n)=>o+n.visitedNodes,0),iterations:this.iterations}}}applyRotations(e){const s=[];return this.actions.forEach(t=>{if(e.rotation&&(rotationsCancel(e.rotation,t)||e.parent&&e.parent.rotation&&rotationsAreEqual(e.rotation,t)&&rotationsAreEqual(e.parent.rotation,t)))return;const o=this.measurer.add(Metrics$4[7],()=>e.cube.rotateFace(t));this.measurer.add(Metrics$4[0],()=>{s.push({cube:o,rotation:t,parent:e})})}),s}calculateDistanceToFinalState(e){const s=e.getConfiguration();return Math.ceil(s.split("").filter((t,o)=>t!==this.goalStateHash[o]).length/this.numberOfStickersThatChangeFaceInOneTwist)}buildSolvedPocketCubeFromCornerCubelet(e,s){const t=new Map;return e.stickers.forEach(o=>{t.set(o.side,o.color),t.set(getOppositeSide(o.side),getOppositeColor(o.color))}),new RubiksCube({colorMap:t,dimension:s})}}var Metrics$3=(r=>(r[r.ADD_CANDIDATE=0]="ADD_CANDIDATE",r[r.POP_CANDIDATE=1]="POP_CANDIDATE",r[r.CHECK_SOLUTION=2]="CHECK_SOLUTION",r[r.BREATHING_TIME=3]="BREATHING_TIME",r[r.HASH_CALCULATION=4]="HASH_CALCULATION",r[r.VISISTED_LIST_CHECK=5]="VISISTED_LIST_CHECK",r[r.ADD_TO_VISISTED_LIST_CHECK=6]="ADD_TO_VISISTED_LIST_CHECK",r[r.PERFORM_ROTATION=7]="PERFORM_ROTATION",r[r.NOT_MEASURED=8]="NOT_MEASURED",r))(Metrics$3||{});class InterativeDeepeningDepthFirstSearchSolver{constructor(e){a(this,"measurer");a(this,"actions");a(this,"root");a(this,"iterations");a(this,"currentMaxDepth");a(this,"visitedNodes");a(this,"aborted");this.measurer=new ProcedureMeasurer,this.iterations=[],this.visitedNodes=0,this.aborted=!1,this.actions=this.createActions(),this.currentMaxDepth=0,this.root={cube:e,rotation:void 0,parent:void 0}}abort(){this.aborted=!0}async findSolution(){return new Promise((e,s)=>{for(this.measurer.start();!this.aborted;){const t=this.beginSearch(this.root,0);if(t)return this.measurer.finish(),e(this.createSolution(t));this.iterations.push({visitedNodes:this.visitedNodes,bound:this.currentMaxDepth}),this.visitedNodes=0,++this.currentMaxDepth}s(Error("Aborted"))})}beginSearch(e,s){if(++this.visitedNodes,!this.aborted){if(e.cube.isSolved())return e;if(s<this.currentMaxDepth){const t=this.applyRotations(e);for(let o of t){const n=this.beginSearch(o,s+1);if(n)return n}}}}createActions(){const e=[];return[Sides.FRONT,Sides.UP,Sides.RIGHT].map(s=>[!0,!1].map(t=>{e.push({side:s,counterClockwiseDirection:t,layer:0})})),e}createSolution(e){const s=[];let t=e;for(;t&&t.rotation;)s.unshift(t.rotation),t=t.parent;return{rotations:s,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:Metrics$3[8]}),visitedNodes:this.iterations.reduce((o,n)=>o+n.visitedNodes,0),iterations:this.iterations}}}applyRotations(e){const s=[];return this.actions.forEach(t=>{if(e.rotation&&(rotationsCancel(e.rotation,t)||e.parent&&e.parent.rotation&&rotationsAreEqual(e.rotation,t)&&rotationsAreEqual(e.parent.rotation,t)))return;const o=this.measurer.add(Metrics$3[7],()=>e.cube.rotateFace(t));this.measurer.add(Metrics$3[0],()=>{s.push({cube:o,rotation:t,parent:e})})}),s}}let SimulatedAnnealing$1=class{constructor(e){a(this,"maxSuccessPerIteration",SimulatedAnnealingConfig.maxSuccessPerIteration);a(this,"temperatureDecreaseRate",SimulatedAnnealingConfig.temperatureDecreaseRate);a(this,"numOfRotations",SimulatedAnnealingConfig.numOfRotations);a(this,"population",SimulatedAnnealingConfig.population);a(this,"numOfActions");a(this,"temperature",SimulatedAnnealingConfig.initialTemperature);a(this,"lastResult");a(this,"successCounter",0);a(this,"iterationCounter",0);this.numOfActions=e}iterate(e){if(++this.iterationCounter,!e)return this.createNewPopulationFromScratch();const s=e.sort((o,n)=>n.score-o.score)[0];return this.lastResult?s.score-this.lastResult.score>0?(++this.successCounter,this.successCounter>this.maxSuccessPerIteration&&this.adjustTemperature(),this.disturbCandidate(s)):this.disturbCandidate(this.lastResult):this.disturbCandidate(s)}getIterationCounter(){return this.iterationCounter}createNewPopulationFromScratch(){return Array.from(new Array(this.population)).map(()=>({actions:Array.from(new Array(this.numOfRotations)).map((e,s,t)=>this.createAction(t[s-1])),score:NaN}))}disturbCandidate(e){return this.lastResult=e,Array.from(Array(this.population-1)).map(()=>({actions:e.actions.map((t,o,n)=>Math.random()<this.temperature?this.createAction(n[o-1]):t),score:NaN})).concat(e)}createAction(e){let s,t;do{s=Math.floor(Math.random()*this.numOfActions);const o=s-e;t=s%2===0?o===1:o===-1}while(t);return s}adjustTemperature(){this.temperature*=this.temperatureDecreaseRate,this.successCounter=0}};var Metrics$2=(r=>(r[r.NOT_MEASURED=0]="NOT_MEASURED",r[r.RUN_CANDIDATE_ROTATIONS=1]="RUN_CANDIDATE_ROTATIONS",r[r.CALCULATE_CANDIDATE_SCORE=2]="CALCULATE_CANDIDATE_SCORE",r[r.APPLY_ROTATIONS_TO_CUBE=3]="APPLY_ROTATIONS_TO_CUBE",r[r.CREATE_NEXT_GENERATION=4]="CREATE_NEXT_GENERATION",r[r.ADD_ROTATION_TO_SOLUTION_CANDIDATE=5]="ADD_ROTATION_TO_SOLUTION_CANDIDATE",r[r.AGGREGATE_CURRENT_GENERATION=6]="AGGREGATE_CURRENT_GENERATION",r[r.CHECK_SOLUTION=7]="CHECK_SOLUTION",r[r.MEASUREMENT_OVERHEAD=8]="MEASUREMENT_OVERHEAD",r))(Metrics$2||{});let SimulatedAnnealingSolver$1=class{constructor(e){a(this,"measurer");a(this,"initialState");a(this,"goalStateHash");a(this,"simulatedAnnealing");a(this,"candidates");a(this,"aborted");a(this,"actions");a(this,"restartCounter",0);a(this,"iterations",0);this.measurer=new ProcedureMeasurer,this.initialState=e.clone(),this.aborted=!1,this.actions=[];const s=e.getCubeletsBySides(Sides.BACK,Sides.LEFT,Sides.DOWN)[0],t=this.buildSolvedPocketCubeFromCornerCubelet(s);this.goalStateHash=t.getHash(),[Sides.FRONT,Sides.UP,Sides.RIGHT].map(o=>[!0,!1].map(n=>{this.actions.push({side:o,counterClockwiseDirection:n,layer:0})})),this.simulatedAnnealing=new SimulatedAnnealing$1(this.actions.length),this.candidates=this.simulatedAnnealing.iterate()}async findSolution(){return this.measurer.start(),new Promise((e,s)=>{for(;;){if(++this.iterations,this.aborted)return s();this.simulatedAnnealing.getIterationCounter()>SimulatedAnnealingConfig.restartThreshold&&(++this.restartCounter,console.log("Restart: "+this.restartCounter),this.simulatedAnnealing=new SimulatedAnnealing$1(this.actions.length),this.candidates=this.simulatedAnnealing.iterate());const t=[];for(let o of this.candidates){const n=this.runCitizen(o);if(n.score===this.goalStateHash.length)return e(this.createSolution(n));this.measurer.add(Metrics$2[6],()=>t.push(n))}this.candidates=this.measurer.add(Metrics$2[4],()=>this.simulatedAnnealing.iterate(t))}})}abort(){this.aborted=!0}runCitizen(e){let s=this.initialState.clone();return e.actions.reduce((t,o)=>(this.measurer.add(Metrics$2[7],()=>t.score===this.goalStateHash.length)||(s=this.measurer.add(Metrics$2[3],()=>s.rotateFace(this.actions[o])),this.measurer.add(Metrics$2[5],()=>t.actions.push(o)),t.score=this.measurer.add(Metrics$2[2],()=>this.calculateCandidateScore(s))),t),{score:0,actions:[]})}calculateCandidateScore(e){return e.getConfiguration().split("").filter((t,o)=>t===this.goalStateHash[o]).length}createSolution(e){const s=new RotationsTuner().tune(e.actions.map(t=>this.actions[t]));return this.measurer.finish(),{rotations:s,totalTime:this.measurer.getTotalTime(),data:{restartCounter:this.restartCounter,iterations:this.iterations,metrics:this.measurer.getData({notMeasuredLabel:Metrics$2[0],measurementOverheadLabel:Metrics$2[8]})}}}buildSolvedPocketCubeFromCornerCubelet(e){const s=new Map;return e.stickers.forEach(t=>{s.set(t.side,t.color),s.set(getOppositeSide(t.side),getOppositeColor(t.color))}),new RubiksCube({colorMap:s,dimension:this.initialState.getDimension()})}};class SimulatedAnnealing{constructor(e){a(this,"temperatureDecreaseRate",.85);a(this,"numOfActions");a(this,"temperature",.345);a(this,"currentBest");a(this,"iterationCounter",0);this.numOfActions=e,this.currentBest={actions:[],score:-1/0}}iterate(e){++this.iterationCounter,e||(e=this.currentBest),this.iterationCounter%5e4===0&&this.adjustTemperature();const s=e.score-this.currentBest.score;if(s>0)this.updateTheBest(e);else if(s<0){const t=Number(Math.random().toFixed(5))*Math.abs(s*s*s);t<this.temperature&&(console.log(this.iterationCounter,this.temperature,s,t),this.updateTheBest(e),this.adjustTemperature())}return this.disturbCandidate()}getIterationCounter(){return this.iterationCounter}updateTheBest(e){this.currentBest=e,console.log(this.currentBest)}disturbCandidate(){return{actions:this.currentBest.actions.concat(this.createAction(this.currentBest.actions[this.currentBest.actions.length-1])),score:NaN}}createAction(e){let s,t;do s=Math.floor(Math.random()*this.numOfActions),t=Math.abs(s-e)<2;while(t);return s}adjustTemperature(){this.temperature=Number((this.temperature*this.temperatureDecreaseRate).toFixed(5))}}var srcExports={},src={get exports(){return srcExports},set exports(r){srcExports=r}};(function(module){var colorList={reset:[0,0],bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],inverse:[7,27],hidden:[8,28],strikethrough:[9,29],black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],gray:[90,39],grey:[90,39],redBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39],bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],blackBG:[40,49],redBG:[41,49],greenBG:[42,49],yellowBG:[43,49],blueBG:[44,49],magentaBG:[45,49],cyanBG:[46,49],whiteBG:[47,49],bgBlackBright:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]};if(typeof process>"u"||!process.env)var process={env:{},argv:["--color"]};var isDisabled={}.NO_COLOR||process.argv.includes("--no-color"),isSupported=!isDisabled&&({}.FORCE_COLOR||process.platform==="win32"||process.argv.includes("--color")||eval("require('tty')").isatty(1)&&{}.TERM!=="dumb"||{}.CI),TObject=typeof Reflect>"u"?Object:Reflect,fncache={};function extend(r,e){var s=e.join("");return Object.keys(colorList).forEach(function(t){var o=s+t;TObject.defineProperty(r,t,{get(){return fncache[o]||(fncache[o]=extend(function(l){return r(color[t](l))},e.concat(t))),fncache[o]}})}),r}function replaceClose(r,e,s,t){var o=r.substring(t+s.length),n=o.indexOf(s);return r.substring(0,t)+e+(~n?replaceClose(o,e,s,n):o)}function getFn(r){var e=colorList[r];if(!e||!isSupported)return function(o){return String(o)};var s=e[0],t=e[1];return function(o){if(o===""||o==null)return"";o=""+o;var n=o.indexOf(t,s.length);return s+(n>-1&&n<o.length-1?replaceClose(o,s,t,n):o)+t}}function color(r,e){return getFn(e)(r)}color.list=colorList;function init(){Object.keys(colorList).forEach(function(r){clc[r]=color[r]=extend(getFn(r),[r])})}for(var clc={color,list:colorList,log(r,e){console.log(color(r,e))},isSupported(){return isSupported},enable(){isSupported=!0,init()},disable(){isSupported=!1,init()},strip(r){return r.replace(/\x1b\[\d+m/gm,"")}},i=0;i<256;i++)colorList["c"+i]=["38;5;"+i,0],colorList["bg"+i]=["48;5;"+i,0];Object.keys(colorList).forEach(function(r){colorList[r]=colorList[r].map(function(e){return"\x1B["+e+"m"}),clc.log[r]=function(){for(var e=[],s=0;s<arguments.length;s++)e.push(arguments[s]);console.log(color[r](e.join(" ")))}}),init(),module.exports=clc})(src);var clc=srcExports;const{log,color,list,isSupported,disable,enable,strip,reset,bold,dim,italic,underline,inverse,hidden,strikethrough,black,red,green,yellow,blue,magenta,cyan,white,gray,grey,redBright,greenBright,yellowBright,blueBright,magentaBright,cyanBright,whiteBright,bgBlack,bgRed,bgGreen,bgYellow,bgBlue,bgMagenta,bgCyan,bgWhite,blackBG,redBG,greenBG,yellowBG,blueBG,magentaBG,cyanBG,whiteBG,bgBlackBright,bgRedBright,bgGreenBright,bgYellowBright,bgBlueBright,bgMagentaBright,bgCyanBright,bgWhiteBright}=clc;class HumanTranslator{translateSide(e,s){const t=s.getAllCubelets(),o=s.getDimension(),n=10,l=(f,S,T)=>{for(const g of t){const D=g.stickers.find(O=>O.side===f&&O.x===S&&O.y===T);if(D)return D}console.log(`Sticker not found: ${Sides[f]}, ${S}, ${T}`)},m=[];m.push(`${(Sides[e]+Array.from(new Array(n)).fill(" ").join("")).substring(0,n)}`);for(let f=0;f<o;++f){let S="";for(let T=0;T<o;++T){const g=l(e,T,f),D=Colors[g.color].substring(0,1)+HumanTranslator.mapToSubscript(`${("  "+g.id).slice(-2)}  `);let O=Colors[g.color].toLowerCase();O==="white"&&(O="gray"),O==="orange"&&(O="redBright");const v=color[O](D);S+=v}m.push(S)}return m}printCube(e){const s=e.getDimension(),t=this.translateSide(Sides.UP,e),o=this.translateSide(Sides.LEFT,e),n=this.translateSide(Sides.FRONT,e),l=this.translateSide(Sides.RIGHT,e),m=this.translateSide(Sides.BACK,e),f=this.translateSide(Sides.DOWN,e);let S="";const T=Array.from(new Array(t[1].length/3)).fill(" ").join("");t.forEach(g=>{S+=T+g+`
`}),S+=o[0],S+=(T+n[0]).slice(-T.length),S+=(T+l[0]).slice(-T.length),S+=(T+m[0]).slice(-T.length)+`
`;for(let g=1;g<s+1;++g)S+=o[g],S+=n[g],S+=l[g],S+=m[g]+`
`;f.forEach(g=>{S+=T+g+`
`}),console.log(S)}convertStringToFaceRotations(e){return e.length===0?[]:e.match(/((\d?)(\w)(\d?)('?))\s*/g).reduce((s,t)=>{const[o,n,l,m,f]=t.match(/(\d?)(\w)(\d?)('?)\s*/),S={side:Sides.UP,counterClockwiseDirection:(f==null?void 0:f.length)>0,layer:Number((m==null?void 0:m.length)>0)};switch(l.toLowerCase()){case"u":S.side=Sides.UP;break;case"l":S.side=Sides.LEFT;break;case"f":S.side=Sides.FRONT;break;case"r":S.side=Sides.RIGHT;break;case"b":S.side=Sides.BACK;break;case"d":S.side=Sides.DOWN;break;default:return s}return(n==null?void 0:n.length)>0?s.push([S,S]):s.push([S]),s},[])}translateRotations(e,s){const t=[...e];let o=0,n="";s!=null&&s.showNumberOfMoves&&(o++,n+=`${e.length}:      `.substring(0,4));let l=t.shift();for(;l;){const m=t[0];let f=" ";m&&rotationsAreEqual(m,l)&&(t.shift(),f="2");let S="";if(s&&s.showLayer){let g=1;l.layer!==void 0&&(g=l.layer+1),S=g.toString(),s.subscript&&(S=HumanTranslator.mapToSubscript(g.toString()))}const T=l.counterClockwiseDirection;n+=`${f}${Sides[l.side].substring(0,1)}${T?"'":" "}${S}  `,(s==null?void 0:s.lineBreak)!==void 0&&o%(s==null?void 0:s.lineBreak)===(s==null?void 0:s.lineBreak)-1&&(n+=`
`),++o,l=t.shift()}return n}translateCubelets(e){let s="";return e.map(t=>{t.stickers.map(o=>{const n=Colors[o.color],l=Sides[o.side],m=HumanTranslator.mapToSmallTopLetters(o.id.toString()),f=`${HumanTranslator.mapToSubscript("("+o.x+","+o.y+")")}`;s+=`${n.substring(0,1).toUpperCase().concat(n.substring(1).toLowerCase())}: ${l}${m}${f};  `}),s+=`
`}),s}static mapToSmallTopLetters(e){const s=new Map;return s.set("0","⁰"),s.set("1","¹"),s.set("2","²"),s.set("3","³"),s.set("4","⁴"),s.set("5","⁵"),s.set("6","⁶"),s.set("7","⁷"),s.set("8","⁸"),s.set("9","⁹"),s.set(",","﹐"),e.split("").map(t=>s.has(t)?s.get(t):t).join("")}static mapToSubscript(e){const s=new Map;return s.set("0","₀"),s.set("1","₁"),s.set("2","₂"),s.set("3","₃"),s.set("4","₄"),s.set("5","₅"),s.set("6","₆"),s.set("7","₇"),s.set("8","₈"),s.set("9","₉"),s.set("0","₀"),s.set("(","₍"),s.set(")","₎"),e.split("").map(t=>s.has(t)?s.get(t):t).join("")}}var Metrics$1=(r=>(r[r.NOT_MEASURED=0]="NOT_MEASURED",r[r.RUN_CANDIDATE_ROTATIONS=1]="RUN_CANDIDATE_ROTATIONS",r[r.CALCULATE_CANDIDATE_SCORE=2]="CALCULATE_CANDIDATE_SCORE",r[r.APPLY_ROTATIONS_TO_CUBE=3]="APPLY_ROTATIONS_TO_CUBE",r[r.CREATE_NEXT_GENERATION=4]="CREATE_NEXT_GENERATION",r[r.ADD_ROTATION_TO_SOLUTION_CANDIDATE=5]="ADD_ROTATION_TO_SOLUTION_CANDIDATE",r[r.AGGREGATE_CURRENT_GENERATION=6]="AGGREGATE_CURRENT_GENERATION",r[r.CHECK_SOLUTION=7]="CHECK_SOLUTION",r[r.MEASUREMENT_OVERHEAD=8]="MEASUREMENT_OVERHEAD",r))(Metrics$1||{});class SimulatedAnnealingSolver{constructor(e){a(this,"measurer");a(this,"initialState");a(this,"goalStateHash");a(this,"simulatedAnnealing");a(this,"candidate");a(this,"aborted");a(this,"actions");a(this,"restartCounter",0);a(this,"iterations",0);this.measurer=new ProcedureMeasurer,this.initialState=e.clone(),this.aborted=!1,this.actions=[];const s=this.buildSolvedCubeFromCenterCubelets(e);this.goalStateHash=s.getHash();const t=new HumanTranslator;getAllSides().forEach(o=>{[!0,!1].forEach(l=>{const m={side:o,counterClockwiseDirection:l,layer:0};this.actions.push({rotate:f=>f.rotateFace(m),char:t.translateRotations([m])})});const n={side:o,counterClockwiseDirection:!1,layer:0};this.actions.push({rotate:l=>l.rotateFace(n).rotateFace(n),char:t.translateRotations([n,n])})}),this.simulatedAnnealing=new SimulatedAnnealing(this.actions.length),this.candidate=this.simulatedAnnealing.iterate()}async findSolution(){return this.measurer.start(),new Promise((e,s)=>{for(;;){if(++this.iterations,this.aborted)return s();this.simulatedAnnealing.getIterationCounter()>5e5&&(++this.restartCounter,console.log("Restart: "+this.restartCounter),this.simulatedAnnealing=new SimulatedAnnealing(this.actions.length),this.candidate=this.simulatedAnnealing.iterate());const t=this.runCitizen(this.candidate);if(t.score===this.goalStateHash.length)return e(this.createSolution(t));this.candidate=this.measurer.add(Metrics$1[4],()=>this.simulatedAnnealing.iterate(t))}})}abort(){this.aborted=!0}runCitizen(e){let s=this.initialState.clone();return e.actions.reduce((t,o)=>{if(this.measurer.add(Metrics$1[7],()=>t.score===this.goalStateHash.length))return t;{s=this.measurer.add(Metrics$1[3],()=>this.actions[o](s));const n=this.measurer.add(Metrics$1[2],()=>this.calculateCandidateScore(s));this.measurer.add(Metrics$1[5],()=>t.actions.push(o)),t.score=n}return t},{score:0,actions:[]})}calculateCandidateScore(e){return e.getConfiguration().split("").filter((t,o)=>t===this.goalStateHash[o]).length}createSolution(e){const s=new RotationsTuner().tune(e.actions.map(t=>this.actions[t](c)));return this.measurer.finish(),{rotations:s,totalTime:this.measurer.getTotalTime(),data:{restartCounter:this.restartCounter,iterations:this.iterations,metrics:this.measurer.getData({notMeasuredLabel:Metrics$1[0],measurementOverheadLabel:Metrics$1[8]})}}}buildSolvedCubeFromCenterCubelets(e){const s=new Map;return e.getAllCubelets().filter(t=>t.stickers.length===1).forEach(t=>s.set(t.stickers[0].side,t.stickers[0].color)),new RubiksCube({colorMap:s,dimension:this.initialState.getDimension()})}}var heapExports$1={},heap$1={get exports(){return heapExports$1},set exports(r){heapExports$1=r}},heapExports={},heap={get exports(){return heapExports},set exports(r){heapExports=r}};(function(r,e){(function(){var s,t,o,n,l,m,f,S,T,g,D,O,v,y,w;o=Math.floor,g=Math.min,t=function(u,d){return u<d?-1:u>d?1:0},T=function(u,d,h,p,b){var C;if(h==null&&(h=0),b==null&&(b=t),h<0)throw new Error("lo must be non-negative");for(p==null&&(p=u.length);h<p;)C=o((h+p)/2),b(d,u[C])<0?p=C:h=C+1;return[].splice.apply(u,[h,h-h].concat(d)),d},m=function(u,d,h){return h==null&&(h=t),u.push(d),y(u,0,u.length-1,h)},l=function(u,d){var h,p;return d==null&&(d=t),h=u.pop(),u.length?(p=u[0],u[0]=h,w(u,0,d)):p=h,p},S=function(u,d,h){var p;return h==null&&(h=t),p=u[0],u[0]=d,w(u,0,h),p},f=function(u,d,h){var p;return h==null&&(h=t),u.length&&h(u[0],d)<0&&(p=[u[0],d],d=p[0],u[0]=p[1],w(u,0,h)),d},n=function(u,d){var h,p,b,C,E,A;for(d==null&&(d=t),C=function(){A=[];for(var I=0,_=o(u.length/2);0<=_?I<_:I>_;0<=_?I++:I--)A.push(I);return A}.apply(this).reverse(),E=[],p=0,b=C.length;p<b;p++)h=C[p],E.push(w(u,h,d));return E},v=function(u,d,h){var p;if(h==null&&(h=t),p=u.indexOf(d),p!==-1)return y(u,0,p,h),w(u,p,h)},D=function(u,d,h){var p,b,C,E,A;if(h==null&&(h=t),b=u.slice(0,d),!b.length)return b;for(n(b,h),A=u.slice(d),C=0,E=A.length;C<E;C++)p=A[C],f(b,p,h);return b.sort(h).reverse()},O=function(u,d,h){var p,b,C,E,A,I,_,x,L;if(h==null&&(h=t),d*10<=u.length){if(C=u.slice(0,d).sort(h),!C.length)return C;for(b=C[C.length-1],_=u.slice(d),E=0,I=_.length;E<I;E++)p=_[E],h(p,b)<0&&(T(C,p,0,null,h),C.pop(),b=C[C.length-1]);return C}for(n(u,h),L=[],A=0,x=g(d,u.length);0<=x?A<x:A>x;0<=x?++A:--A)L.push(l(u,h));return L},y=function(u,d,h,p){var b,C,E;for(p==null&&(p=t),b=u[h];h>d;){if(E=h-1>>1,C=u[E],p(b,C)<0){u[h]=C,h=E;continue}break}return u[h]=b},w=function(u,d,h){var p,b,C,E,A;for(h==null&&(h=t),b=u.length,A=d,C=u[d],p=2*d+1;p<b;)E=p+1,E<b&&!(h(u[p],u[E])<0)&&(p=E),u[d]=u[p],d=p,p=2*d+1;return u[d]=C,y(u,A,d,h)},s=function(){u.push=m,u.pop=l,u.replace=S,u.pushpop=f,u.heapify=n,u.updateItem=v,u.nlargest=D,u.nsmallest=O;function u(d){this.cmp=d??t,this.nodes=[]}return u.prototype.push=function(d){return m(this.nodes,d,this.cmp)},u.prototype.pop=function(){return l(this.nodes,this.cmp)},u.prototype.peek=function(){return this.nodes[0]},u.prototype.contains=function(d){return this.nodes.indexOf(d)!==-1},u.prototype.replace=function(d){return S(this.nodes,d,this.cmp)},u.prototype.pushpop=function(d){return f(this.nodes,d,this.cmp)},u.prototype.heapify=function(){return n(this.nodes,this.cmp)},u.prototype.updateItem=function(d){return v(this.nodes,d,this.cmp)},u.prototype.clear=function(){return this.nodes=[]},u.prototype.empty=function(){return this.nodes.length===0},u.prototype.size=function(){return this.nodes.length},u.prototype.clone=function(){var d;return d=new u,d.nodes=this.nodes.slice(0),d},u.prototype.toArray=function(){return this.nodes.slice(0)},u.prototype.insert=u.prototype.push,u.prototype.top=u.prototype.peek,u.prototype.front=u.prototype.peek,u.prototype.has=u.prototype.contains,u.prototype.copy=u.prototype.clone,u}(),function(u,d){return r.exports=d()}(this,function(){return s})}).call(commonjsGlobal)})(heap),function(r){r.exports=heapExports}(heap$1);var Heap=getDefaultExportFromCjs(heapExports$1),Metrics=(r=>(r[r.ADD_CANDIDATE=0]="ADD_CANDIDATE",r[r.POP_CANDIDATE=1]="POP_CANDIDATE",r[r.CHECK_SOLUTION=2]="CHECK_SOLUTION",r[r.BREATHING_TIME=3]="BREATHING_TIME",r[r.HASH_CALCULATION=4]="HASH_CALCULATION",r[r.VISISTED_LIST_CHECK=5]="VISISTED_LIST_CHECK",r[r.ADD_TO_VISISTED_LIST_CHECK=6]="ADD_TO_VISISTED_LIST_CHECK",r[r.PERFORM_ROTATION=7]="PERFORM_ROTATION",r[r.NOT_MEASURED=8]="NOT_MEASURED",r[r.HEURISTIC_CALCULATION=9]="HEURISTIC_CALCULATION",r[r.GET_ALL_CUBELETS=10]="GET_ALL_CUBELETS",r[r.CUBELET_FINAL_POSITION=11]="CUBELET_FINAL_POSITION",r[r.CUBELET_SIMILARITY=12]="CUBELET_SIMILARITY",r[r.ITERATION=13]="ITERATION",r[r.SOLUTION_CREATION=14]="SOLUTION_CREATION",r[r.MEASUREMENT_OVERHEAD=15]="MEASUREMENT_OVERHEAD",r[r.ITERATIONS_COUNTER_INCREMENT=16]="ITERATIONS_COUNTER_INCREMENT",r[r.ABORTED_VERIFICATION=17]="ABORTED_VERIFICATION",r[r.BUILD_SOLUTION=18]="BUILD_SOLUTION",r))(Metrics||{});class WeightedAStarSolver{constructor(e){a(this,"measurer");a(this,"candidates");a(this,"visitedChecklist");a(this,"actions");a(this,"dimension");a(this,"goalStateHash");a(this,"aborted");this.aborted=!1,this.dimension=e.getDimension(),this.candidates=new Heap((n,l)=>n.cost+WeightedAStarAlgorithmConfig.heuristicWeight*n.heuristicValue-(l.cost+WeightedAStarAlgorithmConfig.heuristicWeight*l.heuristicValue)),this.visitedChecklist=new Map;const s={cost:0,heuristicValue:0,cube:e,rotation:void 0,parent:void 0};this.candidates.push(s),this.actions=[];const t=e.getCubeletsBySides(Sides.BACK,Sides.LEFT,Sides.DOWN)[0],o=this.buildSolvedPocketCubeFromCornerCubelet(t);this.goalStateHash=o.getHash(),[Sides.FRONT,Sides.UP,Sides.RIGHT].map(n=>[!0,!1].map(l=>{this.actions.push({side:n,counterClockwiseDirection:l,layer:0})})),this.measurer=new ProcedureMeasurer}async findSolution(){return new Promise((e,s)=>{this.measurer.start();let t,o=0,n=0;for(;this.measurer.add(Metrics[16],()=>this.candidates.size()>0);){if(this.measurer.add(Metrics[17],()=>this.aborted))return s();if(this.measurer.add(Metrics[16],()=>++o),t=this.measurer.add(Metrics[1],()=>this.candidates.pop()),!this.measurer.add(Metrics[5],()=>this.visitedChecklist.has(t.cube.getHash()))){if(++n,this.measurer.add(Metrics[2],()=>t.cube.getHash()===this.goalStateHash))return e(this.measurer.add(Metrics[14],()=>this.createSolution(t,o,n)));this.measurer.add(Metrics[6],()=>this.visitedChecklist.set(t.cube.getHash(),t)),this.applyRotations(t)}}s(Error("No more candidates to explore"))})}abort(){this.aborted=!0}createSolution(e,s,t){const o=[];let n=e;return this.measurer.add(Metrics[18],()=>{for(;n&&n.rotation;)o.unshift(n.rotation),n=n.parent}),this.measurer.finish(),this.candidates.clear(),{rotations:o,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:Metrics[8],measurementOverheadLabel:Metrics[15]}),visitedNodes:s,differentNodes:t}}}applyRotations(e){for(let s of this.actions){if(e.rotation&&(rotationsCancel(e.rotation,s)||e.parent&&e.parent.rotation&&rotationsAreEqual(e.rotation,s)&&rotationsAreEqual(e.parent.rotation,s)))continue;const t=this.measurer.add(Metrics[7],()=>e.cube.rotateFace(s)),o=t.getHash(),n=this.measurer.add(Metrics[9],()=>this.calculateDistanceToFinalState(t)),l={cost:e.cost+1,cube:t,rotation:s,heuristicValue:n,parent:e};this.measurer.add(Metrics[5],()=>this.visitedChecklist.get(o))||this.measurer.add(Metrics[0],()=>{this.candidates.push(l)})}}calculateDistanceToFinalState(e){const s=this.dimension*4;return e.getConfiguration().split("").filter((o,n)=>o!==this.goalStateHash[n]).length/s}buildSolvedPocketCubeFromCornerCubelet(e){const s=new Map;return e.stickers.forEach(t=>{s.set(t.side,t.color),s.set(getOppositeSide(t.side),getOppositeColor(t.color))}),new RubiksCube({colorMap:s,dimension:this.dimension})}}class KeyboardInterpreter{readKeys(e,s){let t;switch(e.key.toLowerCase()){case"w":t=Sides.UP;break;case"a":t=Sides.LEFT;break;case"s":t=Sides.FRONT;break;case"d":t=Sides.RIGHT;break;case"f":t=Sides.BACK;break;case"x":t=Sides.DOWN;break}if(t!==void 0)return{side:t,counterClockwiseDirection:e.shiftKey,layer:s}}}class HumanSolver{constructor(e){a(this,"moves");a(this,"findSolutionResolve");a(this,"findSolutionReject");a(this,"cube");a(this,"startTime");a(this,"keyboardInterpreter");this.cube=e,this.moves=[],this.keyboardInterpreter=new KeyboardInterpreter}async findSolution(){return this.startTime=Date.now(),new Promise((e,s)=>{this.findSolutionResolve=e,this.findSolutionReject=s})}abort(){this.findSolutionReject()}async readKeys(e){if(this.cube.isSolved())return;const s=this.keyboardInterpreter.readKeys(e);if(s!==void 0)return this.moves.push(s),this.cube=this.cube.rotateFace(s),this.cube.isSolved()&&this.findSolutionResolve({rotations:this.moves,totalTime:Date.now()-this.startTime,data:{human:!0}}),s}}const WeightedAStarAlgorithmConfig={heuristicWeight:50},GeneticAlgorithmConfig={mutationRate:.25,populationPerGeneration:100,maxNumOfRotations:30,elitism:15,armageddonThreshold:4e3},SimulatedAnnealingConfig={population:100,initialTemperature:.5,temperatureDecreaseRate:.95,numOfRotations:30,maxSuccessPerIteration:10,restartThreshold:4e3},Configuration={metrics:{enabled:!0,generateReport:!1},world:{debug:!1,scrambleMoves:()=>Math.floor(Math.random()*10+30),scrambleRotationDuration:80,cubesCircleRay:5,camera:{closeDistance:20,farDistance:60}},renderers:{translationDuration:500,rotationDuration:250,titleDistance:8.5,cubeSize:2.5},initiallySelectedCubeTypeIndex:0,cubeTypes:[{label:"2x2",dimension:2,instantiator:()=>new RubiksCube({dimension:2}),methods:[{key:"Human",instantiator:r=>new HumanSolver(new RubiksCube({clone:r})),checked:!1,human:!0,info:"Use keys 'WASDFX' combined with 'shift' to rotate cube faces"},{key:"IDDFS",instantiator:r=>new InterativeDeepeningDepthFirstSearchSolver(new RubiksCube({clone:r})),checked:!1,info:"Interative-deepening depth-first-search. Brute force"},{key:"IDA*",instantiator:r=>new InterativeDeepeningAStarSolver(new RubiksCube({clone:r})),checked:!1,info:"Interative-deepening A star. Uses number of misplaced stickers as heuristic."},{key:"SA",instantiator:r=>new SimulatedAnnealingSolver$1(new RubiksCube({clone:r})),checked:!0,info:`Random movements improved by simulated annealing algorithm. Uses number of misplaced stickers as a measure of a solution candidate result. Population: ${SimulatedAnnealingConfig.population}. Initial temperature: ${SimulatedAnnealingConfig.initialTemperature}. Temperature decrease rate: ${SimulatedAnnealingConfig.temperatureDecreaseRate}`},{key:"GA",instantiator:r=>new GeneticAlgorithmSolver(new RubiksCube({clone:r})),checked:!0,info:`Random movements improved by genetic algorithm. Uses number of misplaced stickers as fitness function. Population: ${GeneticAlgorithmConfig.populationPerGeneration}. Elitism ${GeneticAlgorithmConfig.elitism}.  Mutation rate ${GeneticAlgorithmConfig.mutationRate}. `},{key:"WA*",instantiator:r=>new WeightedAStarSolver(new RubiksCube({clone:r})),checked:!0,info:`Weighted A star. No re-expansions. Uses number of misplaced stickers as heuristic and weights the heuristic (${WeightedAStarAlgorithmConfig.heuristicWeight} * h(x)) value.`},{key:"BiBFS",instantiator:r=>new BidirectionalBreadthFirstSearchSolver(new RubiksCube({clone:r})),checked:!0,info:"Bidirectional breadth-first-search. Brute force."}]},{label:"3x3",dimension:3,instantiator:()=>new RubiksCube({dimension:3}),methods:[{key:"Human",instantiator:r=>new HumanSolver(new RubiksCube({clone:r})),checked:!0,human:!0,info:"Use keys 'WASDFX' combined with 'shift' to rotate cube faces"},{key:"SA",instantiator:r=>new SimulatedAnnealingSolver(new RubiksCube({clone:r})),checked:!0,info:`Random movements improved by simulated annealing algorithm. Uses number of misplaced stickers as a measure of a solution candidate result. Population: ${SimulatedAnnealingConfig.population}. Initial temperature: ${SimulatedAnnealingConfig.initialTemperature}. Temperature decrease rate: ${SimulatedAnnealingConfig.temperatureDecreaseRate}`}]},{label:"4x4",dimension:4,instantiator:()=>new RubiksCube({dimension:4}),methods:[{key:"Human",instantiator:r=>new HumanSolver(new RubiksCube({clone:r})),checked:!0,human:!0,info:"Use keys 'WASDFX' combined with 'shift' and numbers to rotate cube faces"}]},{label:"5x5",dimension:5,instantiator:()=>new RubiksCube({dimension:5}),methods:[{key:"Human",instantiator:r=>new HumanSolver(new RubiksCube({clone:r})),checked:!0,human:!0,info:"Use keys 'WASDFX' combined with 'shift' and numbers to rotate cube faces"}]},{label:"6x6",dimension:6,instantiator:()=>new RubiksCube({dimension:6}),methods:[{key:"Human",instantiator:r=>new HumanSolver(new RubiksCube({clone:r})),checked:!0,human:!0,info:"Use keys 'WASDFX' combined with 'shift' and numbers to rotate cube faces"}]},{label:"7x7",dimension:7,instantiator:()=>new RubiksCube({dimension:7}),methods:[{key:"Human",instantiator:r=>new HumanSolver(new RubiksCube({clone:r})),checked:!0,human:!0,info:"Use keys 'WASDFX' combined with 'shift' and numbers to rotate cube faces"}]}]},solverMethodFinder=r=>{for(let e of Configuration.cubeTypes)if(e.label.toLowerCase()===r.label.toLowerCase()){for(let s of e.methods)if(s.key.toLowerCase()===r.solverTag.toLowerCase())return s;return}};let solver;self.onmessage=async r=>{if(r.data.abort)solver.abort();else{const e=r.data.solverTag.toLowerCase(),s=solverMethodFinder(r.data);if(e&&s)if(r.data.cube)try{solver=s.instantiator(r.data.cube);const t=await solver.findSolution();self.postMessage({solution:JSON.stringify(t),solverKey:e})}catch(t){console.log(`Solver '${r.data.label}.${e}' aborted`,t),self.postMessage({error:`Solver '${r.data.label}.${e}' aborted`,solverTag:r.data.solverTag})}else if(r.data.keyboardEvent){if(solver instanceof HumanSolver){const t=await solver.readKeys(r.data.keyboardEvent);t!==void 0&&self.postMessage({faceRotation:t,solverKey:e})}}else self.postMessage({error:`Command for '${r.data}' not found`,solverTag:r.data.solverTag});else self.postMessage({error:`Solver '${r.data.solverTag}' not found`,solverTag:r.data.solverTag})}}})();
