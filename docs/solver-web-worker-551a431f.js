var x=Object.defineProperty;var k=(N,R,r)=>R in N?x(N,R,{enumerable:!0,configurable:!0,writable:!0,value:r}):N[R]=r;var l=(N,R,r)=>(k(N,typeof R!="symbol"?R+"":R,r),r);(function(){"use strict";var Sides=(r=>(r[r.UP=0]="UP",r[r.LEFT=1]="LEFT",r[r.FRONT=2]="FRONT",r[r.RIGHT=3]="RIGHT",r[r.BACK=4]="BACK",r[r.DOWN=5]="DOWN",r))(Sides||{});const getAllSides=()=>Object.keys(Sides).filter(r=>!isNaN(Number(r))).map(r=>Number(r)),getOppositeSide=r=>{switch(r){case 0:return 5;case 5:return 0;case 1:return 3;case 3:return 1;case 2:return 4;case 4:return 2}};var Colors=(r=>(r[r.YELLOW=0]="YELLOW",r[r.ORANGE=1]="ORANGE",r[r.BLUE=2]="BLUE",r[r.RED=3]="RED",r[r.GREEN=4]="GREEN",r[r.WHITE=5]="WHITE",r))(Colors||{});const getOppositeColor=r=>{switch(r){case 2:return 4;case 4:return 2;case 3:return 1;case 1:return 3;case 0:return 5;case 5:return 0}},colorToStringMap=new Map;colorToStringMap.set(0,"y"),colorToStringMap.set(1,"o"),colorToStringMap.set(2,"b"),colorToStringMap.set(3,"r"),colorToStringMap.set(4,"g"),colorToStringMap.set(5,"w");const mapColorInitialsToString=r=>colorToStringMap.get(r),stringToColorMap=new Map;stringToColorMap.set("y",0),stringToColorMap.set("o",1),stringToColorMap.set("b",2),stringToColorMap.set("r",3),stringToColorMap.set("g",4),stringToColorMap.set("w",5);const mapStringInitialToColor=r=>stringToColorMap.get(r),N=class{constructor(e){l(this,"dimension");l(this,"stickers");this.dimension=e,this.stickers=[]}create(){if(N.cubeletsCreatorMap.has(this.dimension))return N.cubeletsCreatorMap.get(this.dimension);{let e=0;getAllSides().map(u=>{for(let c=0;c<this.dimension;++c)for(let m=0;m<this.dimension;++m)this.stickers.push({side:u,x:m,y:c,id:e++})});const t=this.extractCenters(),s=this.extractCorners(),o=this.extractEdges(),n=[...s,...o,...t];return N.cubeletsCreatorMap.set(this.dimension,n),n}}cubeletsMerger(e){const t={stickers:[]};return e.forEach(s=>{this.stickers.forEach((o,n,u)=>{o.side===s.side&&s.x===o.x&&s.y===o.y&&t.stickers.push(...u.splice(n,1))})}),t}extractEdges(){const e=this.dimension-1,t=[];for(let s=1;s<this.dimension-1;++s)t.push(this.cubeletsMerger([{side:Sides.FRONT,x:0,y:s},{side:Sides.LEFT,x:e,y:s}])),t.push(this.cubeletsMerger([{side:Sides.FRONT,x:e,y:s},{side:Sides.RIGHT,x:0,y:s}])),t.push(this.cubeletsMerger([{side:Sides.FRONT,x:s,y:0},{side:Sides.UP,x:s,y:e}])),t.push(this.cubeletsMerger([{side:Sides.FRONT,x:s,y:e},{side:Sides.DOWN,x:s,y:0}])),t.push(this.cubeletsMerger([{side:Sides.BACK,x:e,y:s},{side:Sides.LEFT,x:0,y:s}])),t.push(this.cubeletsMerger([{side:Sides.BACK,x:0,y:s},{side:Sides.RIGHT,x:e,y:s}])),t.push(this.cubeletsMerger([{side:Sides.BACK,x:s,y:0},{side:Sides.UP,x:e-s,y:0}])),t.push(this.cubeletsMerger([{side:Sides.BACK,x:s,y:e},{side:Sides.DOWN,x:e-s,y:e}])),t.push(this.cubeletsMerger([{side:Sides.RIGHT,x:s,y:0},{side:Sides.UP,x:e,y:e-s}])),t.push(this.cubeletsMerger([{side:Sides.RIGHT,x:s,y:e},{side:Sides.DOWN,x:e,y:s}])),t.push(this.cubeletsMerger([{side:Sides.LEFT,x:s,y:0},{side:Sides.UP,x:0,y:s}])),t.push(this.cubeletsMerger([{side:Sides.LEFT,x:s,y:e},{side:Sides.DOWN,x:0,y:e-s}]));return t}extractCenters(){const e=this.dimension-1,t=[];return this.stickers.filter(s=>s.x!==0&&s.x!==e&&s.y!==0&&s.y!==e).forEach(s=>{t.push({stickers:[s]})}),t}extractCorners(){const e=[],t=this.dimension-1;return e.push(this.cubeletsMerger([{side:Sides.FRONT,x:0,y:0},{side:Sides.UP,x:0,y:t},{side:Sides.LEFT,x:t,y:0}])),e.push(this.cubeletsMerger([{side:Sides.FRONT,x:t,y:0},{side:Sides.UP,x:t,y:t},{side:Sides.RIGHT,x:0,y:0}])),e.push(this.cubeletsMerger([{side:Sides.FRONT,x:0,y:t},{side:Sides.DOWN,x:0,y:0},{side:Sides.LEFT,x:t,y:t}])),e.push(this.cubeletsMerger([{side:Sides.FRONT,x:t,y:t},{side:Sides.DOWN,x:t,y:0},{side:Sides.RIGHT,x:0,y:t}])),e.push(this.cubeletsMerger([{side:Sides.BACK,x:0,y:0},{side:Sides.UP,x:t,y:0},{side:Sides.RIGHT,x:t,y:0}])),e.push(this.cubeletsMerger([{side:Sides.BACK,x:t,y:0},{side:Sides.UP,x:0,y:0},{side:Sides.LEFT,x:0,y:0}])),e.push(this.cubeletsMerger([{side:Sides.BACK,x:0,y:t},{side:Sides.DOWN,x:t,y:t},{side:Sides.RIGHT,x:t,y:t}])),e.push(this.cubeletsMerger([{side:Sides.BACK,x:t,y:t},{side:Sides.DOWN,x:0,y:t},{side:Sides.LEFT,x:0,y:t}])),e}};let CubeletsCreator=N;l(CubeletsCreator,"cubeletsCreatorMap",new Map);const R=class{constructor(e){l(this,"dimension");if(this.dimension=e,!R.faceRotatorMap.has(this.dimension)){const t=new Map;for(let s=0;s<this.dimension;++s){const o=this.createUpFaceClockwiseRotator(s),n=this.createLeftFaceClockwiseRotator(s),u=this.createFrontFaceClockwiseRotator(s),c=this.createRightFaceClockwiseRotator(s),m=this.createBackFaceClockwiseRotator(s),g=this.createDownFaceClockwiseRotator(s),f=new Map;f.set(Sides.UP,o.map(S=>this.faceStickerMapper(S))),f.set(Sides.LEFT,n.map(S=>this.faceStickerMapper(S))),f.set(Sides.FRONT,u.map(S=>this.faceStickerMapper(S))),f.set(Sides.RIGHT,c.map(S=>this.faceStickerMapper(S))),f.set(Sides.BACK,m.map(S=>this.faceStickerMapper(S))),f.set(Sides.DOWN,g.map(S=>this.faceStickerMapper(S))),t.set(s,f)}R.faceRotatorMap.set(this.dimension,t)}}rotate(e,t){const s=new RubiksCube({clone:e.getConfiguration()}),o=[];return R.faceRotatorMap.get(this.dimension).get(t.layer||0).get(t.side).forEach(n=>{t.counterClockwiseDirection?o.push({index:n.source,color:e.getColorOfIndex(n.destination)}):o.push({index:n.destination,color:e.getColorOfIndex(n.source)})}),s.setColorsOfIndexes(o),s}idMapper(e){let t=e.side*this.dimension*this.dimension;return t+=this.dimension*e.y,t+=e.x,t}faceStickerMapper(e){return{source:this.idMapper(e.source),destination:this.idMapper(e.destination)}}createSideLidClockwiseRotator(e){const t=[];for(let s=0;s<this.dimension*this.dimension;++s){const o=s%this.dimension,n=Math.floor(s/this.dimension),u=this.dimension-1-n,c=o;t.push({source:{side:e,x:o,y:n},destination:{side:e,x:u,y:c}})}return t}createUpFaceClockwiseRotator(e){this.dimension-1;const t=[];e===0&&t.push(...this.createSideLidClockwiseRotator(Sides.UP));for(let s=0;s<this.dimension;++s)t.push({source:{side:Sides.FRONT,x:s,y:e},destination:{side:Sides.LEFT,x:s,y:e}}),t.push({source:{side:Sides.LEFT,x:s,y:e},destination:{side:Sides.BACK,x:s,y:e}}),t.push({source:{side:Sides.BACK,x:s,y:e},destination:{side:Sides.RIGHT,x:s,y:e}}),t.push({source:{side:Sides.RIGHT,x:s,y:e},destination:{side:Sides.FRONT,x:s,y:e}});return t}createLeftFaceClockwiseRotator(e){const t=this.dimension-1,s=[];e===0&&s.push(...this.createSideLidClockwiseRotator(Sides.LEFT));for(let o=0;o<this.dimension;++o)s.push({source:{side:Sides.FRONT,x:e,y:o},destination:{side:Sides.DOWN,x:e,y:o}}),s.push({source:{side:Sides.DOWN,x:e,y:o},destination:{side:Sides.BACK,x:t-e,y:t-o}}),s.push({source:{side:Sides.BACK,x:t-e,y:t-o},destination:{side:Sides.UP,x:e,y:o}}),s.push({source:{side:Sides.UP,x:e,y:o},destination:{side:Sides.FRONT,x:e,y:o}});return s}createFrontFaceClockwiseRotator(e){const t=this.dimension-1,s=[];e===0&&s.push(...this.createSideLidClockwiseRotator(Sides.FRONT));for(let o=0;o<this.dimension;++o)s.push({source:{side:Sides.UP,x:o,y:t-e},destination:{side:Sides.RIGHT,x:e,y:o}}),s.push({source:{side:Sides.RIGHT,x:e,y:o},destination:{side:Sides.DOWN,x:t-o,y:e}}),s.push({source:{side:Sides.DOWN,x:t-o,y:e},destination:{side:Sides.LEFT,x:t-e,y:t-o}}),s.push({source:{side:Sides.LEFT,x:t-e,y:t-o},destination:{side:Sides.UP,x:o,y:t-e}});return s}createRightFaceClockwiseRotator(e){const t=this.dimension-1,s=[];e===0&&s.push(...this.createSideLidClockwiseRotator(Sides.RIGHT));for(let o=0;o<this.dimension;++o)s.push({source:{side:Sides.UP,x:t-e,y:o},destination:{side:Sides.BACK,x:e,y:t-o}}),s.push({source:{side:Sides.BACK,x:e,y:t-o},destination:{side:Sides.DOWN,x:t-e,y:o}}),s.push({source:{side:Sides.DOWN,x:t-e,y:o},destination:{side:Sides.FRONT,x:t-e,y:o}}),s.push({source:{side:Sides.FRONT,x:t-e,y:o},destination:{side:Sides.UP,x:t-e,y:o}});return s}createBackFaceClockwiseRotator(e){const t=this.dimension-1,s=[];e===0&&s.push(...this.createSideLidClockwiseRotator(Sides.BACK));for(let o=0;o<this.dimension;++o)s.push({source:{side:Sides.LEFT,x:e,y:o},destination:{side:Sides.DOWN,x:o,y:t-e}}),s.push({source:{side:Sides.DOWN,x:o,y:t-e},destination:{side:Sides.RIGHT,x:t-e,y:t-o}}),s.push({source:{side:Sides.RIGHT,x:t-e,y:t-o},destination:{side:Sides.UP,x:t-o,y:e}}),s.push({source:{side:Sides.UP,x:t-o,y:e},destination:{side:Sides.LEFT,x:e,y:o}});return s}createDownFaceClockwiseRotator(e){const t=this.dimension-1,s=[];e===0&&s.push(...this.createSideLidClockwiseRotator(Sides.DOWN));for(let o=0;o<this.dimension;++o)s.push({source:{side:Sides.LEFT,x:o,y:t-e},destination:{side:Sides.FRONT,x:o,y:t-e}}),s.push({source:{side:Sides.FRONT,x:o,y:t-e},destination:{side:Sides.RIGHT,x:o,y:t-e}}),s.push({source:{side:Sides.RIGHT,x:o,y:t-e},destination:{side:Sides.BACK,x:o,y:t-e}}),s.push({source:{side:Sides.BACK,x:o,y:t-e},destination:{side:Sides.LEFT,x:o,y:t-e}});return s}};let RubiksCubeFaceRotator=R;l(RubiksCubeFaceRotator,"faceRotatorMap",new Map);const defaultColorMap=new Map;defaultColorMap.set(Sides.FRONT,Colors.BLUE),defaultColorMap.set(Sides.UP,Colors.YELLOW),defaultColorMap.set(Sides.RIGHT,Colors.RED),defaultColorMap.set(Sides.LEFT,Colors.ORANGE),defaultColorMap.set(Sides.BACK,Colors.GREEN),defaultColorMap.set(Sides.DOWN,Colors.WHITE);class RubiksCube{constructor(e){l(this,"configuration");l(this,"dimension");l(this,"faceRotator");l(this,"colorlessCubelets");if(this.dimension=e==null?void 0:e.dimension,e!=null&&e.clone)this.dimension=Math.sqrt(e.clone.length/6),this.configuration=e.clone.slice();else{const t=this.dimension*this.dimension,s=(e==null?void 0:e.colorMap)||defaultColorMap,o=getAllSides();this.configuration="";for(let n=0;n<o.length;++n){const u=s.get(n),c=mapColorInitialsToString(u);this.configuration+=c.repeat(t)}}this.faceRotator=new RubiksCubeFaceRotator(this.dimension),this.colorlessCubelets=new CubeletsCreator(this.dimension).create()}clone(){return new RubiksCube({clone:this.configuration})}getDimension(){return this.dimension}getConfiguration(){return this.configuration}getHash(){return this.configuration}isSolved(){const e=this.dimension*this.dimension,t=getAllSides(),s=Array.from(new Array(e));return t.every((o,n)=>s.every((u,c)=>this.configuration[n*e+c]===this.configuration[n*e]))}rotateFace(e){return this.faceRotator.rotate(this,e)}getAllCubelets(){return this.addColorToCubelets(this.colorlessCubelets)}getAllColorlessCubelets(){return this.colorlessCubelets}getSideOfIndex(e){const t=getAllSides().length;return e/t}getColorlessCubeletOfIndex(e){return this.colorlessCubelets.find(t=>t.stickers.some(s=>s.id===e))}getCubeletsBySides(...e){const t=this.colorlessCubelets.filter(s=>s.stickers.every(o=>e.includes(o.side)));return this.addColorToCubelets(t)}getCubeletsByColor(...e){const t=this.colorlessCubelets.filter(s=>s.stickers.every(o=>e.includes(mapStringInitialToColor(this.configuration[o.id]))));return this.addColorToCubelets(t)}getColorOfIndex(e){return mapStringInitialToColor(this.configuration[e])}setColorsOfIndexes(e){const t=this.configuration.split("");e.forEach(s=>{t[s.index]=mapColorInitialsToString(s.color)}),this.configuration=t.join("")}addColorToCubelets(e){return e.map(t=>({stickers:t.stickers.map(s=>({...s,color:mapStringInitialToColor(this.configuration[s.id])}))}))}}var commonjsGlobal=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function getDefaultExportFromCjs(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}var doubleLinkedList=LinkedList;function LinkedList(){this._start=null,this._end=null,this.length=0}LinkedList.prototype.unShift=function(r){if(this._start===null)this._start=makeNode(r),this._end=this._start;else{var e=this._start;this._start.previous=makeNode(r),this._start=this._start.previous,this._start.next=e}this.length++},LinkedList.prototype.push=function(r){if(this._start===null)this._start=makeNode(r),this._end=this._start;else{var e=this._end;this._end.next=makeNode(r),this._end=this._end.next,this._end.previous=e}this.length++},LinkedList.prototype.add=function(r,e){if(r%1===0)if(r<=0)this.unShift(e);else if(r>=this.length)this.push(e);else{var t=findNode.call(this,r);if(t){var s=t.previous,o=t,n=makeNode(e);n.previous=s,s.next=n,n.next=o,o.previous=n,this.length++}}},LinkedList.prototype.shift=function(){if(this._start){var r=this._start.data;return this._start.next===null?(this._end=null,this._start=null):(this._start=this._start.next,this._start.previous=null),this.length--,r}else return},LinkedList.prototype.pop=function(){if(this._end){var r=this._end.data;return this._end.previous===null?(this._end=null,this._start=null):(this._end=this._end.previous,this._end.next=null),this.length--,r}else return},LinkedList.prototype.remove=function(r){if(r===0)return this.shift();if(r===this.length-1)return this.pop();var e=findNode.call(this,r);if(e){var t=e.previous,s=e.next;t.next=s,s.previous=t,this.length--}else return},LinkedList.prototype.first=function(){if(this._start)return this._start.data},LinkedList.prototype.last=function(){if(this._end)return this._end.data},LinkedList.prototype.get=function(r){var e=findNode.call(this,r);if(e)return e.data},LinkedList.prototype.toString=function(){for(var r=this._start,e="",t=0;t<this.length;t++)typeof r.data=="object"?e+=JSON.stringify(r.data):e+=r.data,t!==this.length-1&&(e+=", "),r=r.next;return e};function makeNode(r){return{data:r,previous:null,next:null}}function findNode(r){var e,t;if(r>=this.length||r<0||r%1!==0)e=null;else if(r<this.length/2)for(e=this._start,t=0;t<r;t++)e=e.next;else for(e=this._end,t=this.length-1;t>r;t--)e=e.previous;return e}class ProcedureMeasurer{constructor(e=!0){l(this,"map");l(this,"enabled");l(this,"measurerOverhead");l(this,"startTime");l(this,"totalTime");this.map=new Map,this.enabled=e,this.measurerOverhead=0}add(e,t){const s=performance.now();if(!this.enabled)return t();const o=t(),n=performance.now(),u=this.map.get(e)||{elapsedTime:0,calls:0,stack:"",stackSize:0};return u.elapsedTime+=n-s,++u.calls,this.map.set(e,u),this.measurerOverhead+=performance.now()-n,o}start(){this.startTime=performance.now()}finish(){this.startTime&&(this.totalTime=performance.now()-this.startTime)}getTotalTime(){return this.totalTime}getData(e){const t=[];if(this.totalTime){let s=0;Array.from(this.map.entries()).forEach(o=>{const[n,u]=o;s+=u.elapsedTime,t.push(this.createSummary(u.elapsedTime,u.calls,n))}),e!=null&&e.notMeasuredLabel&&t.push(this.createSummary(this.totalTime-s,0,e.notMeasuredLabel)),e!=null&&e.measurementOverheadLabel&&t.push(this.createSummary(this.measurerOverhead,0,e.measurementOverheadLabel))}return t}createSummary(e,t,s){const o=100*e/this.totalTime;return{label:s,totalTime:e,totalRelativeTime:Math.trunc(100*o)/100+"%",numOfCalls:t,avgTimePerCall:e*1/(t||1)}}}var Metrics$7=(r=>(r[r.ADD_CANDIDATE=0]="ADD_CANDIDATE",r[r.POP_CANDIDATE=1]="POP_CANDIDATE",r[r.HASH_CALCULATION=2]="HASH_CALCULATION",r[r.VISISTED_LIST_CHECK=3]="VISISTED_LIST_CHECK",r[r.ADD_TO_VISISTED_LIST_CHECK=4]="ADD_TO_VISISTED_LIST_CHECK",r[r.PERFORM_ROTATION=5]="PERFORM_ROTATION",r[r.NOT_MEASURED=6]="NOT_MEASURED",r))(Metrics$7||{});class BidirectionalBreadthFirstSearchSolver{constructor(e){l(this,"measurer");l(this,"forwardSearchToExploreList");l(this,"forwardSearchExploredMap");l(this,"reverseSearchToExploreList");l(this,"reverseSearchExploredMap");l(this,"actions");l(this,"iterations");l(this,"aborted");this.forwardSearchToExploreList=new doubleLinkedList,this.reverseSearchToExploreList=new doubleLinkedList,this.actions=[],this.iterations=0,this.measurer=new ProcedureMeasurer,this.forwardSearchExploredMap=new Map,this.reverseSearchExploredMap=new Map,this.aborted=!1;const t={cube:e,rotation:void 0,parent:void 0};this.forwardSearchToExploreList.push(t);const s=[],o=[Sides.RIGHT,Sides.LEFT][Math.floor(Math.random()*2)],n=[Sides.UP,Sides.DOWN][Math.floor(Math.random()*2)],u=[Sides.FRONT,Sides.BACK][Math.floor(Math.random()*2)];[o,n,u].map(f=>[!0,!1].map(S=>{s.push(getOppositeSide(f)),this.actions.push({side:f,counterClockwiseDirection:S,layer:0})}));const c=e.getCubeletsBySides(...s)[0],g={cube:this.buildSolvedCubeFromCornerCubelet(c,e.getDimension()),rotation:void 0,parent:void 0};this.reverseSearchToExploreList.push(g)}abort(){this.aborted=!0}async findSolution(){return new Promise((e,t)=>{this.measurer.start();let s,o,n=0;for(;this.forwardSearchToExploreList.length>0&&this.reverseSearchToExploreList.length>0;){if(++this.iterations,this.aborted)return t();do s=this.measurer.add(Metrics$7[1],()=>this.forwardSearchToExploreList.shift());while(this.measurer.add(Metrics$7[3],()=>this.forwardSearchExploredMap.has(s.cube.getHash())));do o=this.measurer.add(Metrics$7[1],()=>this.reverseSearchToExploreList.shift());while(this.measurer.add(Metrics$7[3],()=>this.reverseSearchExploredMap.has(o.cube.getHash())));++n;let u=this.measurer.add(Metrics$7[3],()=>this.forwardSearchExploredMap.get(o.cube.getHash()));if(u)return e(this.createSolution(u,o,n));if(u=this.measurer.add(Metrics$7[3],()=>this.reverseSearchExploredMap.get(s.cube.getHash())),u)return e(this.createSolution(s,u,n));this.measurer.add(Metrics$7[4],()=>this.forwardSearchExploredMap.set(s.cube.getHash(),s)),this.measurer.add(Metrics$7[4],()=>this.reverseSearchExploredMap.set(o.cube.getHash(),o)),this.applyRotations(this.forwardSearchToExploreList,this.forwardSearchExploredMap,s),this.applyRotations(this.reverseSearchToExploreList,this.reverseSearchExploredMap,o)}return t()})}applyRotations(e,t,s){this.actions.forEach(o=>{const n=this.measurer.add(Metrics$7[5],()=>s.cube.rotateFace(o));this.measurer.add(Metrics$7[3],()=>t.has(n.getHash()))||this.measurer.add(Metrics$7[0],()=>{e.push({cube:n,rotation:o,parent:s})})})}createSolution(e,t,s){this.measurer.finish();const o=[];let n=e;for(;n&&n.rotation;)o.unshift(n.rotation),n=n.parent;for(n=t;n&&n.rotation;){const u={...n.rotation};u.counterClockwiseDirection=!u.counterClockwiseDirection,o.push(u),n=n.parent}return{rotations:o,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:Metrics$7[6]}),iterations:this.iterations,visitedNodes:s}}}buildSolvedCubeFromCornerCubelet(e,t){const s=new Map;return e.stickers.forEach(o=>{s.set(o.side,o.color),s.set(getOppositeSide(o.side),getOppositeColor(o.color))}),new RubiksCube({colorMap:s,dimension:t})}}var Metrics$6=(r=>(r[r.ADD_CANDIDATE=0]="ADD_CANDIDATE",r[r.POP_CANDIDATE=1]="POP_CANDIDATE",r[r.CHECK_SOLUTION=2]="CHECK_SOLUTION",r[r.BREATHING_TIME=3]="BREATHING_TIME",r[r.HASH_CALCULATION=4]="HASH_CALCULATION",r[r.VISISTED_LIST_CHECK=5]="VISISTED_LIST_CHECK",r[r.ADD_TO_VISISTED_LIST_CHECK=6]="ADD_TO_VISISTED_LIST_CHECK",r[r.PERFORM_ROTATION=7]="PERFORM_ROTATION",r[r.NOT_MEASURED=8]="NOT_MEASURED",r))(Metrics$6||{});class BreadthFirstSearchSolver{constructor(e){l(this,"measurer");l(this,"candidates");l(this,"visitedChecklist");l(this,"actions");l(this,"aborted");this.measurer=new ProcedureMeasurer,this.visitedChecklist=new Map,this.candidates=new doubleLinkedList,this.aborted=!1;const t={cube:e,rotation:void 0,parent:void 0};this.candidates.push(t),this.actions=this.createActions()}abort(){this.aborted=!0}async findSolution(){return new Promise((e,t)=>{this.measurer.start();let s,o=0,n=0;for(;this.candidates.length>0;){if(this.aborted)return t();if(++o,s=this.measurer.add(Metrics$6[1],()=>this.candidates.shift()),!this.measurer.add(Metrics$6[5],()=>this.visitedChecklist.has(s.cube.getHash()))){if(++n,this.measurer.add(Metrics$6[2],()=>s.cube.isSolved()))return this.measurer.finish(),e(this.createSolution(s,o,n));this.measurer.add(Metrics$6[6],()=>this.visitedChecklist.set(s.cube.getHash(),!0)),this.applyRotations(s)}}t(Error("No more candidates to explore"))})}createSolution(e,t,s){const o=[];let n=e;for(;n&&n.rotation;)o.unshift(n.rotation),n=n.parent;return{rotations:o,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:Metrics$6[8]}),visitedNodes:t,differentNodes:s}}}createActions(){const e=[],t=[Sides.RIGHT,Sides.LEFT][Math.floor(Math.random()*2)],s=[Sides.UP,Sides.DOWN][Math.floor(Math.random()*2)],o=[Sides.FRONT,Sides.BACK][Math.floor(Math.random()*2)];return[t,s,o].map(n=>[!0,!1].map(u=>{e.push({side:n,counterClockwiseDirection:u,layer:0})})),e}applyRotations(e){this.actions.forEach(t=>{const s=this.measurer.add(Metrics$6[7],()=>e.cube.rotateFace(t));this.measurer.add(Metrics$6[5],()=>this.visitedChecklist.has(s.getHash()))||this.measurer.add(Metrics$6[0],()=>{this.candidates.push({cube:s,rotation:t,parent:e})})})}}const rotationsAreEqual=(r,e)=>r.layer===e.layer&&r.side===e.side&&r.counterClockwiseDirection===e.counterClockwiseDirection,rotationsCancel=(r,e)=>r.layer===e.layer&&r.side===e.side&&r.counterClockwiseDirection!==e.counterClockwiseDirection,getOppositeRotation=r=>({layer:r.layer,side:r.side,counterClockwiseDirection:!r.counterClockwiseDirection});class RotationsTuner{tune(e){const t=[];let s,o=!1,n=1;for(let u of e){if(s&&rotationsCancel(u,s))t.pop(),o=!0,n=0;else{if(s)if(rotationsAreEqual(s,u)){if(++n,n===3){t.pop(),t.pop(),t.push(getOppositeRotation(u)),n=0,o=!0;continue}}else rotationsAreEqual(s,u)||(n=1);t.push(u)}s=u}return o?this.tune(t):t}}var Metrics$5=(r=>(r[r.ADD_CANDIDATE=0]="ADD_CANDIDATE",r[r.POP_CANDIDATE=1]="POP_CANDIDATE",r[r.CHECK_SOLUTION=2]="CHECK_SOLUTION",r[r.BREATHING_TIME=3]="BREATHING_TIME",r[r.HASH_CALCULATION=4]="HASH_CALCULATION",r[r.VISISTED_LIST_CHECK=5]="VISISTED_LIST_CHECK",r[r.ADD_TO_VISISTED_LIST_CHECK=6]="ADD_TO_VISISTED_LIST_CHECK",r[r.PERFORM_ROTATION=7]="PERFORM_ROTATION",r[r.NOT_MEASURED=8]="NOT_MEASURED",r))(Metrics$5||{});class InterativeDeepeningAStarSolver{constructor(e){l(this,"measurer");l(this,"actions");l(this,"goalStateHash");l(this,"root");l(this,"bound");l(this,"visitedNodes");l(this,"aborted");this.measurer=new ProcedureMeasurer,this.visitedNodes=0,this.aborted=!1,this.actions=[],[Sides.FRONT,Sides.UP,Sides.RIGHT].map(o=>{this.actions.push({side:o,layer:0})});const t=e.getCubeletsBySides(Sides.BACK,Sides.LEFT,Sides.DOWN)[0],s=this.buildSolvedPocketCubeFromCornerCubelet(t,e.getDimension());this.goalStateHash=s.getHash(),this.bound=this.calculateDistanceToFinalState(e),this.root={cube:e,rotation:void 0,parent:void 0,cost:0}}abort(){this.aborted=!0}async findSolution(){return new Promise((e,t)=>{for(this.measurer.start();!this.aborted;){const s=this.beginSearch(this.root,0);if(typeof s=="number")this.bound=Number(s);else return this.measurer.finish(),e(this.createSolution(s))}t(Error("Aborted"))})}beginSearch(e,t){if(++this.visitedNodes,this.aborted)return-1;const s=this.calculateDistanceToFinalState(e.cube),o=e.cost+s;if(o>this.bound)return o;if(e.cube.isSolved())return e;let n=1/0;const u=this.applyRotations(e);for(let c of u){const m=this.beginSearch(c,t+1);if(typeof m=="number")n=Math.min(m,n);else return m}return n}createSolution(e){const t=[];let s=e;for(;s&&s.rotation;)t.unshift(s.rotation),s=s.parent;return{rotations:new RotationsTuner().tune(t),totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:Metrics$5[8]}),visitedNodes:this.visitedNodes}}}applyRotations(e){const t=[];return this.actions.forEach(s=>{const o=this.measurer.add(Metrics$5[7],()=>e.cube.rotateFace(s));this.measurer.add(Metrics$5[0],()=>{t.push({cube:o,rotation:s,parent:e,cost:e.cost+1})})}),t}calculateDistanceToFinalState(e){const t=e.getDimension()*e.getDimension()+e.getDimension()*4,s=e.getConfiguration();return Math.ceil(s.split("").filter((o,n)=>o!==this.goalStateHash[n]).length/t)}buildSolvedPocketCubeFromCornerCubelet(e,t){const s=new Map;return e.stickers.forEach(o=>{s.set(o.side,o.color),s.set(getOppositeSide(o.side),getOppositeColor(o.color))}),new RubiksCube({colorMap:s,dimension:t})}}var Metrics$4=(r=>(r[r.ADD_CANDIDATE=0]="ADD_CANDIDATE",r[r.POP_CANDIDATE=1]="POP_CANDIDATE",r[r.CHECK_SOLUTION=2]="CHECK_SOLUTION",r[r.BREATHING_TIME=3]="BREATHING_TIME",r[r.HASH_CALCULATION=4]="HASH_CALCULATION",r[r.VISISTED_LIST_CHECK=5]="VISISTED_LIST_CHECK",r[r.ADD_TO_VISISTED_LIST_CHECK=6]="ADD_TO_VISISTED_LIST_CHECK",r[r.PERFORM_ROTATION=7]="PERFORM_ROTATION",r[r.NOT_MEASURED=8]="NOT_MEASURED",r))(Metrics$4||{});class InterativeDeepeningDepthFirstSearchSolver{constructor(e){l(this,"measurer");l(this,"actions");l(this,"root");l(this,"currentMaxDepth");l(this,"visitedNodes");l(this,"visitedLeaves");l(this,"aborted");this.measurer=new ProcedureMeasurer,this.visitedNodes=0,this.visitedLeaves=0,this.aborted=!1,this.actions=this.createActions();const t=e.getCubeletsBySides(Sides.BACK,Sides.LEFT,Sides.DOWN)[0],s=this.buildSolvedPocketCubeFromCornerCubelet(t,e.getDimension());this.currentMaxDepth=this.calculateDistanceToFinalState(e,s.getConfiguration()),this.root={cube:e,rotation:void 0,parent:void 0}}abort(){this.aborted=!0}async findSolution(){return new Promise((e,t)=>{for(this.measurer.start();!this.aborted;){const s=this.beginSearch(this.root,0);if(s)return this.measurer.finish(),e(this.createSolution(s));++this.currentMaxDepth}t(Error("Aborted"))})}beginSearch(e,t){if(++this.visitedNodes,!this.aborted){if(t<this.currentMaxDepth){const s=this.applyRotations(e);for(let o of s){const n=this.beginSearch(o,t+1);if(n)return n}}else if(t===this.currentMaxDepth&&(++this.visitedLeaves,e.cube.isSolved()))return e}}createActions(){const e=[];return[Sides.FRONT,Sides.UP,Sides.RIGHT].map(t=>[!0,!1].map(s=>{e.push({side:t,counterClockwiseDirection:s,layer:0})})),e}createSolution(e){const t=[];let s=e;for(;s&&s.rotation;)t.unshift(s.rotation),s=s.parent;return{rotations:t,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:Metrics$4[8]}),visitedNodes:this.visitedNodes,visitedLeaves:this.visitedLeaves}}}applyRotations(e){const t=[];return this.actions.forEach(s=>{const o=this.measurer.add(Metrics$4[7],()=>e.cube.rotateFace(s));this.measurer.add(Metrics$4[0],()=>{t.push({cube:o,rotation:s,parent:e})})}),t}calculateDistanceToFinalState(e,t){const s=e.getDimension()*e.getDimension()+e.getDimension()*4,o=e.getConfiguration();return Math.ceil(o.split("").filter((n,u)=>n!==t[u]).length/s)}buildSolvedPocketCubeFromCornerCubelet(e,t){const s=new Map;return e.stickers.forEach(o=>{s.set(o.side,o.color),s.set(getOppositeSide(o.side),getOppositeColor(o.color))}),new RubiksCube({colorMap:s,dimension:t})}}var heapExports$1={},heap$1={get exports(){return heapExports$1},set exports(r){heapExports$1=r}},heapExports={},heap={get exports(){return heapExports},set exports(r){heapExports=r}};(function(r,e){(function(){var t,s,o,n,u,c,m,g,f,S,w,A,D,y,O;o=Math.floor,S=Math.min,s=function(a,h){return a<h?-1:a>h?1:0},f=function(a,h,d,p,T){var C;if(d==null&&(d=0),T==null&&(T=s),d<0)throw new Error("lo must be non-negative");for(p==null&&(p=a.length);d<p;)C=o((d+p)/2),T(h,a[C])<0?p=C:d=C+1;return[].splice.apply(a,[d,d-d].concat(h)),h},c=function(a,h,d){return d==null&&(d=s),a.push(h),y(a,0,a.length-1,d)},u=function(a,h){var d,p;return h==null&&(h=s),d=a.pop(),a.length?(p=a[0],a[0]=d,O(a,0,h)):p=d,p},g=function(a,h,d){var p;return d==null&&(d=s),p=a[0],a[0]=h,O(a,0,d),p},m=function(a,h,d){var p;return d==null&&(d=s),a.length&&d(a[0],h)<0&&(p=[a[0],h],h=p[0],a[0]=p[1],O(a,0,d)),h},n=function(a,h){var d,p,T,C,b,E;for(h==null&&(h=s),C=function(){E=[];for(var v=0,I=o(a.length/2);0<=I?v<I:v>I;0<=I?v++:v--)E.push(v);return E}.apply(this).reverse(),b=[],p=0,T=C.length;p<T;p++)d=C[p],b.push(O(a,d,h));return b},D=function(a,h,d){var p;if(d==null&&(d=s),p=a.indexOf(h),p!==-1)return y(a,0,p,d),O(a,p,d)},w=function(a,h,d){var p,T,C,b,E;if(d==null&&(d=s),T=a.slice(0,h),!T.length)return T;for(n(T,d),E=a.slice(h),C=0,b=E.length;C<b;C++)p=E[C],m(T,p,d);return T.sort(d).reverse()},A=function(a,h,d){var p,T,C,b,E,v,I,L,_;if(d==null&&(d=s),h*10<=a.length){if(C=a.slice(0,h).sort(d),!C.length)return C;for(T=C[C.length-1],I=a.slice(h),b=0,v=I.length;b<v;b++)p=I[b],d(p,T)<0&&(f(C,p,0,null,d),C.pop(),T=C[C.length-1]);return C}for(n(a,d),_=[],E=0,L=S(h,a.length);0<=L?E<L:E>L;0<=L?++E:--E)_.push(u(a,d));return _},y=function(a,h,d,p){var T,C,b;for(p==null&&(p=s),T=a[d];d>h;){if(b=d-1>>1,C=a[b],p(T,C)<0){a[d]=C,d=b;continue}break}return a[d]=T},O=function(a,h,d){var p,T,C,b,E;for(d==null&&(d=s),T=a.length,E=h,C=a[h],p=2*h+1;p<T;)b=p+1,b<T&&!(d(a[p],a[b])<0)&&(p=b),a[h]=a[p],h=p,p=2*h+1;return a[h]=C,y(a,E,h,d)},t=function(){a.push=c,a.pop=u,a.replace=g,a.pushpop=m,a.heapify=n,a.updateItem=D,a.nlargest=w,a.nsmallest=A;function a(h){this.cmp=h??s,this.nodes=[]}return a.prototype.push=function(h){return c(this.nodes,h,this.cmp)},a.prototype.pop=function(){return u(this.nodes,this.cmp)},a.prototype.peek=function(){return this.nodes[0]},a.prototype.contains=function(h){return this.nodes.indexOf(h)!==-1},a.prototype.replace=function(h){return g(this.nodes,h,this.cmp)},a.prototype.pushpop=function(h){return m(this.nodes,h,this.cmp)},a.prototype.heapify=function(){return n(this.nodes,this.cmp)},a.prototype.updateItem=function(h){return D(this.nodes,h,this.cmp)},a.prototype.clear=function(){return this.nodes=[]},a.prototype.empty=function(){return this.nodes.length===0},a.prototype.size=function(){return this.nodes.length},a.prototype.clone=function(){var h;return h=new a,h.nodes=this.nodes.slice(0),h},a.prototype.toArray=function(){return this.nodes.slice(0)},a.prototype.insert=a.prototype.push,a.prototype.top=a.prototype.peek,a.prototype.front=a.prototype.peek,a.prototype.has=a.prototype.contains,a.prototype.copy=a.prototype.clone,a}(),function(a,h){return r.exports=h()}(this,function(){return t})}).call(commonjsGlobal)})(heap),function(r){r.exports=heapExports}(heap$1);var Heap=getDefaultExportFromCjs(heapExports$1),Metrics$3=(r=>(r[r.ADD_CANDIDATE=0]="ADD_CANDIDATE",r[r.POP_CANDIDATE=1]="POP_CANDIDATE",r[r.CHECK_SOLUTION=2]="CHECK_SOLUTION",r[r.BREATHING_TIME=3]="BREATHING_TIME",r[r.HASH_CALCULATION=4]="HASH_CALCULATION",r[r.VISISTED_LIST_CHECK=5]="VISISTED_LIST_CHECK",r[r.ADD_TO_VISISTED_LIST_CHECK=6]="ADD_TO_VISISTED_LIST_CHECK",r[r.PERFORM_ROTATION=7]="PERFORM_ROTATION",r[r.NOT_MEASURED=8]="NOT_MEASURED",r[r.HEURISTIC_CALCULATION=9]="HEURISTIC_CALCULATION",r[r.GET_ALL_CUBELETS=10]="GET_ALL_CUBELETS",r[r.CUBELET_FINAL_POSITION=11]="CUBELET_FINAL_POSITION",r[r.CUBELET_SIMILARITY=12]="CUBELET_SIMILARITY",r[r.ITERATION=13]="ITERATION",r[r.SOLUTION_CREATION=14]="SOLUTION_CREATION",r[r.MEASUREMENT_OVERHEAD=15]="MEASUREMENT_OVERHEAD",r[r.ITERATIONS_COUNTER_INCREMENT=16]="ITERATIONS_COUNTER_INCREMENT",r[r.ABORTED_VERIFICATION=17]="ABORTED_VERIFICATION",r[r.BUILD_SOLUTION=18]="BUILD_SOLUTION",r))(Metrics$3||{});class WeightedAStarSolver{constructor(e){l(this,"measurer");l(this,"candidates");l(this,"visitedChecklist");l(this,"actions");l(this,"dimension");l(this,"goalStateHash");l(this,"aborted");this.aborted=!1,this.dimension=e.getDimension(),this.candidates=new Heap((n,u)=>n.cost+WeightedAStarAlgorithmConfig.heuristicWeight*n.heuristicValue-(u.cost+WeightedAStarAlgorithmConfig.heuristicWeight*u.heuristicValue)),this.visitedChecklist=new Map;const t={cost:0,heuristicValue:0,cube:e,rotation:void 0,parentHash:void 0,hash:e.getHash()};this.candidates.push(t),this.actions=[];const s=e.getCubeletsBySides(Sides.BACK,Sides.LEFT,Sides.DOWN)[0],o=this.buildSolvedPocketCubeFromCornerCubelet(s);this.goalStateHash=o.getHash(),[Sides.FRONT,Sides.UP,Sides.RIGHT].map(n=>[!0,!1].map(u=>{this.actions.push({side:n,counterClockwiseDirection:u,layer:0})})),this.measurer=new ProcedureMeasurer(Configuration.metrics.enabled)}async findSolution(){return new Promise((e,t)=>{this.measurer.start();let s,o=0,n=0;for(;this.measurer.add(Metrics$3[16],()=>this.candidates.size()>0);){if(this.measurer.add(Metrics$3[17],()=>this.aborted))return t();if(this.measurer.add(Metrics$3[16],()=>++o),s=this.measurer.add(Metrics$3[1],()=>this.candidates.pop()),!this.measurer.add(Metrics$3[5],()=>this.visitedChecklist.has(s.hash))){if(++n,this.measurer.add(Metrics$3[2],()=>s.hash===this.goalStateHash))return e(this.measurer.add(Metrics$3[14],()=>this.createSolution(s,o,n)));this.measurer.add(Metrics$3[6],()=>this.visitedChecklist.set(s.hash,s)),this.applyRotations(s)}}t(Error("No more candidates to explore"))})}abort(){this.aborted=!0}createSolution(e,t,s){const o=[];let n=e;return this.measurer.add(Metrics$3[18],()=>{for(;n&&n.rotation;)o.unshift(n.rotation),n=this.visitedChecklist.get(n.parentHash)}),this.measurer.finish(),this.candidates.clear(),{rotations:o,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:Metrics$3[8],measurementOverheadLabel:Metrics$3[15]}),visitedNodes:t,differentNodes:s}}}applyRotations(e){for(let t of this.actions){const s=this.measurer.add(Metrics$3[7],()=>e.cube.rotateFace(t)),o=s.getHash(),n=this.measurer.add(Metrics$3[9],()=>this.calculateDistanceToFinalState(s)),u={cost:e.cost+1,cube:s,rotation:t,heuristicValue:n,parentHash:e.hash,hash:o};this.measurer.add(Metrics$3[5],()=>this.visitedChecklist.get(o))||this.measurer.add(Metrics$3[0],()=>{this.candidates.push(u)})}}calculateDistanceToFinalState(e){const t=this.dimension*this.dimension+this.dimension*4;return e.getConfiguration().split("").filter((o,n)=>o!==this.goalStateHash[n]).length/t}buildSolvedPocketCubeFromCornerCubelet(e){const t=new Map;return e.stickers.forEach(s=>{t.set(s.side,s.color),t.set(getOppositeSide(s.side),getOppositeColor(s.color))}),new RubiksCube({colorMap:t,dimension:this.dimension})}}class CubeScrambler{constructor(e=30){l(this,"moves");this.moves=e}scramble(e){let t;const s=Math.floor(e.getDimension()/2),o=getAllSides(),n=[];return Array.from(new Array(this.moves)).forEach(()=>{const u=Math.floor(Math.random()*6)===0,c=Math.floor(Math.random()*2)===0,m=Math.floor(Math.random()*s);let g=Math.floor(Math.random()*o.length),f={side:g,counterClockwiseDirection:c,layer:m};for(;t!==void 0&&t.side===f.side&&t.layer===f.layer;)g=Math.floor(Math.random()*o.length),f={side:g,counterClockwiseDirection:c,layer:m};t=f,u&&(f.counterClockwiseDirection=!1,n.push(f)),n.push(f)}),n.filter((u,c)=>c<this.moves)}}class GeneticAlgorithm{constructor(e,t,s){l(this,"orientationList");l(this,"mutationList");l(this,"original");l(this,"generationsCounter");this.original=e,this.mutationList=t,this.orientationList=s,this.generationsCounter=0}createNextGeneration(e){if(++this.generationsCounter,!e)return this.createNewPopulationFromScratch();const t=e.sort((o,n)=>{const u=o.score-n.score;return u===0?o.genes.length-n.genes.length:u});if(this.generationsCounter%GeneticAlgorithmConfig.armageddonThreshold===0)return console.log(`armageddon. best: ${t[0].score}/${t[t.length-1].score}, moves list: ${t[0].genes.length}`),this.createNewPopulationFromScratch();const s=t.filter((o,n)=>n<GeneticAlgorithmConfig.elitism);return Array.from(Array(GeneticAlgorithmConfig.populationPerGeneration)).map(()=>this.reproduceCitizens(s))}getGenerationsCounter(){return this.generationsCounter}createNewPopulationFromScratch(){return Array.from(new Array(GeneticAlgorithmConfig.populationPerGeneration)).map(()=>({cube:this.original.clone(),genes:[],score:NaN,newGenes:new CubeScrambler(GeneticAlgorithmConfig.numberOfInitialScrambleMovements).scramble(this.original)}))}reproduceCitizens(e){const t=e[Math.floor(Math.random()*e.length)],s=[],o=()=>this.mutationList[Math.floor(Math.random()*this.mutationList.length)],n=()=>this.orientationList[Math.floor(Math.random()*this.orientationList.length)];switch(Math.floor(Math.random()*4)){case 0:s.push(...o());break;case 1:s.push(...o()),s.push(...o());break;case 2:s.push(...n()),s.push(...o());break;case 3:s.push(...n()),s.push(...n()),s.push(...o());break;case 4:s.push(...o());break}return{cube:t.cube.clone(),genes:[...t.genes.slice(0)],newGenes:s,score:987}}}var srcExports={},src={get exports(){return srcExports},set exports(r){srcExports=r}};(function(module){var colorList={reset:[0,0],bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],inverse:[7,27],hidden:[8,28],strikethrough:[9,29],black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],gray:[90,39],grey:[90,39],redBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39],bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],blackBG:[40,49],redBG:[41,49],greenBG:[42,49],yellowBG:[43,49],blueBG:[44,49],magentaBG:[45,49],cyanBG:[46,49],whiteBG:[47,49],bgBlackBright:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]};if(typeof process>"u"||!process.env)var process={env:{},argv:["--color"]};var isDisabled={}.NO_COLOR||process.argv.includes("--no-color"),isSupported=!isDisabled&&({}.FORCE_COLOR||process.platform==="win32"||process.argv.includes("--color")||eval("require('tty')").isatty(1)&&{}.TERM!=="dumb"||{}.CI),TObject=typeof Reflect>"u"?Object:Reflect,fncache={};function extend(r,e){var t=e.join("");return Object.keys(colorList).forEach(function(s){var o=t+s;TObject.defineProperty(r,s,{get(){return fncache[o]||(fncache[o]=extend(function(u){return r(color[s](u))},e.concat(s))),fncache[o]}})}),r}function replaceClose(r,e,t,s){var o=r.substring(s+t.length),n=o.indexOf(t);return r.substring(0,s)+e+(~n?replaceClose(o,e,t,n):o)}function getFn(r){var e=colorList[r];if(!e||!isSupported)return function(o){return String(o)};var t=e[0],s=e[1];return function(o){if(o===""||o==null)return"";o=""+o;var n=o.indexOf(s,t.length);return t+(n>-1&&n<o.length-1?replaceClose(o,t,s,n):o)+s}}function color(r,e){return getFn(e)(r)}color.list=colorList;function init(){Object.keys(colorList).forEach(function(r){clc[r]=color[r]=extend(getFn(r),[r])})}for(var clc={color,list:colorList,log(r,e){console.log(color(r,e))},isSupported(){return isSupported},enable(){isSupported=!0,init()},disable(){isSupported=!1,init()},strip(r){return r.replace(/\x1b\[\d+m/gm,"")}},i=0;i<256;i++)colorList["c"+i]=["38;5;"+i,0],colorList["bg"+i]=["48;5;"+i,0];Object.keys(colorList).forEach(function(r){colorList[r]=colorList[r].map(function(e){return"\x1B["+e+"m"}),clc.log[r]=function(){for(var e=[],t=0;t<arguments.length;t++)e.push(arguments[t]);console.log(color[r](e.join(" ")))}}),init(),module.exports=clc})(src);var clc=srcExports;const{log,color,list,isSupported,disable,enable,strip,reset,bold,dim,italic,underline,inverse,hidden,strikethrough,black,red,green,yellow,blue,magenta,cyan,white,gray,grey,redBright,greenBright,yellowBright,blueBright,magentaBright,cyanBright,whiteBright,bgBlack,bgRed,bgGreen,bgYellow,bgBlue,bgMagenta,bgCyan,bgWhite,blackBG,redBG,greenBG,yellowBG,blueBG,magentaBG,cyanBG,whiteBG,bgBlackBright,bgRedBright,bgGreenBright,bgYellowBright,bgBlueBright,bgMagentaBright,bgCyanBright,bgWhiteBright}=clc;class HumanTranslator{translateSide(e,t){const s=t.getAllCubelets(),o=t.getDimension(),n=10,u=(m,g,f)=>{for(const S of s){const w=S.stickers.find(A=>A.side===m&&A.x===g&&A.y===f);if(w)return w}console.log(`Sticker not found: ${Sides[m]}, ${g}, ${f}`)},c=[];c.push(`${(Sides[e]+Array.from(new Array(n)).fill(" ").join("")).substring(0,n)}`);for(let m=0;m<o;++m){let g="";for(let f=0;f<o;++f){const S=u(e,f,m),w=Colors[S.color].substring(0,1)+HumanTranslator.mapToSubscript(`${("  "+S.id).slice(-2)}  `);let A=Colors[S.color].toLowerCase();A==="white"&&(A="gray"),A==="orange"&&(A="redBright");const D=color[A](w);g+=D}c.push(g)}return c}translateCube(e){const t=e.getDimension(),s=this.translateSide(Sides.UP,e),o=this.translateSide(Sides.LEFT,e),n=this.translateSide(Sides.FRONT,e),u=this.translateSide(Sides.RIGHT,e),c=this.translateSide(Sides.BACK,e),m=this.translateSide(Sides.DOWN,e);let g="";const f=Array.from(new Array(s[1].length/3)).fill(" ").join("");s.forEach(S=>{g+=f+S+`
`}),g+=o[0],g+=(f+n[0]).slice(-f.length),g+=(f+u[0]).slice(-f.length),g+=(f+c[0]).slice(-f.length)+`
`;for(let S=1;S<t+1;++S)g+=o[S],g+=n[S],g+=u[S],g+=c[S]+`
`;m.forEach(S=>{g+=f+S+`
`}),console.log(g)}convertStringToFaceRotations(e){return e.length===0?[]:e.match(/((\d?)(\w)(\d?)('?))\s*/g).reduce((t,s)=>{const[o,n,u,c,m]=s.match(/(\d?)(\w)(\d?)('?)\s*/),g={side:Sides.UP,counterClockwiseDirection:(m==null?void 0:m.length)>0,layer:Number((c==null?void 0:c.length)>0)};switch(u.toLowerCase()){case"u":g.side=Sides.UP;break;case"l":g.side=Sides.LEFT;break;case"f":g.side=Sides.FRONT;break;case"r":g.side=Sides.RIGHT;break;case"b":g.side=Sides.BACK;break;case"d":g.side=Sides.DOWN;break;default:return t}return(n==null?void 0:n.length)>0?t.push([g,g]):t.push([g]),t},[])}translateRotations(e,t){const s=[...e];let o=0,n="";t!=null&&t.showNumberOfMoves&&(o++,n+=`${e.length}:      `.substring(0,4));let u=s.shift();for(;u;){const c=s[0];let m=" ";c&&rotationsAreEqual(c,u)&&(s.shift(),m="2");let g="";if(t&&t.showLayer){let S=1;u.layer!==void 0&&(S=u.layer+1),g=S.toString(),t.subscript&&(g=HumanTranslator.mapToSubscript(S.toString()))}const f=u.counterClockwiseDirection;n+=`${m}${Sides[u.side].substring(0,1)}${f?"'":" "}${g}  `,(t==null?void 0:t.lineBreak)!==void 0&&o%(t==null?void 0:t.lineBreak)===(t==null?void 0:t.lineBreak)-1&&(n+=`
`),++o,u=s.shift()}return n}translateCubelets(e){let t="";return e.map(s=>{s.stickers.map(o=>{const n=Colors[o.color],u=Sides[o.side],c=HumanTranslator.mapToSmallTopLetters(o.id.toString()),m=`${HumanTranslator.mapToSubscript("("+o.x+","+o.y+")")}`;t+=`${n.substring(0,1).toUpperCase().concat(n.substring(1).toLowerCase())}: ${u}${c}${m};  `}),t+=`
`}),t}static mapToSmallTopLetters(e){const t=new Map;return t.set("0","⁰"),t.set("1","¹"),t.set("2","²"),t.set("3","³"),t.set("4","⁴"),t.set("5","⁵"),t.set("6","⁶"),t.set("7","⁷"),t.set("8","⁸"),t.set("9","⁹"),t.set(",","﹐"),e.split("").map(s=>t.has(s)?t.get(s):s).join("")}static mapToSubscript(e){const t=new Map;return t.set("0","₀"),t.set("1","₁"),t.set("2","₂"),t.set("3","₃"),t.set("4","₄"),t.set("5","₅"),t.set("6","₆"),t.set("7","₇"),t.set("8","₈"),t.set("9","₉"),t.set("0","₀"),t.set("(","₍"),t.set(")","₎"),e.split("").map(s=>t.has(s)?t.get(s):s).join("")}}var Metrics$2=(r=>(r[r.NOT_MEASURED=0]="NOT_MEASURED",r[r.RUN_CITIZEN_ROTATIONS=1]="RUN_CITIZEN_ROTATIONS",r[r.CALCULATE_CITIZEN_SCORE=2]="CALCULATE_CITIZEN_SCORE",r[r.ROTATIONS_TUNING=3]="ROTATIONS_TUNING",r))(Metrics$2||{});const orientations=["F F2 F3","F' F2' F3'","2F 2F2 2F3","R R2 R3","R' R2' R3'","2R 2R2 2R3","U U2 U3","U' U2' U3'","2U 2U2 2U3"],supervisedPermutations=["2R2 2F2 2F2","F' L' B' R' U' R U' B L F R U R' U","F R B L U L' U B' R' F' L' U' L U'","2U B 2U B' 2R F R' F' 2U F' 2U F R'","2U R 2U R' 2F L F' L' 2U L' 2U L F'","U' 2B 2D L' 2F 2D 2B R' U'","U 2B 2D R 2F 2D 2B L U","D' R' D 2R U' R 2B L U' L' 2B U 2R","D L D' 2L U L' 2B R' U R 2B U' 2L","R' U L' 2U R U' L R' U L' 2U R U' L U'","L U' R 2U L' U R' L U' R 2U L' U R' U","F' U B U' F U B' U'","F U' B' U F' U' B U","L' 2U L R' 2F R","R' 2U R L' 2B L","2R2 U 2R2 2U 2R2 U 2R2"];class GeneticAlgorithmSolver{constructor(e){l(this,"measurer");l(this,"initialState");l(this,"geneticAlgorithm");l(this,"citizens");l(this,"aborted");l(this,"armageddonCounter");this.measurer=new ProcedureMeasurer,this.initialState=e.clone(),this.aborted=!1,this.armageddonCounter=0;const t=new HumanTranslator;this.geneticAlgorithm=new GeneticAlgorithm(this.initialState,supervisedPermutations.map(s=>t.convertStringToFaceRotations(s)),orientations.map(s=>t.convertStringToFaceRotations(s))),this.citizens=this.geneticAlgorithm.createNextGeneration()}async findSolution(){return this.measurer.start(),new Promise((e,t)=>{for(;;){if(this.aborted)return t();const s=[];for(let o of this.citizens){if(this.runCitizen(o),o.score===0)return e(this.createSolution(o));s.push(o)}this.citizens=this.geneticAlgorithm.createNextGeneration(s)}})}abort(){this.aborted=!0}runCitizen(e){let t;for(let s of e.newGenes){e.genes.push(s),e.cube=e.cube.rotateFace(s);const o=this.calculateCitizenScore(e.cube);if((Number.isNaN(o)||o===999)&&console.log("what"),e.score=o,t={genes:e.genes.slice(),score:o,newGenes:[],cube:e.cube.clone()},o===0)return t}return t.genes=new RotationsTuner().tune(t.genes),t}calculateCitizenScore(e){return this.measurer.add(Metrics$2[2],()=>{const t=e.getConfiguration(),s=this.buildSolvedCubeFromCenterCubelets(e).getConfiguration();return t.split("").filter((o,n)=>o!==s[n]).length})}createSolution(e){const t=this.measurer.add(Metrics$2[3],()=>new RotationsTuner().tune(e.genes));return this.measurer.finish(),{rotations:t,totalTime:this.measurer.getTotalTime(),data:{armageddonCounter:this.armageddonCounter,metrics:this.measurer.getData({notMeasuredLabel:Metrics$2[0]}),generations:this.geneticAlgorithm.getGenerationsCounter()}}}buildSolvedCubeFromCenterCubelets(e){const t=e.getAllColorlessCubelets().filter(o=>o.stickers.length===1).map(o=>o.stickers[0].id),s=new Map;return getAllSides().forEach((o,n)=>{s.set(o,e.getColorOfIndex(t[n]))}),new RubiksCube({colorMap:s,dimension:this.initialState.getDimension()})}}class NeuroGeneticAlgorithm{constructor(e,t){l(this,"mutationRate");l(this,"populationPerGeneration");l(this,"generationsCounter");this.generationsCounter=0,this.mutationRate=e,this.populationPerGeneration=t}createNextGeneration(e){++this.generationsCounter;const t=e.reduce((o,n)=>({score:o.score+n.score,movesLength:o.movesLength+n.genes.length}),{score:0,movesLength:0});this.generationsCounter%10===0&&console.log(`${this.generationsCounter} >. score sum: ${t.score}. avg: ${Math.round(10*t.score/e.length)/10}. moves ${Math.round(10*t.movesLength/e.length)/10}`);const s=e.map(o=>({genes:o.genes,score:parseFloat(o.score.toString())/t.score}));return Array.from(Array(this.populationPerGeneration)).map(()=>this.createNewCitizen(this.pickOne(s),this.pickOne(s)))}getGenerationsCounter(){return this.generationsCounter}createNewCitizen(e,t){const s=Math.floor(Math.random()*e.genes.length);return{genes:e.genes.map((n,u)=>{let c=e.genes[u];return u>s&&(c=t.genes[u]),Math.random()<this.mutationRate&&(c*=Math.random()*2-1),c}),score:NaN}}pickOne(e){let t=0,s=Math.random();for(;s>0;)s-=e[t].score,++t;return--t,e[t]}}class NeuralNetwork{constructor(e,t){l(this,"weights");l(this,"config");if(this.config=e,t)this.weights=t;else{let s=this.config.inputs+this.config.outputs;this.config.bias!==void 0&&(s+=1);const o=s*this.config.hiddenNeurons;this.weights=Array.from(Array(o)).map(()=>Math.random()*2-1)}}getWeights(){return this.weights}doTheMagic(e){if(e.length!==this.config.inputs)throw new Error(`Amount of function argument '${e.length}' should match configuration inputs quantity '${this.config.inputs}'`);const t=[...e,this.config.bias],s=NeuralNetwork.processLayer(t,this.weights.filter((o,n)=>n>=0&&n<this.config.inputs*this.config.hiddenNeurons),this.config.hiddenNeurons);return NeuralNetwork.processLayer(s,this.weights.filter((o,n)=>n>=this.config.inputs*this.config.hiddenNeurons),this.config.outputs)}static processLayer(e,t,s){const o=Array.from(Array(s)).map(()=>0);return t.reduce((n,u,c)=>(n[c%s]+=u*e[c%e.length],n),o).map(n=>Math.tanh(n))}}var Metrics$1=(r=>(r[r.NOT_MEASURED=0]="NOT_MEASURED",r[r.RUN_NEURAL_NETWORK=1]="RUN_NEURAL_NETWORK",r[r.CALCULATE_CITIZEN_SCORE=2]="CALCULATE_CITIZEN_SCORE",r[r.ROTATIONS_TUNING=3]="ROTATIONS_TUNING",r[r.MEASUREMENT_OVERHEAD=4]="MEASUREMENT_OVERHEAD",r))(Metrics$1||{});class NeuroEvolutionarySolver{constructor(e){l(this,"measurer");l(this,"inputs");l(this,"initialState");l(this,"actions");l(this,"neuroGeneticAlgorithm");l(this,"citizens");l(this,"aborted");l(this,"armageddonCounter");this.aborted=!1,this.measurer=new ProcedureMeasurer,this.armageddonCounter=0,this.neuroGeneticAlgorithm=new NeuroGeneticAlgorithm(NeuroEvolutionaryConfig.geneticData.mutationRate,NeuroEvolutionaryConfig.geneticData.populationPerGeneration),this.initialState=e.clone(),this.inputs=e.getConfiguration().length,this.actions=[],getAllSides().map(t=>[!0,!1].map(s=>{this.actions.push({side:t,counterClockwiseDirection:s,layer:0})})),this.citizens=this.createNewPopulationFromScratch()}async findSolution(){return this.measurer.start(),new Promise((e,t)=>{for(;;){if(this.aborted)return t();for(let s of this.citizens)if(this.runCitizen(s))return e(this.createSolution(s));if(this.neuroGeneticAlgorithm.getGenerationsCounter()>NeuroEvolutionaryConfig.geneticData.armageddonThreshold){++this.armageddonCounter;const s=this.citizens.reduce((o,n)=>Math.max(this.calculateCitizenScore(n.cube),o),0);console.log(`armageddon. best score from generation: ${s}`),this.citizens=this.createNewPopulationFromScratch()}else this.citizens=this.createNewPopulationFromPreviousOne()}})}abort(){this.aborted=!0}createNewPopulationFromScratch(){return this.neuroGeneticAlgorithm=new NeuroGeneticAlgorithm(NeuroEvolutionaryConfig.geneticData.mutationRate,NeuroEvolutionaryConfig.geneticData.populationPerGeneration),this.actions.sort(()=>Math.random()*2-1),Array.from(new Array(NeuroEvolutionaryConfig.geneticData.populationPerGeneration)).map(()=>{const e=new NeuralNetwork({inputs:this.inputs,hiddenNeurons:NeuroEvolutionaryConfig.neuralNetworkData.hiddenNeurons,outputs:this.actions.length,bias:Math.random()*2-1});return{genes:e.getWeights(),neuralNetwork:e,cube:this.initialState.clone(),moves:[]}})}createNewPopulationFromPreviousOne(){return this.neuroGeneticAlgorithm.createNextGeneration(this.citizens.map(e=>({genes:e.genes,score:this.calculateCitizenScore(e.cube)}))).map(e=>{const t=new NeuralNetwork({inputs:this.inputs,hiddenNeurons:NeuroEvolutionaryConfig.neuralNetworkData.hiddenNeurons,outputs:this.actions.length,bias:Math.random()*2-1},e.genes);return{genes:e.genes,neuralNetwork:t,cube:this.initialState.clone(),moves:[]}})}runCitizen(e){return Array.from(new Array(NeuroEvolutionaryConfig.neuralNetworkData.iterations)).reduce(t=>t||this.measurer.add(Metrics$1[1],()=>{let o=e.neuralNetwork.doTheMagic(e.cube.getConfiguration().split("").map(n=>mapStringInitialToColor(n))).reduce((n,u,c)=>((n.index===-1||u>n.value)&&(n.value=u,n.index=c),n),{index:-1,value:0});if(o.value>.5){const n=this.actions[o.index];if(e.cube=e.cube.rotateFace(n),e.moves.push(n),e.cube.isSolved())return!0}return!1}),!1)}calculateCitizenScore(e){return this.measurer.add(Metrics$1[2],()=>{const t=e.getConfiguration(),s=this.buildSolvedCubeFromCenterCubelets(e).getConfiguration();return t.split("").filter((o,n)=>o===s[n]).length})}createSolution(e){const t=this.measurer.add(Metrics$1[3],()=>new RotationsTuner().tune(e.moves));return this.measurer.finish(),{rotations:t,totalTime:this.measurer.getTotalTime(),data:{armageddonCounter:this.armageddonCounter,genes:e.genes,neuralNetworkWeights:e.neuralNetwork.getWeights(),metrics:this.measurer.getData({notMeasuredLabel:Metrics$1[0],measurementOverheadLabel:Metrics$1[4]}),generations:this.neuroGeneticAlgorithm.getGenerationsCounter()}}}buildSolvedCubeFromCenterCubelets(e){const t=e.getAllColorlessCubelets().filter(o=>o.stickers.length===1).map(o=>o.stickers[0].id),s=new Map;return getAllSides().forEach((o,n)=>{s.set(o,e.getColorOfIndex(t[n]))}),new RubiksCube({colorMap:s,dimension:this.initialState.getDimension()})}}class GoodEdgesStep{constructor(e){l(this,"goalState");l(this,"edgesIndexes",new RubiksCube({dimension:3}).getAllColorlessCubelets().filter(e=>e.stickers.length===2).flatMap(e=>e.stickers.map(t=>t.id)));this.goalState=e}getAllowedMoves(e){return new HumanTranslator().convertStringToFaceRotations("L R F B U D L' R' F' B' U' D'").filter(s=>e.length>0?!rotationsCancel(s[0],e[0]):!0)}calculateDistanceToGoal(e){const t=e.getConfiguration();return this.edgesIndexes.filter(s=>t[s]!==this.goalState.getConfiguration()[s]).length===0}}var Metrics=(r=>(r[r.ADD_CANDIDATE=0]="ADD_CANDIDATE",r[r.POP_CANDIDATE=1]="POP_CANDIDATE",r[r.CHECK_SOLUTION=2]="CHECK_SOLUTION",r[r.BREATHING_TIME=3]="BREATHING_TIME",r[r.HASH_CALCULATION=4]="HASH_CALCULATION",r[r.VISISTED_LIST_CHECK=5]="VISISTED_LIST_CHECK",r[r.ADD_TO_VISISTED_LIST_CHECK=6]="ADD_TO_VISISTED_LIST_CHECK",r[r.PERFORM_ROTATION=7]="PERFORM_ROTATION",r[r.NOT_MEASURED=8]="NOT_MEASURED",r))(Metrics||{});class ThistlethwaiteSolver{constructor(e){l(this,"measurer");l(this,"initialState");l(this,"goalState");l(this,"currentMaxDepth");l(this,"visitedNodes");l(this,"aborted");l(this,"currentStep");l(this,"stepsSolvers");l(this,"currentSolver");this.measurer=new ProcedureMeasurer,this.visitedNodes=0,this.aborted=!1,this.goalState=this.buildSolvedCubeFromCentersCubelets(e),this.stepsSolvers=new Map,this.stepsSolvers.set(0,new GoodEdgesStep(this.goalState)),this.currentStep=0,this.currentSolver=this.stepsSolvers.get(this.currentStep),this.currentMaxDepth=1,this.initialState={cube:e,rotations:[],parent:void 0}}abort(){this.aborted=!0}async findSolution(){return new Promise((e,t)=>{for(this.measurer.start();!this.aborted;){const s=this.beginSearch(this.initialState,0);if(s)return this.measurer.finish(),e(this.createSolution(s));++this.currentMaxDepth,console.log(this.currentMaxDepth)}t(Error("Aborted"))})}beginSearch(e,t){if(++this.visitedNodes,!this.aborted&&t<=this.currentMaxDepth){if(this.solvesCurrentStep(e))return console.log("indexes are found"),e;const s=this.applyRotations(e);for(let o of s){const n=this.beginSearch(o,t+1);if(n)return n}}}solvesCurrentStep(e){return this.currentSolver.calculateDistanceToGoal(e.cube)}createSolution(e){const t=[];let s=e;for(;s&&s.rotations.length>0;)t.unshift(...s.rotations),s=s.parent;return{rotations:t,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:Metrics[8]}),visitedNodes:this.visitedNodes}}}applyRotations(e){const t=[];return this.currentSolver.getAllowedMoves(e.rotations).forEach(o=>{const n=o.reduce((u,c)=>u.rotateFace(c),e.cube);this.measurer.add(Metrics[0],()=>{t.push({cube:n,rotations:o,parent:e})})}),t}buildSolvedCubeFromCentersCubelets(e){const t=e.getAllCubelets().filter(o=>o.stickers.length===1),s=new Map;return t.forEach(o=>o.stickers.forEach(n=>{s.set(n.side,n.color),s.set(getOppositeSide(n.side),getOppositeColor(n.color))})),new RubiksCube({colorMap:s,dimension:e.getDimension()})}}class KeyboardInterpreter{readKeys(e,t){let s;switch(e.key.toLowerCase()){case"w":s=Sides.UP;break;case"a":s=Sides.LEFT;break;case"s":s=Sides.FRONT;break;case"d":s=Sides.RIGHT;break;case"f":s=Sides.BACK;break;case"x":s=Sides.DOWN;break}if(s!==void 0)return{side:s,counterClockwiseDirection:e.shiftKey,layer:t}}}class HumanSolver{constructor(e){l(this,"moves");l(this,"findSolutionResolve");l(this,"findSolutionReject");l(this,"cube");l(this,"startTime");l(this,"keyboardInterpreter");this.cube=e,this.moves=[],this.keyboardInterpreter=new KeyboardInterpreter}async findSolution(){return this.startTime=Date.now(),new Promise((e,t)=>{this.findSolutionResolve=e,this.findSolutionReject=t})}abort(){this.findSolutionReject()}async readKeys(e){if(this.cube.isSolved())return;const t=this.keyboardInterpreter.readKeys(e);if(t!==void 0)return this.moves.push(t),this.cube=this.cube.rotateFace(t),this.cube.isSolved()&&this.findSolutionResolve({rotations:this.moves,totalTime:Date.now()-this.startTime,data:{human:!0}}),t}}const WeightedAStarAlgorithmConfig={heuristicWeight:50},NeuroEvolutionaryConfig={geneticData:{mutationRate:.01,populationPerGeneration:150,armageddonThreshold:1500},neuralNetworkData:{hiddenNeurons:15,iterations:20}},GeneticAlgorithmConfig={populationPerGeneration:500,elitism:20,armageddonThreshold:50,numberOfInitialScrambleMovements:10},Configuration={metrics:{enabled:!1},world:{debug:!1,scrambleMoves:15,scrambleRotationDuration:150,cubesCircleRay:4.5,camera:{closeDistance:20,farDistance:55}},renderers:{translationDuration:500,rotationDuration:250,titleDistance:8.5,cubeSize:2.5},initiallySelectedCubeTypeIndex:1,cubeTypes:[{label:"2x2",dimension:2,instantiator:()=>new RubiksCube({dimension:2}),methods:[{key:"Human",instantiator:r=>new HumanSolver(new RubiksCube({clone:r})),checked:!1,info:"Use keys 'WASDFX' combined with 'shift' to rotate cube faces"},{key:"IDDFS",instantiator:r=>new InterativeDeepeningDepthFirstSearchSolver(new RubiksCube({clone:r})),checked:!1,info:"Interative-deepening depth-first-search. Brute force"},{key:"BFS",instantiator:r=>new BreadthFirstSearchSolver(new RubiksCube({clone:r})),checked:!1,info:"Breadth-first-search. Brute force"},{key:"IDA*",instantiator:r=>new InterativeDeepeningAStarSolver(new RubiksCube({clone:r})),checked:!0,info:"Interative-deepening A star. Uses number of misplaced stickers as heuristic."},{key:"WA*",instantiator:r=>new WeightedAStarSolver(new RubiksCube({clone:r})),checked:!0,info:`Weighted A star. No re-expansions. Uses number of misplaced stickers as heuristic and weights the heuristic (${WeightedAStarAlgorithmConfig.heuristicWeight} * h(x)) value.`},{key:"BiBFS",instantiator:r=>new BidirectionalBreadthFirstSearchSolver(new RubiksCube({clone:r})),checked:!0,info:"BiDirectional Breadth-first-search. Brute force."}]},{label:"3x3",dimension:3,instantiator:()=>new RubiksCube({dimension:3}),methods:[{key:"Human",instantiator:r=>new HumanSolver(new RubiksCube({clone:r})),checked:!1,info:"Use keys 'WASDFX' combined with 'shift' to rotate cube faces"},{key:"Thisttlethwait",instantiator:r=>new ThistlethwaiteSolver(new RubiksCube({clone:r})),checked:!0,info:`Neuro Evolutionary. Uses number of misplaced stickers as fitness function. Internal neurons: ${NeuroEvolutionaryConfig.neuralNetworkData.hiddenNeurons}. Population: ${NeuroEvolutionaryConfig.geneticData.populationPerGeneration}. No elitism`},{key:"NE",instantiator:r=>new NeuroEvolutionarySolver(new RubiksCube({clone:r})),checked:!1,info:`Neuro Evolutionary. Uses number of misplaced stickers as fitness function. Internal neurons: ${NeuroEvolutionaryConfig.neuralNetworkData.hiddenNeurons}. Population: ${NeuroEvolutionaryConfig.geneticData.populationPerGeneration}. No elitism`},{key:"GA",instantiator:r=>new GeneticAlgorithmSolver(new RubiksCube({clone:r})),checked:!1,info:`Predefined macro movements combined with genetic algorithm. Uses number of misplaced stickers as fitness function. Population: ${GeneticAlgorithmConfig.populationPerGeneration}. Elitism ${GeneticAlgorithmConfig.elitism}. Asexual reproduction`}]},{label:"4x4",dimension:4,instantiator:()=>new RubiksCube({dimension:4}),methods:[{key:"Human",instantiator:r=>new HumanSolver(new RubiksCube({clone:r})),checked:!1,info:"Use keys 'WASDFX' combined with 'shift' and numbers to rotate cube faces"}]},{label:"5x5",dimension:5,instantiator:()=>new RubiksCube({dimension:5}),methods:[{key:"Human",instantiator:r=>new HumanSolver(new RubiksCube({clone:r})),checked:!1,info:"Use keys 'WASDFX' combined with 'shift' and numbers to rotate cube faces"}]}]},solverMethodFinder=r=>{for(let e of Configuration.cubeTypes)if(e.label.toLowerCase()===r.label.toLowerCase()){for(let t of e.methods)if(t.key.toLowerCase()===r.solverTag.toLowerCase())return t;return}};let solver;self.onmessage=async r=>{if(r.data.abort)solver.abort();else{const e=r.data.solverTag.toLowerCase(),t=solverMethodFinder(r.data);if(e&&t)if(r.data.cube)try{solver=t.instantiator(r.data.cube);const s=await solver.findSolution();self.postMessage({solution:JSON.stringify(s),solverKey:e})}catch(s){console.log(`Solver '${r.data.label}.${e}' aborted`,s),self.postMessage({error:`Solver '${r.data.label}.${e}' aborted`,solverTag:r.data.solverTag})}else if(r.data.keyboardEvent){if(solver instanceof HumanSolver){const s=await solver.readKeys(r.data.keyboardEvent);s!==void 0&&self.postMessage({faceRotation:s,solverKey:e})}}else self.postMessage({error:`Command for '${r.data}' not found`,solverTag:r.data.solverTag});else self.postMessage({error:`Solver '${r.data.solverTag}' not found`,solverTag:r.data.solverTag})}}})();
