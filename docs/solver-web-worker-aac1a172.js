var De=Object.defineProperty;var we=(o,R,F)=>R in o?De(o,R,{enumerable:!0,configurable:!0,writable:!0,value:F}):o[R]=F;var u=(o,R,F)=>(we(o,typeof R!="symbol"?R+"":R,F),F);(function(){"use strict";var o=(s=>(s[s.UP=0]="UP",s[s.LEFT=1]="LEFT",s[s.FRONT=2]="FRONT",s[s.RIGHT=3]="RIGHT",s[s.BACK=4]="BACK",s[s.DOWN=5]="DOWN",s))(o||{});const R=()=>Object.keys(o).filter(s=>!isNaN(Number(s))).map(s=>Number(s)),F=s=>Object.keys(o).filter(e=>!isNaN(Number(e))).map(e=>Number(e)).filter(e=>e!==s&&e!==v(s)),v=s=>{switch(s){case 0:return 5;case 5:return 0;case 1:return 3;case 3:return 1;case 2:return 4;case 4:return 2}};var k=(s=>(s[s.YELLOW=0]="YELLOW",s[s.ORANGE=1]="ORANGE",s[s.BLUE=2]="BLUE",s[s.RED=3]="RED",s[s.GREEN=4]="GREEN",s[s.WHITE=5]="WHITE",s))(k||{});const K=s=>{switch(s){case 2:return 4;case 4:return 2;case 3:return 1;case 1:return 3;case 0:return 5;case 5:return 0}},U=new Map;U.set(0,"y"),U.set(1,"o"),U.set(2,"b"),U.set(3,"r"),U.set(4,"g"),U.set(5,"w");const ue=s=>U.get(s),P=new Map;P.set("y",0),P.set("o",1),P.set("b",2),P.set("r",3),P.set("g",4),P.set("w",5);const te=s=>P.get(s),Y=class{constructor(e){u(this,"dimension");u(this,"stickers");u(this,"cubeletCounter");this.dimension=e,this.stickers=[],this.cubeletCounter=0}create(){if(Y.cubeletsCreatorMap.has(this.dimension))return Y.cubeletsCreatorMap.get(this.dimension);{let e=0;R().map(d=>{for(let m=0;m<this.dimension;++m)for(let E=0;E<this.dimension;++E)this.stickers.push({side:d,x:E,y:m,id:e++})});const i=this.extractCenters(),t=this.extractCorners(),n=this.extractEdges(),r=[...t,...n,...i];return Y.cubeletsCreatorMap.set(this.dimension,r),r}}cubeletsMerger(e){const i={stickers:[],id:++this.cubeletCounter};return e.forEach(t=>{this.stickers.forEach((n,r,d)=>{n.side===t.side&&t.x===n.x&&t.y===n.y&&i.stickers.push(...d.splice(r,1))})}),i}extractEdges(){const e=this.dimension-1,i=[];for(let t=1;t<this.dimension-1;++t)i.push(this.cubeletsMerger([{side:o.FRONT,x:0,y:t},{side:o.LEFT,x:e,y:t}])),i.push(this.cubeletsMerger([{side:o.FRONT,x:e,y:t},{side:o.RIGHT,x:0,y:t}])),i.push(this.cubeletsMerger([{side:o.FRONT,x:t,y:0},{side:o.UP,x:t,y:e}])),i.push(this.cubeletsMerger([{side:o.FRONT,x:t,y:e},{side:o.DOWN,x:t,y:0}])),i.push(this.cubeletsMerger([{side:o.BACK,x:e,y:t},{side:o.LEFT,x:0,y:t}])),i.push(this.cubeletsMerger([{side:o.BACK,x:0,y:t},{side:o.RIGHT,x:e,y:t}])),i.push(this.cubeletsMerger([{side:o.BACK,x:t,y:0},{side:o.UP,x:e-t,y:0}])),i.push(this.cubeletsMerger([{side:o.BACK,x:t,y:e},{side:o.DOWN,x:e-t,y:e}])),i.push(this.cubeletsMerger([{side:o.RIGHT,x:t,y:0},{side:o.UP,x:e,y:e-t}])),i.push(this.cubeletsMerger([{side:o.RIGHT,x:t,y:e},{side:o.DOWN,x:e,y:t}])),i.push(this.cubeletsMerger([{side:o.LEFT,x:t,y:0},{side:o.UP,x:0,y:t}])),i.push(this.cubeletsMerger([{side:o.LEFT,x:t,y:e},{side:o.DOWN,x:0,y:e-t}]));return i}extractCenters(){const e=this.dimension-1,i=[];return this.stickers.filter(t=>t.x!==0&&t.x!==e&&t.y!==0&&t.y!==e).forEach(t=>{i.push({stickers:[t],id:++this.cubeletCounter})}),i}extractCorners(){const e=[],i=this.dimension-1;return e.push(this.cubeletsMerger([{side:o.FRONT,x:0,y:0},{side:o.UP,x:0,y:i},{side:o.LEFT,x:i,y:0}])),e.push(this.cubeletsMerger([{side:o.FRONT,x:i,y:0},{side:o.UP,x:i,y:i},{side:o.RIGHT,x:0,y:0}])),e.push(this.cubeletsMerger([{side:o.FRONT,x:0,y:i},{side:o.DOWN,x:0,y:0},{side:o.LEFT,x:i,y:i}])),e.push(this.cubeletsMerger([{side:o.FRONT,x:i,y:i},{side:o.DOWN,x:i,y:0},{side:o.RIGHT,x:0,y:i}])),e.push(this.cubeletsMerger([{side:o.BACK,x:0,y:0},{side:o.UP,x:i,y:0},{side:o.RIGHT,x:i,y:0}])),e.push(this.cubeletsMerger([{side:o.BACK,x:i,y:0},{side:o.UP,x:0,y:0},{side:o.LEFT,x:0,y:0}])),e.push(this.cubeletsMerger([{side:o.BACK,x:0,y:i},{side:o.DOWN,x:i,y:i},{side:o.RIGHT,x:i,y:i}])),e.push(this.cubeletsMerger([{side:o.BACK,x:i,y:i},{side:o.DOWN,x:0,y:i},{side:o.LEFT,x:0,y:i}])),e}};let Z=Y;u(Z,"cubeletsCreatorMap",new Map);const X=class{constructor(e){u(this,"dimension");if(this.dimension=e,!X.faceRotatorMap.has(this.dimension)){const i=new Map;for(let t=0;t<this.dimension;++t){const n=this.createUpFaceClockwiseRotator(t),r=this.createLeftFaceClockwiseRotator(t),d=this.createFrontFaceClockwiseRotator(t),m=this.createRightFaceClockwiseRotator(t),E=this.createBackFaceClockwiseRotator(t),b=this.createDownFaceClockwiseRotator(t),I=new Map;I.set(o.UP,n.map(O=>this.faceStickerMapper(O))),I.set(o.LEFT,r.map(O=>this.faceStickerMapper(O))),I.set(o.FRONT,d.map(O=>this.faceStickerMapper(O))),I.set(o.RIGHT,m.map(O=>this.faceStickerMapper(O))),I.set(o.BACK,E.map(O=>this.faceStickerMapper(O))),I.set(o.DOWN,b.map(O=>this.faceStickerMapper(O))),i.set(t,I)}X.faceRotatorMap.set(this.dimension,i)}}rotate(e,i){const t=new f({clone:e.getConfiguration()}),n=[];return X.faceRotatorMap.get(this.dimension).get(i.layer||0).get(i.side).forEach(r=>{i.counterClockwiseDirection?n.push({index:r.source,color:e.getColorOfIndex(r.destination)}):n.push({index:r.destination,color:e.getColorOfIndex(r.source)})}),t.setColorsOfIndexes(n),t}idMapper(e){let i=e.side*this.dimension*this.dimension;return i+=this.dimension*e.y,i+=e.x,i}faceStickerMapper(e){return{source:this.idMapper(e.source),destination:this.idMapper(e.destination)}}createSideLidClockwiseRotator(e){const i=[];for(let t=0;t<this.dimension*this.dimension;++t){const n=t%this.dimension,r=Math.floor(t/this.dimension),d=this.dimension-1-r,m=n;i.push({source:{side:e,x:n,y:r},destination:{side:e,x:d,y:m}})}return i}createUpFaceClockwiseRotator(e){this.dimension-1;const i=[];e===0&&i.push(...this.createSideLidClockwiseRotator(o.UP));for(let t=0;t<this.dimension;++t)i.push({source:{side:o.FRONT,x:t,y:e},destination:{side:o.LEFT,x:t,y:e}}),i.push({source:{side:o.LEFT,x:t,y:e},destination:{side:o.BACK,x:t,y:e}}),i.push({source:{side:o.BACK,x:t,y:e},destination:{side:o.RIGHT,x:t,y:e}}),i.push({source:{side:o.RIGHT,x:t,y:e},destination:{side:o.FRONT,x:t,y:e}});return i}createLeftFaceClockwiseRotator(e){const i=this.dimension-1,t=[];e===0&&t.push(...this.createSideLidClockwiseRotator(o.LEFT));for(let n=0;n<this.dimension;++n)t.push({source:{side:o.FRONT,x:e,y:n},destination:{side:o.DOWN,x:e,y:n}}),t.push({source:{side:o.DOWN,x:e,y:n},destination:{side:o.BACK,x:i-e,y:i-n}}),t.push({source:{side:o.BACK,x:i-e,y:i-n},destination:{side:o.UP,x:e,y:n}}),t.push({source:{side:o.UP,x:e,y:n},destination:{side:o.FRONT,x:e,y:n}});return t}createFrontFaceClockwiseRotator(e){const i=this.dimension-1,t=[];e===0&&t.push(...this.createSideLidClockwiseRotator(o.FRONT));for(let n=0;n<this.dimension;++n)t.push({source:{side:o.UP,x:n,y:i-e},destination:{side:o.RIGHT,x:e,y:n}}),t.push({source:{side:o.RIGHT,x:e,y:n},destination:{side:o.DOWN,x:i-n,y:e}}),t.push({source:{side:o.DOWN,x:i-n,y:e},destination:{side:o.LEFT,x:i-e,y:i-n}}),t.push({source:{side:o.LEFT,x:i-e,y:i-n},destination:{side:o.UP,x:n,y:i-e}});return t}createRightFaceClockwiseRotator(e){const i=this.dimension-1,t=[];e===0&&t.push(...this.createSideLidClockwiseRotator(o.RIGHT));for(let n=0;n<this.dimension;++n)t.push({source:{side:o.UP,x:i-e,y:n},destination:{side:o.BACK,x:e,y:i-n}}),t.push({source:{side:o.BACK,x:e,y:i-n},destination:{side:o.DOWN,x:i-e,y:n}}),t.push({source:{side:o.DOWN,x:i-e,y:n},destination:{side:o.FRONT,x:i-e,y:n}}),t.push({source:{side:o.FRONT,x:i-e,y:n},destination:{side:o.UP,x:i-e,y:n}});return t}createBackFaceClockwiseRotator(e){const i=this.dimension-1,t=[];e===0&&t.push(...this.createSideLidClockwiseRotator(o.BACK));for(let n=0;n<this.dimension;++n)t.push({source:{side:o.LEFT,x:e,y:n},destination:{side:o.DOWN,x:n,y:i-e}}),t.push({source:{side:o.DOWN,x:n,y:i-e},destination:{side:o.RIGHT,x:i-e,y:i-n}}),t.push({source:{side:o.RIGHT,x:i-e,y:i-n},destination:{side:o.UP,x:i-n,y:e}}),t.push({source:{side:o.UP,x:i-n,y:e},destination:{side:o.LEFT,x:e,y:n}});return t}createDownFaceClockwiseRotator(e){const i=this.dimension-1,t=[];e===0&&t.push(...this.createSideLidClockwiseRotator(o.DOWN));for(let n=0;n<this.dimension;++n)t.push({source:{side:o.LEFT,x:n,y:i-e},destination:{side:o.FRONT,x:n,y:i-e}}),t.push({source:{side:o.FRONT,x:n,y:i-e},destination:{side:o.RIGHT,x:n,y:i-e}}),t.push({source:{side:o.RIGHT,x:n,y:i-e},destination:{side:o.BACK,x:n,y:i-e}}),t.push({source:{side:o.BACK,x:n,y:i-e},destination:{side:o.LEFT,x:n,y:i-e}});return t}};let J=X;u(J,"faceRotatorMap",new Map);const G=new Map;G.set(o.FRONT,k.BLUE),G.set(o.UP,k.YELLOW),G.set(o.RIGHT,k.RED),G.set(o.LEFT,k.ORANGE),G.set(o.BACK,k.GREEN),G.set(o.DOWN,k.WHITE);class f{constructor(e){u(this,"configuration");u(this,"dimension");u(this,"faceRotator");u(this,"colorlessCubelets");if(this.dimension=e==null?void 0:e.dimension,e!=null&&e.clone)this.dimension=Math.sqrt(e.clone.length/6),this.configuration=e.clone.slice();else{const i=this.dimension*this.dimension,t=(e==null?void 0:e.colorMap)||G,n=R();this.configuration="";for(let r=0;r<n.length;++r){const d=t.get(r),m=ue(d);this.configuration+=m.repeat(i)}}this.faceRotator=new J(this.dimension),this.colorlessCubelets=new Z(this.dimension).create()}clone(){return new f({clone:this.configuration})}getDimension(){return this.dimension}getConfiguration(){return this.configuration}getHash(){return this.configuration}isSolved(){const e=this.dimension*this.dimension,i=R(),t=Array.from(new Array(e));return i.every((n,r)=>t.every((d,m)=>this.configuration[r*e+m]===this.configuration[r*e]))}rotateFace(e){return this.faceRotator.rotate(this,e)}getAllCubelets(){return this.addColorToCubelets(this.colorlessCubelets)}getAllColorlessCubelets(){return this.colorlessCubelets}getSideOfIndex(e){const i=R().length;return e/i}getColorlessCubeletOfIndex(e){return this.colorlessCubelets.find(i=>i.stickers.some(t=>t.id===e))}getCubeletsBySides(...e){const i=this.colorlessCubelets.filter(t=>t.stickers.every(n=>e.includes(n.side)));return this.addColorToCubelets(i)}getCubeletsByColors(...e){const i=this.colorlessCubelets.filter(t=>t.stickers.every(n=>e.includes(te(this.configuration[n.id]))));return this.addColorToCubelets(i)}getColorOfIndex(e){return te(this.configuration[e])}setColorsOfIndexes(e){const i=this.configuration.split("");e.forEach(t=>{i[t.index]=ue(t.color)}),this.configuration=i.join("")}addColorToCubelets(e){return e.map(i=>({stickers:i.stickers.map(t=>({...t,color:te(this.configuration[t.id])}))}))}}var fe=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function me(s){return s&&s.__esModule&&Object.prototype.hasOwnProperty.call(s,"default")?s.default:s}var he=N;function N(){this._start=null,this._end=null,this.length=0}N.prototype.unShift=function(s){if(this._start===null)this._start=V(s),this._end=this._start;else{var e=this._start;this._start.previous=V(s),this._start=this._start.previous,this._start.next=e}this.length++},N.prototype.push=function(s){if(this._start===null)this._start=V(s),this._end=this._start;else{var e=this._end;this._end.next=V(s),this._end=this._end.next,this._end.previous=e}this.length++},N.prototype.add=function(s,e){if(s%1===0)if(s<=0)this.unShift(e);else if(s>=this.length)this.push(e);else{var i=se.call(this,s);if(i){var t=i.previous,n=i,r=V(e);r.previous=t,t.next=r,r.next=n,n.previous=r,this.length++}}},N.prototype.shift=function(){if(this._start){var s=this._start.data;return this._start.next===null?(this._end=null,this._start=null):(this._start=this._start.next,this._start.previous=null),this.length--,s}else return},N.prototype.pop=function(){if(this._end){var s=this._end.data;return this._end.previous===null?(this._end=null,this._start=null):(this._end=this._end.previous,this._end.next=null),this.length--,s}else return},N.prototype.remove=function(s){if(s===0)return this.shift();if(s===this.length-1)return this.pop();var e=se.call(this,s);if(e){var i=e.previous,t=e.next;i.next=t,t.previous=i,this.length--}else return},N.prototype.first=function(){if(this._start)return this._start.data},N.prototype.last=function(){if(this._end)return this._end.data},N.prototype.get=function(s){var e=se.call(this,s);if(e)return e.data},N.prototype.toString=function(){for(var s=this._start,e="",i=0;i<this.length;i++)typeof s.data=="object"?e+=JSON.stringify(s.data):e+=s.data,i!==this.length-1&&(e+=", "),s=s.next;return e};function V(s){return{data:s,previous:null,next:null}}function se(s){var e,i;if(s>=this.length||s<0||s%1!==0)e=null;else if(s<this.length/2)for(e=this._start,i=0;i<s;i++)e=e.next;else for(e=this._end,i=this.length-1;i>s;i--)e=e.previous;return e}class M{constructor(e=de.metrics.enabled){u(this,"map");u(this,"enabled");u(this,"measurerOverhead");u(this,"startTime");u(this,"totalTime");this.map=new Map,this.enabled=e,this.measurerOverhead=0}add(e,i){const t=performance.now();if(!this.enabled)return i();const n=i(),r=performance.now(),d=this.map.get(e)||{elapsedTime:0,calls:0,stack:"",stackSize:0};return d.elapsedTime+=r-t,++d.calls,this.map.set(e,d),this.measurerOverhead+=performance.now()-r,n}start(){this.startTime=performance.now()}finish(){this.startTime&&(this.totalTime=performance.now()-this.startTime)}getTotalTime(){return this.totalTime}getData(e){const i=[];if(this.totalTime){let t=0;Array.from(this.map.entries()).forEach(n=>{const[r,d]=n;t+=d.elapsedTime,i.push(this.createSummary(d.elapsedTime,d.calls,r))}),e!=null&&e.measurementOverheadLabel&&(i.push(this.createSummary(this.measurerOverhead,0,e.measurementOverheadLabel)),t+=this.measurerOverhead),e!=null&&e.notMeasuredLabel&&i.push(this.createSummary(this.totalTime-t,0,e.notMeasuredLabel))}return i}createSummary(e,i,t){const n=100*e/this.totalTime;return{label:t,totalTime:e,totalRelativeTime:Math.trunc(100*n)/100+"%",numOfCalls:i,avgTimePerCall:e*1/(i||1)}}}const y=(s,e)=>s.layer===e.layer&&s.side===e.side&&s.counterClockwiseDirection===e.counterClockwiseDirection,q=(s,e)=>s.layer===e.layer&&s.side===e.side&&s.counterClockwiseDirection!==e.counterClockwiseDirection;var A=(s=>(s[s.ADD_CANDIDATE=0]="ADD_CANDIDATE",s[s.POP_CANDIDATE=1]="POP_CANDIDATE",s[s.HASH_CALCULATION=2]="HASH_CALCULATION",s[s.VISISTED_LIST_CHECK=3]="VISISTED_LIST_CHECK",s[s.ADD_TO_VISISTED_LIST_CHECK=4]="ADD_TO_VISISTED_LIST_CHECK",s[s.PERFORM_ROTATION=5]="PERFORM_ROTATION",s[s.NOT_MEASURED=6]="NOT_MEASURED",s[s.MEASUREMENT_OVERHEAD=7]="MEASUREMENT_OVERHEAD",s))(A||{});class Te{constructor(e){u(this,"measurer");u(this,"forwardSearchToExploreList");u(this,"forwardSearchExploredMap");u(this,"reverseSearchToExploreList");u(this,"reverseSearchExploredMap");u(this,"actions");u(this,"iterations");u(this,"aborted");this.forwardSearchToExploreList=new he,this.reverseSearchToExploreList=new he,this.actions=[],this.iterations=0,this.measurer=new M,this.forwardSearchExploredMap=new Map,this.reverseSearchExploredMap=new Map,this.aborted=!1;const i={cube:e,rotation:void 0,parent:void 0};this.forwardSearchToExploreList.push(i);const t=[];[o.RIGHT,o.UP,o.FRONT].map(m=>[!0,!1].map(E=>{t.push(v(m)),this.actions.push({side:m,counterClockwiseDirection:E,layer:0})}));const n=e.getCubeletsBySides(...t)[0],d={cube:this.buildSolvedCubeFromCornerCubelet(n,e.getDimension()),rotation:void 0,parent:void 0};this.reverseSearchToExploreList.push(d)}abort(){this.aborted=!0}async findSolution(){return new Promise((e,i)=>{this.measurer.start();let t,n,r=0;for(;this.forwardSearchToExploreList.length>0&&this.reverseSearchToExploreList.length>0;){if(++this.iterations,this.aborted)return i();do t=this.measurer.add(A[1],()=>this.forwardSearchToExploreList.shift());while(this.measurer.add(A[3],()=>this.forwardSearchExploredMap.has(t.cube.getHash())));do n=this.measurer.add(A[1],()=>this.reverseSearchToExploreList.shift());while(this.measurer.add(A[3],()=>this.reverseSearchExploredMap.has(n.cube.getHash())));++r;let d=this.measurer.add(A[3],()=>this.forwardSearchExploredMap.get(n.cube.getHash()));if(d)return e(this.createSolution(d,n,r));if(d=this.measurer.add(A[3],()=>this.reverseSearchExploredMap.get(t.cube.getHash())),d)return e(this.createSolution(t,d,r));this.measurer.add(A[4],()=>this.forwardSearchExploredMap.set(t.cube.getHash(),t)),this.measurer.add(A[4],()=>this.reverseSearchExploredMap.set(n.cube.getHash(),n)),this.applyRotations(this.forwardSearchToExploreList,this.forwardSearchExploredMap,t),this.applyRotations(this.reverseSearchToExploreList,this.reverseSearchExploredMap,n)}return i()})}applyRotations(e,i,t){this.actions.forEach(n=>{if(t.rotation&&(q(t.rotation,n)||t.parent&&t.parent.rotation&&y(t.rotation,n)&&y(t.parent.rotation,n)))return;const r=this.measurer.add(A[5],()=>t.cube.rotateFace(n));this.measurer.add(A[3],()=>i.has(r.getHash()))||this.measurer.add(A[0],()=>{e.push({cube:r,rotation:n,parent:t})})})}createSolution(e,i,t){this.measurer.finish();const n=[];let r=e;for(;r&&r.rotation;)n.unshift(r.rotation),r=r.parent;for(r=i;r&&r.rotation;){const d={...r.rotation};d.counterClockwiseDirection=!d.counterClockwiseDirection,n.push(d),r=r.parent}return{rotations:n,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:A[6],measurementOverheadLabel:A[7]}),iterations:this.iterations,visitedNodes:t}}}buildSolvedCubeFromCornerCubelet(e,i){const t=new Map;return e.stickers.forEach(n=>{t.set(n.side,n.color),t.set(v(n.side),K(n.color))}),new f({colorMap:t,dimension:i})}}class Ce{constructor(e,i){u(this,"numberOfActions");u(this,"numOfGenes");u(this,"generationsCounter");u(this,"armageddonCounter");this.numberOfActions=e,this.numOfGenes=i,this.generationsCounter=0,this.armageddonCounter=0}createNextGeneration(e){if(++this.generationsCounter,!e)return this.createNewPopulationFromScratch();if(this.generationsCounter%w.armageddonThreshold===0)return console.log("Armageddon: "+ ++this.armageddonCounter),this.createNextGeneration();const i=e.sort((t,n)=>n.score-t.score).filter((t,n)=>n<w.elitism);return Array.from(new Array(w.populationPerGeneration)).map(()=>this.reproduceCitizens(i))}getArmageddonCounter(){return this.armageddonCounter}getGenerationsCounter(){return this.generationsCounter}pickOne(e,i){let t;do t=Math.floor(Math.random()*e.length);while(i.includes(t));return{chromosome:e[t],index:t}}createNewPopulationFromScratch(){return Array.from(new Array(w.populationPerGeneration)).map(()=>({genes:Array.from(new Array(this.numOfGenes)).map(()=>Math.floor(Math.random()*this.numberOfActions)),score:NaN}))}reproduceCitizens(e){const i=this.pickOne(e,[]),t=this.pickOne(e,[i.index]),n=Math.floor(i.chromosome.genes.length*.25+Math.random()*i.chromosome.genes.length*.5);return{genes:i.chromosome.genes.map((d,m)=>{let E=d;return m>n&&(E=t.chromosome.genes[m]),Math.random()<w.mutationRate&&(E=Math.floor(Math.random()*this.numberOfActions)),E}),score:NaN}}}var _=(s=>(s[s.NOT_MEASURED=0]="NOT_MEASURED",s[s.RUN_CITIZEN_ROTATIONS=1]="RUN_CITIZEN_ROTATIONS",s[s.CALCULATE_CITIZEN_SCORE=2]="CALCULATE_CITIZEN_SCORE",s[s.APPLYING_ROTATIONS=3]="APPLYING_ROTATIONS",s[s.CREATE_NEXT_GENERATION=4]="CREATE_NEXT_GENERATION",s[s.COMPUTE_GENE=5]="COMPUTE_GENE",s[s.AGGREGATE_CURRENT_GENERATION=6]="AGGREGATE_CURRENT_GENERATION",s[s.CHECK_SOLUTION=7]="CHECK_SOLUTION",s[s.MEASUREMENT_OVERHEAD=8]="MEASUREMENT_OVERHEAD",s))(_||{});class Ee{constructor(e){u(this,"measurer");u(this,"initialState");u(this,"goalStateHash");u(this,"geneticAlgorithm");u(this,"citizens");u(this,"aborted");u(this,"actions");this.measurer=new M,this.initialState=e.clone(),this.aborted=!1,this.actions=[];const i=e.getCubeletsBySides(o.BACK,o.LEFT,o.DOWN)[0],t=this.buildSolvedPocketCubeFromCornerCubelet(i);this.goalStateHash=t.getHash(),[o.FRONT,o.UP,o.RIGHT].map(n=>[!0,!1].map(r=>{this.actions.push({side:n,counterClockwiseDirection:r,layer:0})})),this.geneticAlgorithm=new Ce(this.actions.length,w.maxNumOfRotations),this.citizens=this.geneticAlgorithm.createNextGeneration()}async findSolution(){return this.measurer.start(),new Promise((e,i)=>{for(;;){if(this.aborted)return i();const t=[];for(let n of this.citizens){const r=this.runCitizen(n);if(r.score===this.goalStateHash.length)return e(this.createSolution(r));this.measurer.add(_[6],()=>t.push(r))}this.citizens=this.measurer.add(_[4],()=>this.geneticAlgorithm.createNextGeneration(t))}})}abort(){this.aborted=!0}runCitizen(e){let i=this.initialState.clone();return e.genes.reduce((t,n)=>(this.measurer.add(_[7],()=>t.score===this.goalStateHash.length)||(i=this.measurer.add(_[3],()=>i.rotateFace(this.actions[n])),this.measurer.add(_[5],()=>t.genes.push(n)),t.score=this.measurer.add(_[2],()=>this.calculateCitizenScore(i))),t),{score:0,genes:[]})}calculateCitizenScore(e){return e.getConfiguration().split("").filter((t,n)=>t===this.goalStateHash[n]).length}createSolution(e){const i=e.genes.map(t=>this.actions[t]);return this.measurer.finish(),{rotations:i,totalTime:this.measurer.getTotalTime(),data:{armageddonCounter:this.geneticAlgorithm.getArmageddonCounter(),generations:this.geneticAlgorithm.getGenerationsCounter(),metrics:this.measurer.getData({notMeasuredLabel:_[0],measurementOverheadLabel:_[8]})}}}buildSolvedPocketCubeFromCornerCubelet(e){const i=new Map;return e.stickers.forEach(t=>{i.set(t.side,t.color),i.set(v(t.side),K(t.color))}),new f({colorMap:i,dimension:this.initialState.getDimension()})}}var z=(s=>(s[s.ADD_CANDIDATE=0]="ADD_CANDIDATE",s[s.POP_CANDIDATE=1]="POP_CANDIDATE",s[s.CHECK_SOLUTION=2]="CHECK_SOLUTION",s[s.BREATHING_TIME=3]="BREATHING_TIME",s[s.HASH_CALCULATION=4]="HASH_CALCULATION",s[s.VISISTED_LIST_CHECK=5]="VISISTED_LIST_CHECK",s[s.ADD_TO_VISISTED_LIST_CHECK=6]="ADD_TO_VISISTED_LIST_CHECK",s[s.PERFORM_ROTATION=7]="PERFORM_ROTATION",s[s.NOT_MEASURED=8]="NOT_MEASURED",s[s.CYCLE_AVOIDANCE_CHECK=9]="CYCLE_AVOIDANCE_CHECK",s))(z||{});class ge{constructor(e){u(this,"measurer");u(this,"actions");u(this,"goalStateHash");u(this,"root");u(this,"numberOfStickersMovedInOneTwist");u(this,"iterations");u(this,"minBoundGrow",1.25);u(this,"currentPath");u(this,"bound");u(this,"visitedNodes");u(this,"aborted");this.iterations=[],this.measurer=new M,this.currentPath=[],this.visitedNodes=0,this.aborted=!1,this.actions=[],[o.FRONT,o.UP,o.RIGHT].map(r=>[!0,!1].map(d=>{this.actions.push({side:r,counterClockwiseDirection:d,layer:0})}));const i=e.getCubeletsBySides(o.BACK,o.LEFT,o.DOWN)[0],t=this.buildSolvedPocketCubeFromCornerCubelet(i,e.getDimension());this.goalStateHash=t.getHash();const n=e.getDimension();this.numberOfStickersMovedInOneTwist=n*n+n*F(o.UP).length,this.bound=Math.ceil(this.calculateDistanceToFinalState(e)),this.root={cube:e,rotation:void 0,parent:void 0}}abort(){this.aborted=!0}async findSolution(){return new Promise((e,i)=>{for(this.measurer.start();!this.aborted;){this.currentPath=[this.root.cube.getHash()];const t=this.search(this.root,0);if(t.solution)return e(this.createSolution(t.solution));if(t.aborted)break;this.iterations.push({visitedNodes:this.visitedNodes,bound:this.bound}),this.bound=Math.max(t.cost,this.bound+this.minBoundGrow),this.visitedNodes=0}i(Error("Aborted"))})}search(e,i){if(++this.visitedNodes,this.aborted)return{aborted:!0};let t=this.calculateDistanceToFinalState(e.cube);if(e.cube.isSolved())return{solution:e};let n=1/0;const r=this.applyRotations(e);for(let d of r){const m=i+t;if(m>this.bound)return{cost:m};const E=d.cube.getHash();if(this.measurer.add(z[9],()=>this.currentPath.every(b=>b!==E))){this.currentPath.push(E);const b=this.search(d,i+1);if(b.solution||b.aborted)return b;t=Math.min(t,b.cost-1),n=Math.min(b.cost,n),this.currentPath.pop()}}return{cost:n}}createSolution(e){this.measurer.finish();const i=[];let t=e;for(;t&&t.rotation;)i.unshift(t.rotation),t=t.parent;return{rotations:i,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:z[8]}),visitedNodes:this.iterations.reduce((n,r)=>n+r.visitedNodes,0),iterations:this.iterations}}}applyRotations(e){const i=[];return this.actions.forEach(t=>{if(e.rotation&&(q(e.rotation,t)||e.parent&&e.parent.rotation&&y(e.rotation,t)&&y(e.parent.rotation,t)))return;const n=this.measurer.add(z[7],()=>e.cube.rotateFace(t));this.measurer.add(z[0],()=>{i.push({cube:n,rotation:t,parent:e})})}),i}calculateDistanceToFinalState(e){return e.getConfiguration().split("").filter((t,n)=>t!==this.goalStateHash[n]).length/this.numberOfStickersMovedInOneTwist}buildSolvedPocketCubeFromCornerCubelet(e,i){const t=new Map;return e.stickers.forEach(n=>{t.set(n.side,n.color),t.set(v(n.side),K(n.color))}),new f({colorMap:t,dimension:i})}}var Q=(s=>(s[s.ADD_CANDIDATE=0]="ADD_CANDIDATE",s[s.POP_CANDIDATE=1]="POP_CANDIDATE",s[s.CHECK_SOLUTION=2]="CHECK_SOLUTION",s[s.BREATHING_TIME=3]="BREATHING_TIME",s[s.HASH_CALCULATION=4]="HASH_CALCULATION",s[s.VISISTED_LIST_CHECK=5]="VISISTED_LIST_CHECK",s[s.ADD_TO_VISISTED_LIST_CHECK=6]="ADD_TO_VISISTED_LIST_CHECK",s[s.PERFORM_ROTATION=7]="PERFORM_ROTATION",s[s.NOT_MEASURED=8]="NOT_MEASURED",s))(Q||{});class Se{constructor(e){u(this,"measurer");u(this,"actions");u(this,"root");u(this,"iterations");u(this,"currentMaxDepth");u(this,"visitedNodes");u(this,"aborted");this.measurer=new M,this.iterations=[],this.visitedNodes=0,this.aborted=!1,this.actions=this.createActions();const i=e.getCubeletsBySides(o.BACK,o.LEFT,o.DOWN)[0],t=this.buildSolvedPocketCubeFromCornerCubelet(i,e.getDimension());this.currentMaxDepth=this.calculateDistanceToFinalState(e,t.getConfiguration()),this.root={cube:e,rotation:void 0,parent:void 0}}abort(){this.aborted=!0}async findSolution(){return new Promise((e,i)=>{for(this.measurer.start();!this.aborted;){const t=this.beginSearch(this.root,0);if(t)return this.measurer.finish(),e(this.createSolution(t));this.iterations.push({visitedNodes:this.visitedNodes,bound:this.currentMaxDepth}),this.visitedNodes=0,++this.currentMaxDepth}i(Error("Aborted"))})}beginSearch(e,i){if(++this.visitedNodes,!this.aborted){if(i<this.currentMaxDepth){const t=this.applyRotations(e);for(let n of t){const r=this.beginSearch(n,i+1);if(r)return r}}else if(i===this.currentMaxDepth&&e.cube.isSolved())return e}}createActions(){const e=[];return[o.FRONT,o.UP,o.RIGHT].map(i=>[!0,!1].map(t=>{e.push({side:i,counterClockwiseDirection:t,layer:0})})),e}createSolution(e){const i=[];let t=e;for(;t&&t.rotation;)i.unshift(t.rotation),t=t.parent;return{rotations:i,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:Q[8]}),visitedNodes:this.iterations.reduce((n,r)=>n+r.visitedNodes,0),iterations:this.iterations}}}applyRotations(e){const i=[];return this.actions.forEach(t=>{if(e.rotation&&(q(e.rotation,t)||e.parent&&e.parent.rotation&&y(e.rotation,t)&&y(e.parent.rotation,t)))return;const n=this.measurer.add(Q[7],()=>e.cube.rotateFace(t));this.measurer.add(Q[0],()=>{i.push({cube:n,rotation:t,parent:e})})}),i}calculateDistanceToFinalState(e,i){const t=e.getDimension()*e.getDimension()+e.getDimension()*4,n=e.getConfiguration();return Math.ceil(n.split("").filter((r,d)=>r!==i[d]).length/t)}buildSolvedPocketCubeFromCornerCubelet(e,i){const t=new Map;return e.stickers.forEach(n=>{t.set(n.side,n.color),t.set(v(n.side),K(n.color))}),new f({colorMap:t,dimension:i})}}class le{constructor(e){u(this,"maxSuccessPerIteration",x.maxSuccessPerIteration);u(this,"temperatureDecreaseRate",x.temperatureDecreaseRate);u(this,"numOfRotations",x.numOfRotations);u(this,"population",x.population);u(this,"numOfActions");u(this,"temperature",x.initialTemperature);u(this,"lastResult");u(this,"successCounter",0);u(this,"generationCounter",0);this.numOfActions=e}createNextGeneration(e){if(++this.generationCounter,!e)return this.createNewPopulationFromScratch();const i=e.sort((n,r)=>r.score-n.score)[0];return this.lastResult?i.score-this.lastResult.score>0?(++this.successCounter,this.successCounter>this.maxSuccessPerIteration&&this.adjustTemperature(),this.disturbCandidate(i)):this.disturbCandidate(this.lastResult):this.disturbCandidate(i)}getGenerationCounter(){return this.generationCounter}createNewPopulationFromScratch(){return Array.from(new Array(this.population)).map(()=>({actions:Array.from(new Array(this.numOfRotations)).map(()=>this.createAction()),score:NaN}))}disturbCandidate(e){return this.lastResult=e,Array.from(Array(this.population-1)).map(()=>({actions:e.actions.map(t=>Math.random()<this.temperature?this.createAction():t),score:NaN})).concat(e)}createAction(){return Math.floor(Math.random()*this.numOfActions)}adjustTemperature(){this.temperature*=this.temperatureDecreaseRate,this.successCounter=0}}var D=(s=>(s[s.NOT_MEASURED=0]="NOT_MEASURED",s[s.RUN_CANDIDATE_ROTATIONS=1]="RUN_CANDIDATE_ROTATIONS",s[s.CALCULATE_CITIZEN_SCORE=2]="CALCULATE_CITIZEN_SCORE",s[s.APPLYING_ROTATIONS=3]="APPLYING_ROTATIONS",s[s.CREATE_NEXT_GENERATION=4]="CREATE_NEXT_GENERATION",s[s.COMPUTE_ROTATION=5]="COMPUTE_ROTATION",s[s.AGGREGATE_CURRENT_GENERATION=6]="AGGREGATE_CURRENT_GENERATION",s[s.CHECK_SOLUTION=7]="CHECK_SOLUTION",s[s.MEASUREMENT_OVERHEAD=8]="MEASUREMENT_OVERHEAD",s))(D||{});class Ae{constructor(e){u(this,"measurer");u(this,"initialState");u(this,"goalStateHash");u(this,"simulatedAnnealing");u(this,"candidates");u(this,"aborted");u(this,"actions");u(this,"restartCounter",0);u(this,"iterations",0);this.measurer=new M,this.initialState=e.clone(),this.aborted=!1,this.actions=[];const i=e.getCubeletsBySides(o.BACK,o.LEFT,o.DOWN)[0],t=this.buildSolvedPocketCubeFromCornerCubelet(i);this.goalStateHash=t.getHash(),[o.FRONT,o.UP,o.RIGHT].map(n=>[!0,!1].map(r=>{this.actions.push({side:n,counterClockwiseDirection:r,layer:0})})),this.simulatedAnnealing=new le(this.actions.length),this.candidates=this.simulatedAnnealing.createNextGeneration()}async findSolution(){return this.measurer.start(),new Promise((e,i)=>{for(;;){if(++this.iterations,this.aborted)return i();this.simulatedAnnealing.getGenerationCounter()>x.restartThreshold&&(++this.restartCounter,console.log("Restart: "+this.restartCounter),this.simulatedAnnealing=new le(this.actions.length),this.candidates=this.simulatedAnnealing.createNextGeneration());const t=[];for(let n of this.candidates){const r=this.runCitizen(n);if(r.score===this.goalStateHash.length)return e(this.createSolution(r));this.measurer.add(D[6],()=>t.push(r))}this.candidates=this.measurer.add(D[4],()=>this.simulatedAnnealing.createNextGeneration(t))}})}abort(){this.aborted=!0}runCitizen(e){let i=this.initialState.clone();return e.actions.reduce((t,n)=>(this.measurer.add(D[7],()=>t.score===this.goalStateHash.length)||(i=this.measurer.add(D[3],()=>i.rotateFace(this.actions[n])),this.measurer.add(D[5],()=>t.actions.push(n)),t.score=this.measurer.add(D[2],()=>this.calculateCitizenScore(i))),t),{score:0,actions:[]})}calculateCitizenScore(e){return e.getConfiguration().split("").filter((t,n)=>t===this.goalStateHash[n]).length}createSolution(e){const i=e.actions.map(t=>this.actions[t]);return this.measurer.finish(),{rotations:i,totalTime:this.measurer.getTotalTime(),data:{restartCounter:this.restartCounter,iterations:this.iterations,metrics:this.measurer.getData({notMeasuredLabel:D[0],measurementOverheadLabel:D[8]})}}}buildSolvedPocketCubeFromCornerCubelet(e){const i=new Map;return e.stickers.forEach(t=>{i.set(t.side,t.color),i.set(v(t.side),K(t.color))}),new f({colorMap:i,dimension:this.initialState.getDimension()})}}var ie={},Oe={get exports(){return ie},set exports(s){ie=s}},ne={},be={get exports(){return ne},set exports(s){ne=s}};(function(s,e){(function(){var i,t,n,r,d,m,E,b,I,O,ce,pe,re,ee,W;n=Math.floor,O=Math.min,t=function(a,h){return a<h?-1:a>h?1:0},I=function(a,h,l,c,T){var p;if(l==null&&(l=0),T==null&&(T=t),l<0)throw new Error("lo must be non-negative");for(c==null&&(c=a.length);l<c;)p=n((l+c)/2),T(h,a[p])<0?c=p:l=p+1;return[].splice.apply(a,[l,l-l].concat(h)),h},m=function(a,h,l){return l==null&&(l=t),a.push(h),ee(a,0,a.length-1,l)},d=function(a,h){var l,c;return h==null&&(h=t),l=a.pop(),a.length?(c=a[0],a[0]=l,W(a,0,h)):c=l,c},b=function(a,h,l){var c;return l==null&&(l=t),c=a[0],a[0]=h,W(a,0,l),c},E=function(a,h,l){var c;return l==null&&(l=t),a.length&&l(a[0],h)<0&&(c=[a[0],h],h=c[0],a[0]=c[1],W(a,0,l)),h},r=function(a,h){var l,c,T,p,C,S;for(h==null&&(h=t),p=function(){S=[];for(var L=0,H=n(a.length/2);0<=H?L<H:L>H;0<=H?L++:L--)S.push(L);return S}.apply(this).reverse(),C=[],c=0,T=p.length;c<T;c++)l=p[c],C.push(W(a,l,h));return C},re=function(a,h,l){var c;if(l==null&&(l=t),c=a.indexOf(h),c!==-1)return ee(a,0,c,l),W(a,c,l)},ce=function(a,h,l){var c,T,p,C,S;if(l==null&&(l=t),T=a.slice(0,h),!T.length)return T;for(r(T,l),S=a.slice(h),p=0,C=S.length;p<C;p++)c=S[p],E(T,c,l);return T.sort(l).reverse()},pe=function(a,h,l){var c,T,p,C,S,L,H,j,ae;if(l==null&&(l=t),h*10<=a.length){if(p=a.slice(0,h).sort(l),!p.length)return p;for(T=p[p.length-1],H=a.slice(h),C=0,L=H.length;C<L;C++)c=H[C],l(c,T)<0&&(I(p,c,0,null,l),p.pop(),T=p[p.length-1]);return p}for(r(a,l),ae=[],S=0,j=O(h,a.length);0<=j?S<j:S>j;0<=j?++S:--S)ae.push(d(a,l));return ae},ee=function(a,h,l,c){var T,p,C;for(c==null&&(c=t),T=a[l];l>h;){if(C=l-1>>1,p=a[C],c(T,p)<0){a[l]=p,l=C;continue}break}return a[l]=T},W=function(a,h,l){var c,T,p,C,S;for(l==null&&(l=t),T=a.length,S=h,p=a[h],c=2*h+1;c<T;)C=c+1,C<T&&!(l(a[c],a[C])<0)&&(c=C),a[h]=a[c],h=c,c=2*h+1;return a[h]=p,ee(a,S,h,l)},i=function(){a.push=m,a.pop=d,a.replace=b,a.pushpop=E,a.heapify=r,a.updateItem=re,a.nlargest=ce,a.nsmallest=pe;function a(h){this.cmp=h??t,this.nodes=[]}return a.prototype.push=function(h){return m(this.nodes,h,this.cmp)},a.prototype.pop=function(){return d(this.nodes,this.cmp)},a.prototype.peek=function(){return this.nodes[0]},a.prototype.contains=function(h){return this.nodes.indexOf(h)!==-1},a.prototype.replace=function(h){return b(this.nodes,h,this.cmp)},a.prototype.pushpop=function(h){return E(this.nodes,h,this.cmp)},a.prototype.heapify=function(){return r(this.nodes,this.cmp)},a.prototype.updateItem=function(h){return re(this.nodes,h,this.cmp)},a.prototype.clear=function(){return this.nodes=[]},a.prototype.empty=function(){return this.nodes.length===0},a.prototype.size=function(){return this.nodes.length},a.prototype.clone=function(){var h;return h=new a,h.nodes=this.nodes.slice(0),h},a.prototype.toArray=function(){return this.nodes.slice(0)},a.prototype.insert=a.prototype.push,a.prototype.top=a.prototype.peek,a.prototype.front=a.prototype.peek,a.prototype.has=a.prototype.contains,a.prototype.copy=a.prototype.clone,a}(),function(a,h){return s.exports=h()}(this,function(){return i})}).call(fe)})(be),function(s){s.exports=ne}(Oe);var Re=me(ie),g=(s=>(s[s.ADD_CANDIDATE=0]="ADD_CANDIDATE",s[s.POP_CANDIDATE=1]="POP_CANDIDATE",s[s.CHECK_SOLUTION=2]="CHECK_SOLUTION",s[s.BREATHING_TIME=3]="BREATHING_TIME",s[s.HASH_CALCULATION=4]="HASH_CALCULATION",s[s.VISISTED_LIST_CHECK=5]="VISISTED_LIST_CHECK",s[s.ADD_TO_VISISTED_LIST_CHECK=6]="ADD_TO_VISISTED_LIST_CHECK",s[s.PERFORM_ROTATION=7]="PERFORM_ROTATION",s[s.NOT_MEASURED=8]="NOT_MEASURED",s[s.HEURISTIC_CALCULATION=9]="HEURISTIC_CALCULATION",s[s.GET_ALL_CUBELETS=10]="GET_ALL_CUBELETS",s[s.CUBELET_FINAL_POSITION=11]="CUBELET_FINAL_POSITION",s[s.CUBELET_SIMILARITY=12]="CUBELET_SIMILARITY",s[s.ITERATION=13]="ITERATION",s[s.SOLUTION_CREATION=14]="SOLUTION_CREATION",s[s.MEASUREMENT_OVERHEAD=15]="MEASUREMENT_OVERHEAD",s[s.ITERATIONS_COUNTER_INCREMENT=16]="ITERATIONS_COUNTER_INCREMENT",s[s.ABORTED_VERIFICATION=17]="ABORTED_VERIFICATION",s[s.BUILD_SOLUTION=18]="BUILD_SOLUTION",s))(g||{});class Ne{constructor(e){u(this,"measurer");u(this,"candidates");u(this,"visitedChecklist");u(this,"actions");u(this,"dimension");u(this,"goalStateHash");u(this,"aborted");this.aborted=!1,this.dimension=e.getDimension(),this.candidates=new Re((r,d)=>r.cost+oe.heuristicWeight*r.heuristicValue-(d.cost+oe.heuristicWeight*d.heuristicValue)),this.visitedChecklist=new Map;const i={cost:0,heuristicValue:0,cube:e,rotation:void 0,parent:void 0};this.candidates.push(i),this.actions=[];const t=e.getCubeletsBySides(o.BACK,o.LEFT,o.DOWN)[0],n=this.buildSolvedPocketCubeFromCornerCubelet(t);this.goalStateHash=n.getHash(),[o.FRONT,o.UP,o.RIGHT].map(r=>[!0,!1].map(d=>{this.actions.push({side:r,counterClockwiseDirection:d,layer:0})})),this.measurer=new M}async findSolution(){return new Promise((e,i)=>{this.measurer.start();let t,n=0,r=0;for(;this.measurer.add(g[16],()=>this.candidates.size()>0);){if(this.measurer.add(g[17],()=>this.aborted))return i();if(this.measurer.add(g[16],()=>++n),t=this.measurer.add(g[1],()=>this.candidates.pop()),!this.measurer.add(g[5],()=>this.visitedChecklist.has(t.cube.getHash()))){if(++r,this.measurer.add(g[2],()=>t.cube.getHash()===this.goalStateHash))return e(this.measurer.add(g[14],()=>this.createSolution(t,n,r)));this.measurer.add(g[6],()=>this.visitedChecklist.set(t.cube.getHash(),t)),this.applyRotations(t)}}i(Error("No more candidates to explore"))})}abort(){this.aborted=!0}createSolution(e,i,t){const n=[];let r=e;return this.measurer.add(g[18],()=>{for(;r&&r.rotation;)n.unshift(r.rotation),r=r.parent}),this.measurer.finish(),this.candidates.clear(),{rotations:n,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:g[8],measurementOverheadLabel:g[15]}),visitedNodes:i,differentNodes:t}}}applyRotations(e){for(let i of this.actions){if(e.rotation&&(q(e.rotation,i)||e.parent&&e.parent.rotation&&y(e.rotation,i)&&y(e.parent.rotation,i)))continue;const t=this.measurer.add(g[7],()=>e.cube.rotateFace(i)),n=t.getHash(),r=this.measurer.add(g[9],()=>this.calculateDistanceToFinalState(t)),d={cost:e.cost+1,cube:t,rotation:i,heuristicValue:r,parent:e};this.measurer.add(g[5],()=>this.visitedChecklist.get(n))||this.measurer.add(g[0],()=>{this.candidates.push(d)})}}calculateDistanceToFinalState(e){const i=this.dimension*this.dimension+this.dimension*4;return e.getConfiguration().split("").filter((n,r)=>n!==this.goalStateHash[r]).length/i}buildSolvedPocketCubeFromCornerCubelet(e){const i=new Map;return e.stickers.forEach(t=>{i.set(t.side,t.color),i.set(v(t.side),K(t.color))}),new f({colorMap:i,dimension:this.dimension})}}class Ie{readKeys(e,i){let t;switch(e.key.toLowerCase()){case"w":t=o.UP;break;case"a":t=o.LEFT;break;case"s":t=o.FRONT;break;case"d":t=o.RIGHT;break;case"f":t=o.BACK;break;case"x":t=o.DOWN;break}if(t!==void 0)return{side:t,counterClockwiseDirection:e.shiftKey,layer:i}}}class B{constructor(e){u(this,"moves");u(this,"findSolutionResolve");u(this,"findSolutionReject");u(this,"cube");u(this,"startTime");u(this,"keyboardInterpreter");this.cube=e,this.moves=[],this.keyboardInterpreter=new Ie}async findSolution(){return this.startTime=Date.now(),new Promise((e,i)=>{this.findSolutionResolve=e,this.findSolutionReject=i})}abort(){this.findSolutionReject()}async readKeys(e){if(this.cube.isSolved())return;const i=this.keyboardInterpreter.readKeys(e);if(i!==void 0)return this.moves.push(i),this.cube=this.cube.rotateFace(i),this.cube.isSolved()&&this.findSolutionResolve({rotations:this.moves,totalTime:Date.now()-this.startTime,data:{human:!0}}),i}}const oe={heuristicWeight:50},w={mutationRate:.1,populationPerGeneration:100,maxNumOfRotations:30,elitism:15,armageddonThreshold:5e3},x={population:100,initialTemperature:.2,temperatureDecreaseRate:.85,numOfRotations:30,maxSuccessPerIteration:10,restartThreshold:5e3},de={metrics:{enabled:!0,generateReport:!0},world:{debug:!1,scrambleMoves:()=>Math.floor(Math.random()*10+30),scrambleRotationDuration:80,cubesCircleRay:4.5,camera:{closeDistance:20,farDistance:55}},renderers:{translationDuration:500,rotationDuration:250,titleDistance:8.5,cubeSize:2.5},initiallySelectedCubeTypeIndex:0,cubeTypes:[{label:"2x2",dimension:2,instantiator:()=>new f({dimension:2}),methods:[{key:"Human",instantiator:s=>new B(new f({clone:s})),checked:!1,info:"Use keys 'WASDFX' combined with 'shift' to rotate cube faces"},{key:"IDDFS",instantiator:s=>new Se(new f({clone:s})),checked:!1,info:"Interative-deepening depth-first-search. Brute force"},{key:"IDA*",instantiator:s=>new ge(new f({clone:s})),checked:!1,info:"Interative-deepening A star. Uses number of misplaced stickers as heuristic."},{key:"GA",instantiator:s=>new Ee(new f({clone:s})),checked:!0,info:`Random movements improved by genetic algorithm. Uses number of misplaced stickers as fitness function. Population: ${w.populationPerGeneration}. Elitism ${w.elitism}.  Mutation rate ${w.mutationRate}. `},{key:"SA",instantiator:s=>new Ae(new f({clone:s})),checked:!0,info:`Random movements improved by simulated annealing algorithm. Uses number of misplaced stickers as a measure of a solution candidate result. Population: ${x.population}. Initial temperature: ${x.initialTemperature}. Temperature decrease rate: ${x.temperatureDecreaseRate}`},{key:"WA*",instantiator:s=>new Ne(new f({clone:s})),checked:!0,info:`Weighted A star. No re-expansions. Uses number of misplaced stickers as heuristic and weights the heuristic (${oe.heuristicWeight} * h(x)) value.`},{key:"BiBFS",instantiator:s=>new Te(new f({clone:s})),checked:!0,info:"Bidirectional breadth-first-search. Brute force."}]},{label:"3x3",dimension:3,instantiator:()=>new f({dimension:3}),methods:[{key:"Human",instantiator:s=>new B(new f({clone:s})),checked:!1,info:"Use keys 'WASDFX' combined with 'shift' to rotate cube faces"}]},{label:"4x4",dimension:4,instantiator:()=>new f({dimension:4}),methods:[{key:"Human",instantiator:s=>new B(new f({clone:s})),checked:!1,info:"Use keys 'WASDFX' combined with 'shift' and numbers to rotate cube faces"}]},{label:"5x5",dimension:5,instantiator:()=>new f({dimension:5}),methods:[{key:"Human",instantiator:s=>new B(new f({clone:s})),checked:!1,info:"Use keys 'WASDFX' combined with 'shift' and numbers to rotate cube faces"}]},{label:"6x6",dimension:6,instantiator:()=>new f({dimension:6}),methods:[{key:"Human",instantiator:s=>new B(new f({clone:s})),checked:!1,info:"Use keys 'WASDFX' combined with 'shift' and numbers to rotate cube faces"}]},{label:"7x7",dimension:7,instantiator:()=>new f({dimension:7}),methods:[{key:"Human",instantiator:s=>new B(new f({clone:s})),checked:!1,info:"Use keys 'WASDFX' combined with 'shift' and numbers to rotate cube faces"}]}]},_e=s=>{for(let e of de.cubeTypes)if(e.label.toLowerCase()===s.label.toLowerCase()){for(let i of e.methods)if(i.key.toLowerCase()===s.solverTag.toLowerCase())return i;return}};let $;self.onmessage=async s=>{if(s.data.abort)$.abort();else{const e=s.data.solverTag.toLowerCase(),i=_e(s.data);if(e&&i)if(s.data.cube)try{$=i.instantiator(s.data.cube);const t=await $.findSolution();self.postMessage({solution:JSON.stringify(t),solverKey:e})}catch(t){console.log(`Solver '${s.data.label}.${e}' aborted`,t),self.postMessage({error:`Solver '${s.data.label}.${e}' aborted`,solverTag:s.data.solverTag})}else if(s.data.keyboardEvent){if($ instanceof B){const t=await $.readKeys(s.data.keyboardEvent);t!==void 0&&self.postMessage({faceRotation:t,solverKey:e})}}else self.postMessage({error:`Command for '${s.data}' not found`,solverTag:s.data.solverTag});else self.postMessage({error:`Solver '${s.data.solverTag}' not found`,solverTag:s.data.solverTag})}}})();
