var Ie=Object.defineProperty;var _e=(o,N,H)=>N in o?Ie(o,N,{enumerable:!0,configurable:!0,writable:!0,value:H}):o[N]=H;var u=(o,N,H)=>(_e(o,typeof N!="symbol"?N+"":N,H),H);(function(){"use strict";var o=(s=>(s[s.UP=0]="UP",s[s.LEFT=1]="LEFT",s[s.FRONT=2]="FRONT",s[s.RIGHT=3]="RIGHT",s[s.BACK=4]="BACK",s[s.DOWN=5]="DOWN",s))(o||{});const N=()=>Object.keys(o).filter(s=>!isNaN(Number(s))).map(s=>Number(s)),H=s=>Object.keys(o).filter(e=>!isNaN(Number(e))).map(e=>Number(e)).filter(e=>e!==s&&e!==v(s)),v=s=>{switch(s){case 0:return 5;case 5:return 0;case 1:return 3;case 3:return 1;case 2:return 4;case 4:return 2}};var F=(s=>(s[s.YELLOW=0]="YELLOW",s[s.ORANGE=1]="ORANGE",s[s.BLUE=2]="BLUE",s[s.RED=3]="RED",s[s.GREEN=4]="GREEN",s[s.WHITE=5]="WHITE",s))(F||{});const B=s=>{switch(s){case 2:return 4;case 4:return 2;case 3:return 1;case 1:return 3;case 0:return 5;case 5:return 0}},k=new Map;k.set(0,"y"),k.set(1,"o"),k.set(2,"b"),k.set(3,"r"),k.set(4,"g"),k.set(5,"w");const re=s=>k.get(s),U=new Map;U.set("y",0),U.set("o",1),U.set("b",2),U.set("r",3),U.set("g",4),U.set("w",5);const Q=s=>U.get(s),$=class{constructor(e){u(this,"dimension");u(this,"stickers");u(this,"cubeletCounter");this.dimension=e,this.stickers=[],this.cubeletCounter=0}create(){if($.cubeletsCreatorMap.has(this.dimension))return $.cubeletsCreatorMap.get(this.dimension);{let e=0;N().map(d=>{for(let T=0;T<this.dimension;++T)for(let E=0;E<this.dimension;++E)this.stickers.push({side:d,x:E,y:T,id:e++})});const i=this.extractCenters(),t=this.extractCorners(),n=this.extractEdges(),r=[...t,...n,...i];return $.cubeletsCreatorMap.set(this.dimension,r),r}}cubeletsMerger(e){const i={stickers:[],id:++this.cubeletCounter};return e.forEach(t=>{this.stickers.forEach((n,r,d)=>{n.side===t.side&&t.x===n.x&&t.y===n.y&&i.stickers.push(...d.splice(r,1))})}),i}extractEdges(){const e=this.dimension-1,i=[];for(let t=1;t<this.dimension-1;++t)i.push(this.cubeletsMerger([{side:o.FRONT,x:0,y:t},{side:o.LEFT,x:e,y:t}])),i.push(this.cubeletsMerger([{side:o.FRONT,x:e,y:t},{side:o.RIGHT,x:0,y:t}])),i.push(this.cubeletsMerger([{side:o.FRONT,x:t,y:0},{side:o.UP,x:t,y:e}])),i.push(this.cubeletsMerger([{side:o.FRONT,x:t,y:e},{side:o.DOWN,x:t,y:0}])),i.push(this.cubeletsMerger([{side:o.BACK,x:e,y:t},{side:o.LEFT,x:0,y:t}])),i.push(this.cubeletsMerger([{side:o.BACK,x:0,y:t},{side:o.RIGHT,x:e,y:t}])),i.push(this.cubeletsMerger([{side:o.BACK,x:t,y:0},{side:o.UP,x:e-t,y:0}])),i.push(this.cubeletsMerger([{side:o.BACK,x:t,y:e},{side:o.DOWN,x:e-t,y:e}])),i.push(this.cubeletsMerger([{side:o.RIGHT,x:t,y:0},{side:o.UP,x:e,y:e-t}])),i.push(this.cubeletsMerger([{side:o.RIGHT,x:t,y:e},{side:o.DOWN,x:e,y:t}])),i.push(this.cubeletsMerger([{side:o.LEFT,x:t,y:0},{side:o.UP,x:0,y:t}])),i.push(this.cubeletsMerger([{side:o.LEFT,x:t,y:e},{side:o.DOWN,x:0,y:e-t}]));return i}extractCenters(){const e=this.dimension-1,i=[];return this.stickers.filter(t=>t.x!==0&&t.x!==e&&t.y!==0&&t.y!==e).forEach(t=>{i.push({stickers:[t],id:++this.cubeletCounter})}),i}extractCorners(){const e=[],i=this.dimension-1;return e.push(this.cubeletsMerger([{side:o.FRONT,x:0,y:0},{side:o.UP,x:0,y:i},{side:o.LEFT,x:i,y:0}])),e.push(this.cubeletsMerger([{side:o.FRONT,x:i,y:0},{side:o.UP,x:i,y:i},{side:o.RIGHT,x:0,y:0}])),e.push(this.cubeletsMerger([{side:o.FRONT,x:0,y:i},{side:o.DOWN,x:0,y:0},{side:o.LEFT,x:i,y:i}])),e.push(this.cubeletsMerger([{side:o.FRONT,x:i,y:i},{side:o.DOWN,x:i,y:0},{side:o.RIGHT,x:0,y:i}])),e.push(this.cubeletsMerger([{side:o.BACK,x:0,y:0},{side:o.UP,x:i,y:0},{side:o.RIGHT,x:i,y:0}])),e.push(this.cubeletsMerger([{side:o.BACK,x:i,y:0},{side:o.UP,x:0,y:0},{side:o.LEFT,x:0,y:0}])),e.push(this.cubeletsMerger([{side:o.BACK,x:0,y:i},{side:o.DOWN,x:i,y:i},{side:o.RIGHT,x:i,y:i}])),e.push(this.cubeletsMerger([{side:o.BACK,x:i,y:i},{side:o.DOWN,x:0,y:i},{side:o.LEFT,x:0,y:i}])),e}};let j=$;u(j,"cubeletsCreatorMap",new Map);const Y=class{constructor(e){u(this,"dimension");if(this.dimension=e,!Y.faceRotatorMap.has(this.dimension)){const i=new Map;for(let t=0;t<this.dimension;++t){const n=this.createUpFaceClockwiseRotator(t),r=this.createLeftFaceClockwiseRotator(t),d=this.createFrontFaceClockwiseRotator(t),T=this.createRightFaceClockwiseRotator(t),E=this.createBackFaceClockwiseRotator(t),O=this.createDownFaceClockwiseRotator(t),R=new Map;R.set(o.UP,n.map(S=>this.faceStickerMapper(S))),R.set(o.LEFT,r.map(S=>this.faceStickerMapper(S))),R.set(o.FRONT,d.map(S=>this.faceStickerMapper(S))),R.set(o.RIGHT,T.map(S=>this.faceStickerMapper(S))),R.set(o.BACK,E.map(S=>this.faceStickerMapper(S))),R.set(o.DOWN,O.map(S=>this.faceStickerMapper(S))),i.set(t,R)}Y.faceRotatorMap.set(this.dimension,i)}}rotate(e,i){const t=new f({clone:e.getConfiguration()}),n=[];return Y.faceRotatorMap.get(this.dimension).get(i.layer||0).get(i.side).forEach(r=>{i.counterClockwiseDirection?n.push({index:r.source,color:e.getColorOfIndex(r.destination)}):n.push({index:r.destination,color:e.getColorOfIndex(r.source)})}),t.setColorsOfIndexes(n),t}idMapper(e){let i=e.side*this.dimension*this.dimension;return i+=this.dimension*e.y,i+=e.x,i}faceStickerMapper(e){return{source:this.idMapper(e.source),destination:this.idMapper(e.destination)}}createSideLidClockwiseRotator(e){const i=[];for(let t=0;t<this.dimension*this.dimension;++t){const n=t%this.dimension,r=Math.floor(t/this.dimension),d=this.dimension-1-r,T=n;i.push({source:{side:e,x:n,y:r},destination:{side:e,x:d,y:T}})}return i}createUpFaceClockwiseRotator(e){this.dimension-1;const i=[];e===0&&i.push(...this.createSideLidClockwiseRotator(o.UP));for(let t=0;t<this.dimension;++t)i.push({source:{side:o.FRONT,x:t,y:e},destination:{side:o.LEFT,x:t,y:e}}),i.push({source:{side:o.LEFT,x:t,y:e},destination:{side:o.BACK,x:t,y:e}}),i.push({source:{side:o.BACK,x:t,y:e},destination:{side:o.RIGHT,x:t,y:e}}),i.push({source:{side:o.RIGHT,x:t,y:e},destination:{side:o.FRONT,x:t,y:e}});return i}createLeftFaceClockwiseRotator(e){const i=this.dimension-1,t=[];e===0&&t.push(...this.createSideLidClockwiseRotator(o.LEFT));for(let n=0;n<this.dimension;++n)t.push({source:{side:o.FRONT,x:e,y:n},destination:{side:o.DOWN,x:e,y:n}}),t.push({source:{side:o.DOWN,x:e,y:n},destination:{side:o.BACK,x:i-e,y:i-n}}),t.push({source:{side:o.BACK,x:i-e,y:i-n},destination:{side:o.UP,x:e,y:n}}),t.push({source:{side:o.UP,x:e,y:n},destination:{side:o.FRONT,x:e,y:n}});return t}createFrontFaceClockwiseRotator(e){const i=this.dimension-1,t=[];e===0&&t.push(...this.createSideLidClockwiseRotator(o.FRONT));for(let n=0;n<this.dimension;++n)t.push({source:{side:o.UP,x:n,y:i-e},destination:{side:o.RIGHT,x:e,y:n}}),t.push({source:{side:o.RIGHT,x:e,y:n},destination:{side:o.DOWN,x:i-n,y:e}}),t.push({source:{side:o.DOWN,x:i-n,y:e},destination:{side:o.LEFT,x:i-e,y:i-n}}),t.push({source:{side:o.LEFT,x:i-e,y:i-n},destination:{side:o.UP,x:n,y:i-e}});return t}createRightFaceClockwiseRotator(e){const i=this.dimension-1,t=[];e===0&&t.push(...this.createSideLidClockwiseRotator(o.RIGHT));for(let n=0;n<this.dimension;++n)t.push({source:{side:o.UP,x:i-e,y:n},destination:{side:o.BACK,x:e,y:i-n}}),t.push({source:{side:o.BACK,x:e,y:i-n},destination:{side:o.DOWN,x:i-e,y:n}}),t.push({source:{side:o.DOWN,x:i-e,y:n},destination:{side:o.FRONT,x:i-e,y:n}}),t.push({source:{side:o.FRONT,x:i-e,y:n},destination:{side:o.UP,x:i-e,y:n}});return t}createBackFaceClockwiseRotator(e){const i=this.dimension-1,t=[];e===0&&t.push(...this.createSideLidClockwiseRotator(o.BACK));for(let n=0;n<this.dimension;++n)t.push({source:{side:o.LEFT,x:e,y:n},destination:{side:o.DOWN,x:n,y:i-e}}),t.push({source:{side:o.DOWN,x:n,y:i-e},destination:{side:o.RIGHT,x:i-e,y:i-n}}),t.push({source:{side:o.RIGHT,x:i-e,y:i-n},destination:{side:o.UP,x:i-n,y:e}}),t.push({source:{side:o.UP,x:i-n,y:e},destination:{side:o.LEFT,x:e,y:n}});return t}createDownFaceClockwiseRotator(e){const i=this.dimension-1,t=[];e===0&&t.push(...this.createSideLidClockwiseRotator(o.DOWN));for(let n=0;n<this.dimension;++n)t.push({source:{side:o.LEFT,x:n,y:i-e},destination:{side:o.FRONT,x:n,y:i-e}}),t.push({source:{side:o.FRONT,x:n,y:i-e},destination:{side:o.RIGHT,x:n,y:i-e}}),t.push({source:{side:o.RIGHT,x:n,y:i-e},destination:{side:o.BACK,x:n,y:i-e}}),t.push({source:{side:o.BACK,x:n,y:i-e},destination:{side:o.LEFT,x:n,y:i-e}});return t}};let Z=Y;u(Z,"faceRotatorMap",new Map);const P=new Map;P.set(o.FRONT,F.BLUE),P.set(o.UP,F.YELLOW),P.set(o.RIGHT,F.RED),P.set(o.LEFT,F.ORANGE),P.set(o.BACK,F.GREEN),P.set(o.DOWN,F.WHITE);class f{constructor(e){u(this,"configuration");u(this,"dimension");u(this,"faceRotator");u(this,"colorlessCubelets");if(this.dimension=e==null?void 0:e.dimension,e!=null&&e.clone)this.dimension=Math.sqrt(e.clone.length/6),this.configuration=e.clone.slice();else{const i=this.dimension*this.dimension,t=(e==null?void 0:e.colorMap)||P,n=N();this.configuration="";for(let r=0;r<n.length;++r){const d=t.get(r),T=re(d);this.configuration+=T.repeat(i)}}this.faceRotator=new Z(this.dimension),this.colorlessCubelets=new j(this.dimension).create()}clone(){return new f({clone:this.configuration})}getDimension(){return this.dimension}getConfiguration(){return this.configuration}getHash(){return this.configuration}isSolved(){const e=this.dimension*this.dimension,i=N(),t=Array.from(new Array(e));return i.every((n,r)=>t.every((d,T)=>this.configuration[r*e+T]===this.configuration[r*e]))}rotateFace(e){return this.faceRotator.rotate(this,e)}getAllCubelets(){return this.addColorToCubelets(this.colorlessCubelets)}getAllColorlessCubelets(){return this.colorlessCubelets}getSideOfIndex(e){const i=N().length;return e/i}getColorlessCubeletOfIndex(e){return this.colorlessCubelets.find(i=>i.stickers.some(t=>t.id===e))}getCubeletsBySides(...e){const i=this.colorlessCubelets.filter(t=>t.stickers.every(n=>e.includes(n.side)));return this.addColorToCubelets(i)}getCubeletsByColors(...e){const i=this.colorlessCubelets.filter(t=>t.stickers.every(n=>e.includes(Q(this.configuration[n.id]))));return this.addColorToCubelets(i)}getColorOfIndex(e){return Q(this.configuration[e])}setColorsOfIndexes(e){const i=this.configuration.split("");e.forEach(t=>{i[t.index]=re(t.color)}),this.configuration=i.join("")}addColorToCubelets(e){return e.map(i=>({stickers:i.stickers.map(t=>({...t,color:Q(this.configuration[t.id])}))}))}}var ce=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function pe(s){return s&&s.__esModule&&Object.prototype.hasOwnProperty.call(s,"default")?s.default:s}var ae=I;function I(){this._start=null,this._end=null,this.length=0}I.prototype.unShift=function(s){if(this._start===null)this._start=W(s),this._end=this._start;else{var e=this._start;this._start.previous=W(s),this._start=this._start.previous,this._start.next=e}this.length++},I.prototype.push=function(s){if(this._start===null)this._start=W(s),this._end=this._start;else{var e=this._end;this._end.next=W(s),this._end=this._end.next,this._end.previous=e}this.length++},I.prototype.add=function(s,e){if(s%1===0)if(s<=0)this.unShift(e);else if(s>=this.length)this.push(e);else{var i=ee.call(this,s);if(i){var t=i.previous,n=i,r=W(e);r.previous=t,t.next=r,r.next=n,n.previous=r,this.length++}}},I.prototype.shift=function(){if(this._start){var s=this._start.data;return this._start.next===null?(this._end=null,this._start=null):(this._start=this._start.next,this._start.previous=null),this.length--,s}else return},I.prototype.pop=function(){if(this._end){var s=this._end.data;return this._end.previous===null?(this._end=null,this._start=null):(this._end=this._end.previous,this._end.next=null),this.length--,s}else return},I.prototype.remove=function(s){if(s===0)return this.shift();if(s===this.length-1)return this.pop();var e=ee.call(this,s);if(e){var i=e.previous,t=e.next;i.next=t,t.previous=i,this.length--}else return},I.prototype.first=function(){if(this._start)return this._start.data},I.prototype.last=function(){if(this._end)return this._end.data},I.prototype.get=function(s){var e=ee.call(this,s);if(e)return e.data},I.prototype.toString=function(){for(var s=this._start,e="",i=0;i<this.length;i++)typeof s.data=="object"?e+=JSON.stringify(s.data):e+=s.data,i!==this.length-1&&(e+=", "),s=s.next;return e};function W(s){return{data:s,previous:null,next:null}}function ee(s){var e,i;if(s>=this.length||s<0||s%1!==0)e=null;else if(s<this.length/2)for(e=this._start,i=0;i<s;i++)e=e.next;else for(e=this._end,i=this.length-1;i>s;i--)e=e.previous;return e}class M{constructor(e=he.metrics.enabled){u(this,"map");u(this,"enabled");u(this,"measurerOverhead");u(this,"startTime");u(this,"totalTime");this.map=new Map,this.enabled=e,this.measurerOverhead=0}add(e,i){const t=performance.now();if(!this.enabled)return i();const n=i(),r=performance.now(),d=this.map.get(e)||{elapsedTime:0,calls:0,stack:"",stackSize:0};return d.elapsedTime+=r-t,++d.calls,this.map.set(e,d),this.measurerOverhead+=performance.now()-r,n}start(){this.startTime=performance.now()}finish(){this.startTime&&(this.totalTime=performance.now()-this.startTime)}getTotalTime(){return this.totalTime}getData(e){const i=[];if(this.totalTime){let t=0;Array.from(this.map.entries()).forEach(n=>{const[r,d]=n;t+=d.elapsedTime,i.push(this.createSummary(d.elapsedTime,d.calls,r))}),e!=null&&e.measurementOverheadLabel&&(i.push(this.createSummary(this.measurerOverhead,0,e.measurementOverheadLabel)),t+=this.measurerOverhead),e!=null&&e.notMeasuredLabel&&i.push(this.createSummary(this.totalTime-t,0,e.notMeasuredLabel))}return i}createSummary(e,i,t){const n=100*e/this.totalTime;return{label:t,totalTime:e,totalRelativeTime:Math.trunc(100*n)/100+"%",numOfCalls:i,avgTimePerCall:e*1/(i||1)}}}var b=(s=>(s[s.ADD_CANDIDATE=0]="ADD_CANDIDATE",s[s.POP_CANDIDATE=1]="POP_CANDIDATE",s[s.HASH_CALCULATION=2]="HASH_CALCULATION",s[s.VISISTED_LIST_CHECK=3]="VISISTED_LIST_CHECK",s[s.ADD_TO_VISISTED_LIST_CHECK=4]="ADD_TO_VISISTED_LIST_CHECK",s[s.PERFORM_ROTATION=5]="PERFORM_ROTATION",s[s.NOT_MEASURED=6]="NOT_MEASURED",s[s.MEASUREMENT_OVERHEAD=7]="MEASUREMENT_OVERHEAD",s))(b||{});class fe{constructor(e){u(this,"measurer");u(this,"forwardSearchToExploreList");u(this,"forwardSearchExploredMap");u(this,"reverseSearchToExploreList");u(this,"reverseSearchExploredMap");u(this,"actions");u(this,"iterations");u(this,"aborted");this.forwardSearchToExploreList=new ae,this.reverseSearchToExploreList=new ae,this.actions=[],this.iterations=0,this.measurer=new M,this.forwardSearchExploredMap=new Map,this.reverseSearchExploredMap=new Map,this.aborted=!1;const i={cube:e,rotation:void 0,parent:void 0};this.forwardSearchToExploreList.push(i);const t=[],n=[o.RIGHT,o.LEFT][Math.floor(Math.random()*2)],r=[o.UP,o.DOWN][Math.floor(Math.random()*2)],d=[o.FRONT,o.BACK][Math.floor(Math.random()*2)];[n,r,d].map(R=>[!0,!1].map(S=>{t.push(v(R)),this.actions.push({side:R,counterClockwiseDirection:S,layer:0})}));const T=e.getCubeletsBySides(...t)[0],O={cube:this.buildSolvedCubeFromCornerCubelet(T,e.getDimension()),rotation:void 0,parent:void 0};this.reverseSearchToExploreList.push(O)}abort(){this.aborted=!0}async findSolution(){return new Promise((e,i)=>{this.measurer.start();let t,n,r=0;for(;this.forwardSearchToExploreList.length>0&&this.reverseSearchToExploreList.length>0;){if(++this.iterations,this.aborted)return i();do t=this.measurer.add(b[1],()=>this.forwardSearchToExploreList.shift());while(this.measurer.add(b[3],()=>this.forwardSearchExploredMap.has(t.cube.getHash())));do n=this.measurer.add(b[1],()=>this.reverseSearchToExploreList.shift());while(this.measurer.add(b[3],()=>this.reverseSearchExploredMap.has(n.cube.getHash())));++r;let d=this.measurer.add(b[3],()=>this.forwardSearchExploredMap.get(n.cube.getHash()));if(d)return e(this.createSolution(d,n,r));if(d=this.measurer.add(b[3],()=>this.reverseSearchExploredMap.get(t.cube.getHash())),d)return e(this.createSolution(t,d,r));this.measurer.add(b[4],()=>this.forwardSearchExploredMap.set(t.cube.getHash(),t)),this.measurer.add(b[4],()=>this.reverseSearchExploredMap.set(n.cube.getHash(),n)),this.applyRotations(this.forwardSearchToExploreList,this.forwardSearchExploredMap,t),this.applyRotations(this.reverseSearchToExploreList,this.reverseSearchExploredMap,n)}return i()})}applyRotations(e,i,t){this.actions.forEach(n=>{const r=this.measurer.add(b[5],()=>t.cube.rotateFace(n));this.measurer.add(b[3],()=>i.has(r.getHash()))||this.measurer.add(b[0],()=>{e.push({cube:r,rotation:n,parent:t})})})}createSolution(e,i,t){this.measurer.finish();const n=[];let r=e;for(;r&&r.rotation;)n.unshift(r.rotation),r=r.parent;for(r=i;r&&r.rotation;){const d={...r.rotation};d.counterClockwiseDirection=!d.counterClockwiseDirection,n.push(d),r=r.parent}return{rotations:n,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:b[6],measurementOverheadLabel:b[7]}),iterations:this.iterations,visitedNodes:t}}}buildSolvedCubeFromCornerCubelet(e,i){const t=new Map;return e.stickers.forEach(n=>{t.set(n.side,n.color),t.set(v(n.side),B(n.color))}),new f({colorMap:t,dimension:i})}}class me{constructor(e,i){u(this,"numberOfActions");u(this,"numOfGenes");u(this,"generationsCounter");u(this,"armageddonCounter");this.numberOfActions=e,this.numOfGenes=i,this.generationsCounter=0,this.armageddonCounter=0}createNextGeneration(e){if(++this.generationsCounter,!e)return this.createNewPopulationFromScratch();if(this.generationsCounter%w.armageddonThreshold===0)return console.log("Armageddon: "+ ++this.armageddonCounter),this.createNextGeneration();const i=e.sort((t,n)=>n.score-t.score).filter((t,n)=>n<w.elitism);return Array.from(new Array(w.populationPerGeneration)).map(()=>this.reproduceCitizens(i))}getArmageddonCounter(){return this.armageddonCounter}getGenerationsCounter(){return this.generationsCounter}pickOne(e,i){let t;do t=Math.floor(Math.random()*e.length);while(i.includes(t));return{chromosome:e[t],index:t}}createNewPopulationFromScratch(){return Array.from(new Array(w.populationPerGeneration)).map(()=>({genes:Array.from(new Array(this.numOfGenes)).map(()=>Math.floor(Math.random()*this.numberOfActions)),score:NaN}))}reproduceCitizens(e){const i=this.pickOne(e,[]),t=this.pickOne(e,[i.index]),n=Math.floor(i.chromosome.genes.length*.25+Math.random()*i.chromosome.genes.length*.5);return{genes:i.chromosome.genes.map((d,T)=>{let E=d;return T>n&&(E=t.chromosome.genes[T]),Math.random()<w.mutationRate&&(E=Math.floor(Math.random()*this.numberOfActions)),E}),score:NaN}}}var _=(s=>(s[s.NOT_MEASURED=0]="NOT_MEASURED",s[s.RUN_CITIZEN_ROTATIONS=1]="RUN_CITIZEN_ROTATIONS",s[s.CALCULATE_CITIZEN_SCORE=2]="CALCULATE_CITIZEN_SCORE",s[s.APPLYING_ROTATIONS=3]="APPLYING_ROTATIONS",s[s.CREATE_NEXT_GENERATION=4]="CREATE_NEXT_GENERATION",s[s.COMPUTE_GENE=5]="COMPUTE_GENE",s[s.AGGREGATE_CURRENT_GENERATION=6]="AGGREGATE_CURRENT_GENERATION",s[s.CHECK_SOLUTION=7]="CHECK_SOLUTION",s[s.MEASUREMENT_OVERHEAD=8]="MEASUREMENT_OVERHEAD",s))(_||{});class Te{constructor(e){u(this,"measurer");u(this,"initialState");u(this,"goalStateHash");u(this,"geneticAlgorithm");u(this,"citizens");u(this,"aborted");u(this,"actions");this.measurer=new M,this.initialState=e.clone(),this.aborted=!1,this.actions=[];const i=e.getCubeletsBySides(o.BACK,o.LEFT,o.DOWN)[0],t=this.buildSolvedPocketCubeFromCornerCubelet(i);this.goalStateHash=t.getHash(),[o.FRONT,o.UP,o.RIGHT].map(n=>[!0,!1].map(r=>{this.actions.push({side:n,counterClockwiseDirection:r,layer:0})})),this.geneticAlgorithm=new me(this.actions.length,w.maxNumOfRotations),this.citizens=this.geneticAlgorithm.createNextGeneration()}async findSolution(){return this.measurer.start(),new Promise((e,i)=>{for(;;){if(this.aborted)return i();const t=[];for(let n of this.citizens){const r=this.runCitizen(n);if(r.score===this.goalStateHash.length)return e(this.createSolution(r));this.measurer.add(_[6],()=>t.push(r))}this.citizens=this.measurer.add(_[4],()=>this.geneticAlgorithm.createNextGeneration(t))}})}abort(){this.aborted=!0}runCitizen(e){let i=this.initialState.clone();return e.genes.reduce((t,n)=>(this.measurer.add(_[7],()=>t.score===this.goalStateHash.length)||(i=this.measurer.add(_[3],()=>i.rotateFace(this.actions[n])),this.measurer.add(_[5],()=>t.genes.push(n)),t.score=this.measurer.add(_[2],()=>this.calculateCitizenScore(i))),t),{score:0,genes:[]})}calculateCitizenScore(e){return e.getConfiguration().split("").filter((t,n)=>t===this.goalStateHash[n]).length}createSolution(e){const i=e.genes.map(t=>this.actions[t]);return this.measurer.finish(),{rotations:i,totalTime:this.measurer.getTotalTime(),data:{armageddonCounter:this.geneticAlgorithm.getArmageddonCounter(),generations:this.geneticAlgorithm.getGenerationsCounter(),metrics:this.measurer.getData({notMeasuredLabel:_[0],measurementOverheadLabel:_[8]})}}}buildSolvedPocketCubeFromCornerCubelet(e){const i=new Map;return e.stickers.forEach(t=>{i.set(t.side,t.color),i.set(v(t.side),B(t.color))}),new f({colorMap:i,dimension:this.initialState.getDimension()})}}var V=(s=>(s[s.ADD_CANDIDATE=0]="ADD_CANDIDATE",s[s.POP_CANDIDATE=1]="POP_CANDIDATE",s[s.CHECK_SOLUTION=2]="CHECK_SOLUTION",s[s.BREATHING_TIME=3]="BREATHING_TIME",s[s.HASH_CALCULATION=4]="HASH_CALCULATION",s[s.VISISTED_LIST_CHECK=5]="VISISTED_LIST_CHECK",s[s.ADD_TO_VISISTED_LIST_CHECK=6]="ADD_TO_VISISTED_LIST_CHECK",s[s.PERFORM_ROTATION=7]="PERFORM_ROTATION",s[s.NOT_MEASURED=8]="NOT_MEASURED",s[s.CYCLE_AVOIDANCE_CHECK=9]="CYCLE_AVOIDANCE_CHECK",s))(V||{});class Ce{constructor(e){u(this,"measurer");u(this,"actions");u(this,"goalStateHash");u(this,"root");u(this,"numberOfStickersMovedInOneTwist");u(this,"iterations");u(this,"minBoundGrow",1.25);u(this,"currentPath");u(this,"bound");u(this,"visitedNodes");u(this,"aborted");this.iterations=[],this.measurer=new M,this.currentPath=[],this.visitedNodes=0,this.aborted=!1,this.actions=[],[o.FRONT,o.UP,o.RIGHT].map(r=>[!0,!1].map(d=>{this.actions.push({side:r,counterClockwiseDirection:d,layer:0})}));const i=e.getCubeletsBySides(o.BACK,o.LEFT,o.DOWN)[0],t=this.buildSolvedPocketCubeFromCornerCubelet(i,e.getDimension());this.goalStateHash=t.getHash();const n=e.getDimension();this.numberOfStickersMovedInOneTwist=n*n+n*H(o.UP).length,this.bound=this.calculateDistanceToFinalState(e),this.root={cube:e,rotation:void 0,parent:void 0}}abort(){this.aborted=!0}async findSolution(){let e=0;return new Promise((i,t)=>{for(this.measurer.start();!this.aborted;){this.currentPath=[this.root.cube.getHash()];const n=this.search(this.root,0);if(n.solution)return i(this.createSolution(n.solution));if(n.aborted)break;{const r=this.visitedNodes-e;this.iterations.push({newNodesVisited:r,bound:this.bound}),e=this.visitedNodes,this.bound=Math.max(n.cost,this.bound+this.minBoundGrow)}}t(Error("Aborted"))})}search(e,i){if(++this.visitedNodes,this.aborted)return{aborted:!0};let t=this.calculateDistanceToFinalState(e.cube);if(e.cube.isSolved())return{solution:e};let n=1/0;const r=this.applyRotations(e);for(let d of r){const T=i+t;if(T>this.bound)return{cost:T};const E=d.cube.getHash();if(this.measurer.add(V[9],()=>this.currentPath.every(O=>O!==E))){this.currentPath.push(E);const O=this.search(d,i+1);if(O.solution||O.aborted)return O;t=Math.min(t,O.cost-1),n=Math.min(O.cost,n),this.currentPath.pop()}}return{cost:n}}createSolution(e){this.measurer.finish();const i=[];let t=e;for(;t&&t.rotation;)i.unshift(t.rotation),t=t.parent;return{rotations:i,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:V[8]}),visitedNodes:this.visitedNodes,iterations:this.iterations}}}applyRotations(e){const i=[];return this.actions.forEach(t=>{const n=this.measurer.add(V[7],()=>e.cube.rotateFace(t));this.measurer.add(V[0],()=>{i.push({cube:n,rotation:t,parent:e})})}),i}calculateDistanceToFinalState(e){return e.getConfiguration().split("").filter((t,n)=>t!==this.goalStateHash[n]).length/this.numberOfStickersMovedInOneTwist}buildSolvedPocketCubeFromCornerCubelet(e,i){const t=new Map;return e.stickers.forEach(n=>{t.set(n.side,n.color),t.set(v(n.side),B(n.color))}),new f({colorMap:t,dimension:i})}}var J=(s=>(s[s.ADD_CANDIDATE=0]="ADD_CANDIDATE",s[s.POP_CANDIDATE=1]="POP_CANDIDATE",s[s.CHECK_SOLUTION=2]="CHECK_SOLUTION",s[s.BREATHING_TIME=3]="BREATHING_TIME",s[s.HASH_CALCULATION=4]="HASH_CALCULATION",s[s.VISISTED_LIST_CHECK=5]="VISISTED_LIST_CHECK",s[s.ADD_TO_VISISTED_LIST_CHECK=6]="ADD_TO_VISISTED_LIST_CHECK",s[s.PERFORM_ROTATION=7]="PERFORM_ROTATION",s[s.NOT_MEASURED=8]="NOT_MEASURED",s))(J||{});class Ee{constructor(e){u(this,"measurer");u(this,"actions");u(this,"root");u(this,"currentMaxDepth");u(this,"visitedNodes");u(this,"aborted");this.measurer=new M,this.visitedNodes=0,this.aborted=!1,this.actions=this.createActions();const i=e.getCubeletsBySides(o.BACK,o.LEFT,o.DOWN)[0],t=this.buildSolvedPocketCubeFromCornerCubelet(i,e.getDimension());this.currentMaxDepth=this.calculateDistanceToFinalState(e,t.getConfiguration()),this.root={cube:e,rotation:void 0,parent:void 0}}abort(){this.aborted=!0}async findSolution(){return new Promise((e,i)=>{for(this.measurer.start();!this.aborted;){const t=this.beginSearch(this.root,0);if(t)return this.measurer.finish(),e(this.createSolution(t));++this.currentMaxDepth}i(Error("Aborted"))})}beginSearch(e,i){if(++this.visitedNodes,!this.aborted){if(i<this.currentMaxDepth){const t=this.applyRotations(e);for(let n of t){const r=this.beginSearch(n,i+1);if(r)return r}}else if(i===this.currentMaxDepth&&e.cube.isSolved())return e}}createActions(){const e=[];return[o.FRONT,o.UP,o.RIGHT].map(i=>[!0,!1].map(t=>{e.push({side:i,counterClockwiseDirection:t,layer:0})})),e}createSolution(e){const i=[];let t=e;for(;t&&t.rotation;)i.unshift(t.rotation),t=t.parent;return{rotations:i,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:J[8]}),visitedNodes:this.visitedNodes}}}applyRotations(e){const i=[];return this.actions.forEach(t=>{const n=this.measurer.add(J[7],()=>e.cube.rotateFace(t));this.measurer.add(J[0],()=>{i.push({cube:n,rotation:t,parent:e})})}),i}calculateDistanceToFinalState(e,i){const t=e.getDimension()*e.getDimension()+e.getDimension()*4,n=e.getConfiguration();return Math.ceil(n.split("").filter((r,d)=>r!==i[d]).length/t)}buildSolvedPocketCubeFromCornerCubelet(e,i){const t=new Map;return e.stickers.forEach(n=>{t.set(n.side,n.color),t.set(v(n.side),B(n.color))}),new f({colorMap:t,dimension:i})}}class ue{constructor(e){u(this,"maxSuccessPerIteration",x.maxSuccessPerIteration);u(this,"temperatureDecreaseRate",x.temperatureDecreaseRate);u(this,"numOfRotations",x.numOfRotations);u(this,"population",x.population);u(this,"numOfActions");u(this,"temperature",x.initialTemperature);u(this,"lastResult");u(this,"successCounter",0);u(this,"generationCounter",0);this.numOfActions=e}createNextGeneration(e){if(++this.generationCounter,!e)return this.createNewPopulationFromScratch();const i=e.sort((n,r)=>r.score-n.score)[0];return this.lastResult?i.score-this.lastResult.score>0?(++this.successCounter,this.successCounter>this.maxSuccessPerIteration&&this.adjustTemperature(),this.disturbCandidate(i)):this.disturbCandidate(this.lastResult):this.disturbCandidate(i)}getGenerationCounter(){return this.generationCounter}createNewPopulationFromScratch(){return Array.from(new Array(this.population)).map(()=>({actions:Array.from(new Array(this.numOfRotations)).map(()=>this.createAction()),score:NaN}))}disturbCandidate(e){return this.lastResult=e,Array.from(Array(this.population-1)).map(()=>({actions:e.actions.map(t=>Math.random()<this.temperature?this.createAction():t),score:NaN})).concat(e)}createAction(){return Math.floor(Math.random()*this.numOfActions)}adjustTemperature(){this.temperature*=this.temperatureDecreaseRate,this.successCounter=0}}var D=(s=>(s[s.NOT_MEASURED=0]="NOT_MEASURED",s[s.RUN_CANDIDATE_ROTATIONS=1]="RUN_CANDIDATE_ROTATIONS",s[s.CALCULATE_CITIZEN_SCORE=2]="CALCULATE_CITIZEN_SCORE",s[s.APPLYING_ROTATIONS=3]="APPLYING_ROTATIONS",s[s.CREATE_NEXT_GENERATION=4]="CREATE_NEXT_GENERATION",s[s.COMPUTE_ROTATION=5]="COMPUTE_ROTATION",s[s.AGGREGATE_CURRENT_GENERATION=6]="AGGREGATE_CURRENT_GENERATION",s[s.CHECK_SOLUTION=7]="CHECK_SOLUTION",s[s.MEASUREMENT_OVERHEAD=8]="MEASUREMENT_OVERHEAD",s))(D||{});class ge{constructor(e){u(this,"measurer");u(this,"initialState");u(this,"goalStateHash");u(this,"simulatedAnnealing");u(this,"candidates");u(this,"aborted");u(this,"actions");u(this,"restartCounter",0);u(this,"iterations",0);this.measurer=new M,this.initialState=e.clone(),this.aborted=!1,this.actions=[];const i=e.getCubeletsBySides(o.BACK,o.LEFT,o.DOWN)[0],t=this.buildSolvedPocketCubeFromCornerCubelet(i);this.goalStateHash=t.getHash(),[o.FRONT,o.UP,o.RIGHT].map(n=>[!0,!1].map(r=>{this.actions.push({side:n,counterClockwiseDirection:r,layer:0})})),this.simulatedAnnealing=new ue(this.actions.length),this.candidates=this.simulatedAnnealing.createNextGeneration()}async findSolution(){return this.measurer.start(),new Promise((e,i)=>{for(;;){if(++this.iterations,this.aborted)return i();this.simulatedAnnealing.getGenerationCounter()>x.restartThreshold&&(++this.restartCounter,console.log("Restart"),this.simulatedAnnealing=new ue(this.actions.length),this.candidates=this.simulatedAnnealing.createNextGeneration());const t=[];for(let n of this.candidates){const r=this.runCitizen(n);if(r.score===this.goalStateHash.length)return e(this.createSolution(r));this.measurer.add(D[6],()=>t.push(r))}this.candidates=this.measurer.add(D[4],()=>this.simulatedAnnealing.createNextGeneration(t))}})}abort(){this.aborted=!0}runCitizen(e){let i=this.initialState.clone();return e.actions.reduce((t,n)=>(this.measurer.add(D[7],()=>t.score===this.goalStateHash.length)||(i=this.measurer.add(D[3],()=>i.rotateFace(this.actions[n])),this.measurer.add(D[5],()=>t.actions.push(n)),t.score=this.measurer.add(D[2],()=>this.calculateCitizenScore(i))),t),{score:0,actions:[]})}calculateCitizenScore(e){return e.getConfiguration().split("").filter((t,n)=>t===this.goalStateHash[n]).length}createSolution(e){const i=e.actions.map(t=>this.actions[t]);return this.measurer.finish(),{rotations:i,totalTime:this.measurer.getTotalTime(),data:{restartCounter:this.restartCounter,iterations:this.iterations,metrics:this.measurer.getData({notMeasuredLabel:D[0],measurementOverheadLabel:D[8]})}}}buildSolvedPocketCubeFromCornerCubelet(e){const i=new Map;return e.stickers.forEach(t=>{i.set(t.side,t.color),i.set(v(t.side),B(t.color))}),new f({colorMap:i,dimension:this.initialState.getDimension()})}}var te={},Se={get exports(){return te},set exports(s){te=s}},se={},Ae={get exports(){return se},set exports(s){se=s}};(function(s,e){(function(){var i,t,n,r,d,T,E,O,R,S,le,de,ne,q,K;n=Math.floor,S=Math.min,t=function(a,h){return a<h?-1:a>h?1:0},R=function(a,h,l,c,m){var p;if(l==null&&(l=0),m==null&&(m=t),l<0)throw new Error("lo must be non-negative");for(c==null&&(c=a.length);l<c;)p=n((l+c)/2),m(h,a[p])<0?c=p:l=p+1;return[].splice.apply(a,[l,l-l].concat(h)),h},T=function(a,h,l){return l==null&&(l=t),a.push(h),q(a,0,a.length-1,l)},d=function(a,h){var l,c;return h==null&&(h=t),l=a.pop(),a.length?(c=a[0],a[0]=l,K(a,0,h)):c=l,c},O=function(a,h,l){var c;return l==null&&(l=t),c=a[0],a[0]=h,K(a,0,l),c},E=function(a,h,l){var c;return l==null&&(l=t),a.length&&l(a[0],h)<0&&(c=[a[0],h],h=c[0],a[0]=c[1],K(a,0,l)),h},r=function(a,h){var l,c,m,p,C,A;for(h==null&&(h=t),p=function(){A=[];for(var y=0,L=n(a.length/2);0<=L?y<L:y>L;0<=L?y++:y--)A.push(y);return A}.apply(this).reverse(),C=[],c=0,m=p.length;c<m;c++)l=p[c],C.push(K(a,l,h));return C},ne=function(a,h,l){var c;if(l==null&&(l=t),c=a.indexOf(h),c!==-1)return q(a,0,c,l),K(a,c,l)},le=function(a,h,l){var c,m,p,C,A;if(l==null&&(l=t),m=a.slice(0,h),!m.length)return m;for(r(m,l),A=a.slice(h),p=0,C=A.length;p<C;p++)c=A[p],E(m,c,l);return m.sort(l).reverse()},de=function(a,h,l){var c,m,p,C,A,y,L,X,oe;if(l==null&&(l=t),h*10<=a.length){if(p=a.slice(0,h).sort(l),!p.length)return p;for(m=p[p.length-1],L=a.slice(h),C=0,y=L.length;C<y;C++)c=L[C],l(c,m)<0&&(R(p,c,0,null,l),p.pop(),m=p[p.length-1]);return p}for(r(a,l),oe=[],A=0,X=S(h,a.length);0<=X?A<X:A>X;0<=X?++A:--A)oe.push(d(a,l));return oe},q=function(a,h,l,c){var m,p,C;for(c==null&&(c=t),m=a[l];l>h;){if(C=l-1>>1,p=a[C],c(m,p)<0){a[l]=p,l=C;continue}break}return a[l]=m},K=function(a,h,l){var c,m,p,C,A;for(l==null&&(l=t),m=a.length,A=h,p=a[h],c=2*h+1;c<m;)C=c+1,C<m&&!(l(a[c],a[C])<0)&&(c=C),a[h]=a[c],h=c,c=2*h+1;return a[h]=p,q(a,A,h,l)},i=function(){a.push=T,a.pop=d,a.replace=O,a.pushpop=E,a.heapify=r,a.updateItem=ne,a.nlargest=le,a.nsmallest=de;function a(h){this.cmp=h??t,this.nodes=[]}return a.prototype.push=function(h){return T(this.nodes,h,this.cmp)},a.prototype.pop=function(){return d(this.nodes,this.cmp)},a.prototype.peek=function(){return this.nodes[0]},a.prototype.contains=function(h){return this.nodes.indexOf(h)!==-1},a.prototype.replace=function(h){return O(this.nodes,h,this.cmp)},a.prototype.pushpop=function(h){return E(this.nodes,h,this.cmp)},a.prototype.heapify=function(){return r(this.nodes,this.cmp)},a.prototype.updateItem=function(h){return ne(this.nodes,h,this.cmp)},a.prototype.clear=function(){return this.nodes=[]},a.prototype.empty=function(){return this.nodes.length===0},a.prototype.size=function(){return this.nodes.length},a.prototype.clone=function(){var h;return h=new a,h.nodes=this.nodes.slice(0),h},a.prototype.toArray=function(){return this.nodes.slice(0)},a.prototype.insert=a.prototype.push,a.prototype.top=a.prototype.peek,a.prototype.front=a.prototype.peek,a.prototype.has=a.prototype.contains,a.prototype.copy=a.prototype.clone,a}(),function(a,h){return s.exports=h()}(this,function(){return i})}).call(ce)})(Ae),function(s){s.exports=se}(Se);var Oe=pe(te),g=(s=>(s[s.ADD_CANDIDATE=0]="ADD_CANDIDATE",s[s.POP_CANDIDATE=1]="POP_CANDIDATE",s[s.CHECK_SOLUTION=2]="CHECK_SOLUTION",s[s.BREATHING_TIME=3]="BREATHING_TIME",s[s.HASH_CALCULATION=4]="HASH_CALCULATION",s[s.VISISTED_LIST_CHECK=5]="VISISTED_LIST_CHECK",s[s.ADD_TO_VISISTED_LIST_CHECK=6]="ADD_TO_VISISTED_LIST_CHECK",s[s.PERFORM_ROTATION=7]="PERFORM_ROTATION",s[s.NOT_MEASURED=8]="NOT_MEASURED",s[s.HEURISTIC_CALCULATION=9]="HEURISTIC_CALCULATION",s[s.GET_ALL_CUBELETS=10]="GET_ALL_CUBELETS",s[s.CUBELET_FINAL_POSITION=11]="CUBELET_FINAL_POSITION",s[s.CUBELET_SIMILARITY=12]="CUBELET_SIMILARITY",s[s.ITERATION=13]="ITERATION",s[s.SOLUTION_CREATION=14]="SOLUTION_CREATION",s[s.MEASUREMENT_OVERHEAD=15]="MEASUREMENT_OVERHEAD",s[s.ITERATIONS_COUNTER_INCREMENT=16]="ITERATIONS_COUNTER_INCREMENT",s[s.ABORTED_VERIFICATION=17]="ABORTED_VERIFICATION",s[s.BUILD_SOLUTION=18]="BUILD_SOLUTION",s))(g||{});class be{constructor(e){u(this,"measurer");u(this,"candidates");u(this,"visitedChecklist");u(this,"actions");u(this,"dimension");u(this,"goalStateHash");u(this,"aborted");this.aborted=!1,this.dimension=e.getDimension(),this.candidates=new Oe((r,d)=>r.cost+ie.heuristicWeight*r.heuristicValue-(d.cost+ie.heuristicWeight*d.heuristicValue)),this.visitedChecklist=new Map;const i={cost:0,heuristicValue:0,cube:e,rotation:void 0,parentHash:void 0,hash:e.getHash()};this.candidates.push(i),this.actions=[];const t=e.getCubeletsBySides(o.BACK,o.LEFT,o.DOWN)[0],n=this.buildSolvedPocketCubeFromCornerCubelet(t);this.goalStateHash=n.getHash(),[o.FRONT,o.UP,o.RIGHT].map(r=>[!0,!1].map(d=>{this.actions.push({side:r,counterClockwiseDirection:d,layer:0})})),this.measurer=new M}async findSolution(){return new Promise((e,i)=>{this.measurer.start();let t,n=0,r=0;for(;this.measurer.add(g[16],()=>this.candidates.size()>0);){if(this.measurer.add(g[17],()=>this.aborted))return i();if(this.measurer.add(g[16],()=>++n),t=this.measurer.add(g[1],()=>this.candidates.pop()),!this.measurer.add(g[5],()=>this.visitedChecklist.has(t.hash))){if(++r,this.measurer.add(g[2],()=>t.hash===this.goalStateHash))return e(this.measurer.add(g[14],()=>this.createSolution(t,n,r)));this.measurer.add(g[6],()=>this.visitedChecklist.set(t.hash,t)),this.applyRotations(t)}}i(Error("No more candidates to explore"))})}abort(){this.aborted=!0}createSolution(e,i,t){const n=[];let r=e;return this.measurer.add(g[18],()=>{for(;r&&r.rotation;)n.unshift(r.rotation),r=this.visitedChecklist.get(r.parentHash)}),this.measurer.finish(),this.candidates.clear(),{rotations:n,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData({notMeasuredLabel:g[8],measurementOverheadLabel:g[15]}),visitedNodes:i,differentNodes:t}}}applyRotations(e){for(let i of this.actions){const t=this.measurer.add(g[7],()=>e.cube.rotateFace(i)),n=t.getHash(),r=this.measurer.add(g[9],()=>this.calculateDistanceToFinalState(t)),d={cost:e.cost+1,cube:t,rotation:i,heuristicValue:r,parentHash:e.hash,hash:n};this.measurer.add(g[5],()=>this.visitedChecklist.get(n))||this.measurer.add(g[0],()=>{this.candidates.push(d)})}}calculateDistanceToFinalState(e){const i=this.dimension*this.dimension+this.dimension*4;return e.getConfiguration().split("").filter((n,r)=>n!==this.goalStateHash[r]).length/i}buildSolvedPocketCubeFromCornerCubelet(e){const i=new Map;return e.stickers.forEach(t=>{i.set(t.side,t.color),i.set(v(t.side),B(t.color))}),new f({colorMap:i,dimension:this.dimension})}}class Re{readKeys(e,i){let t;switch(e.key.toLowerCase()){case"w":t=o.UP;break;case"a":t=o.LEFT;break;case"s":t=o.FRONT;break;case"d":t=o.RIGHT;break;case"f":t=o.BACK;break;case"x":t=o.DOWN;break}if(t!==void 0)return{side:t,counterClockwiseDirection:e.shiftKey,layer:i}}}class G{constructor(e){u(this,"moves");u(this,"findSolutionResolve");u(this,"findSolutionReject");u(this,"cube");u(this,"startTime");u(this,"keyboardInterpreter");this.cube=e,this.moves=[],this.keyboardInterpreter=new Re}async findSolution(){return this.startTime=Date.now(),new Promise((e,i)=>{this.findSolutionResolve=e,this.findSolutionReject=i})}abort(){this.findSolutionReject()}async readKeys(e){if(this.cube.isSolved())return;const i=this.keyboardInterpreter.readKeys(e);if(i!==void 0)return this.moves.push(i),this.cube=this.cube.rotateFace(i),this.cube.isSolved()&&this.findSolutionResolve({rotations:this.moves,totalTime:Date.now()-this.startTime,data:{human:!0}}),i}}const ie={heuristicWeight:50},w={mutationRate:.1,populationPerGeneration:100,maxNumOfRotations:30,elitism:15,armageddonThreshold:5e3},x={population:100,initialTemperature:.2,temperatureDecreaseRate:.75,numOfRotations:30,maxSuccessPerIteration:10,restartThreshold:1e3*1e3*1e3},he={metrics:{enabled:!0,generateReport:!1},world:{debug:!1,scrambleMoves:30,scrambleRotationDuration:100,cubesCircleRay:4.5,camera:{closeDistance:20,farDistance:55}},renderers:{translationDuration:500,rotationDuration:250,titleDistance:8.5,cubeSize:2.5},initiallySelectedCubeTypeIndex:0,cubeTypes:[{label:"2x2",dimension:2,instantiator:()=>new f({dimension:2}),methods:[{key:"Human",instantiator:s=>new G(new f({clone:s})),checked:!1,info:"Use keys 'WASDFX' combined with 'shift' to rotate cube faces"},{key:"IDDFS",instantiator:s=>new Ee(new f({clone:s})),checked:!1,info:"Interative-deepening depth-first-search. Brute force"},{key:"IDA*",instantiator:s=>new Ce(new f({clone:s})),checked:!1,info:"Interative-deepening A star. Uses number of misplaced stickers as heuristic."},{key:"GA",instantiator:s=>new Te(new f({clone:s})),checked:!0,info:`Random movements improved by genetic algorithm. Uses number of misplaced stickers as fitness function. Population: ${w.populationPerGeneration}. Elitism ${w.elitism}.  Mutation rate ${w.mutationRate}. `},{key:"SA",instantiator:s=>new ge(new f({clone:s})),checked:!0,info:`Random movements improved by simulated annealing algorithm. Uses number of misplaced stickers as a measure of a solution candidate result. Population: ${x.population}. Initial temperature: ${x.initialTemperature}. Temperature decrease rate: ${x.temperatureDecreaseRate}`},{key:"WA*",instantiator:s=>new be(new f({clone:s})),checked:!0,info:`Weighted A star. No re-expansions. Uses number of misplaced stickers as heuristic and weights the heuristic (${ie.heuristicWeight} * h(x)) value.`},{key:"BiBFS",instantiator:s=>new fe(new f({clone:s})),checked:!0,info:"Bidirectional breadth-first-search. Brute force."}]},{label:"3x3",dimension:3,instantiator:()=>new f({dimension:3}),methods:[{key:"Human",instantiator:s=>new G(new f({clone:s})),checked:!1,info:"Use keys 'WASDFX' combined with 'shift' to rotate cube faces"}]},{label:"4x4",dimension:4,instantiator:()=>new f({dimension:4}),methods:[{key:"Human",instantiator:s=>new G(new f({clone:s})),checked:!1,info:"Use keys 'WASDFX' combined with 'shift' and numbers to rotate cube faces"}]},{label:"5x5",dimension:5,instantiator:()=>new f({dimension:5}),methods:[{key:"Human",instantiator:s=>new G(new f({clone:s})),checked:!1,info:"Use keys 'WASDFX' combined with 'shift' and numbers to rotate cube faces"}]},{label:"6x6",dimension:6,instantiator:()=>new f({dimension:6}),methods:[{key:"Human",instantiator:s=>new G(new f({clone:s})),checked:!1,info:"Use keys 'WASDFX' combined with 'shift' and numbers to rotate cube faces"}]},{label:"7x7",dimension:7,instantiator:()=>new f({dimension:7}),methods:[{key:"Human",instantiator:s=>new G(new f({clone:s})),checked:!1,info:"Use keys 'WASDFX' combined with 'shift' and numbers to rotate cube faces"}]}]},Ne=s=>{for(let e of he.cubeTypes)if(e.label.toLowerCase()===s.label.toLowerCase()){for(let i of e.methods)if(i.key.toLowerCase()===s.solverTag.toLowerCase())return i;return}};let z;self.onmessage=async s=>{if(s.data.abort)z.abort();else{const e=s.data.solverTag.toLowerCase(),i=Ne(s.data);if(e&&i)if(s.data.cube)try{z=i.instantiator(s.data.cube);const t=await z.findSolution();self.postMessage({solution:JSON.stringify(t),solverKey:e})}catch(t){console.log(`Solver '${s.data.label}.${e}' aborted`,t),self.postMessage({error:`Solver '${s.data.label}.${e}' aborted`,solverTag:s.data.solverTag})}else if(s.data.keyboardEvent){if(z instanceof G){const t=await z.readKeys(s.data.keyboardEvent);t!==void 0&&self.postMessage({faceRotation:t,solverKey:e})}}else self.postMessage({error:`Command for '${s.data}' not found`,solverTag:s.data.solverTag});else self.postMessage({error:`Solver '${s.data.solverTag}' not found`,solverTag:s.data.solverTag})}}})();
