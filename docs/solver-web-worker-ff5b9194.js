var ve=Object.defineProperty;var Ie=(o,y,x)=>y in o?ve(o,y,{enumerable:!0,configurable:!0,writable:!0,value:x}):o[y]=x;var l=(o,y,x)=>(Ie(o,typeof y!="symbol"?y+"":y,x),x);(function(){"use strict";var o=(i=>(i[i.UP=0]="UP",i[i.LEFT=1]="LEFT",i[i.FRONT=2]="FRONT",i[i.RIGHT=3]="RIGHT",i[i.BACK=4]="BACK",i[i.DOWN=5]="DOWN",i))(o||{});const y=()=>Object.keys(o).filter(i=>!isNaN(Number(i))).map(i=>Number(i)),x=i=>{switch(i){case 0:return 5;case 5:return 0;case 1:return 3;case 3:return 1;case 2:return 4;case 4:return 2}};var O=(i=>(i[i.YELLOW=0]="YELLOW",i[i.ORANGE=1]="ORANGE",i[i.BLUE=2]="BLUE",i[i.RED=3]="RED",i[i.GREEN=4]="GREEN",i[i.WHITE=5]="WHITE",i))(O||{});const q=i=>{switch(i){case 2:return 4;case 4:return 2;case 3:return 1;case 1:return 3;case 0:return 5;case 5:return 0}},F=new Map;F.set(0,"y"),F.set(1,"o"),F.set(2,"b"),F.set(3,"r"),F.set(4,"g"),F.set(5,"w");const oe=i=>F.get(i),_=new Map;_.set("y",0),_.set("o",1),_.set("b",2),_.set("r",3),_.set("g",4),_.set("w",5);const J=i=>_.get(i),z=class{constructor(t){l(this,"dimension");l(this,"stickers");this.dimension=t,this.stickers=[]}create(){if(z.cubeletsCreatorMap.has(this.dimension))return z.cubeletsCreatorMap.get(this.dimension);{let t=0;y().map(c=>{for(let d=0;d<this.dimension;++d)for(let g=0;g<this.dimension;++g)this.stickers.push({side:c,x:g,y:d,id:t++})});const e=this.extractCenters(),s=this.extractCorners(),n=this.extractEdges(),a=[...s,...n,...e];return z.cubeletsCreatorMap.set(this.dimension,a),a}}cubeletsMerger(t){const e={stickers:[]};return t.forEach(s=>{this.stickers.forEach((n,a,c)=>{n.side===s.side&&s.x===n.x&&s.y===n.y&&e.stickers.push(...c.splice(a,1))})}),e}extractEdges(){const t=this.dimension-1,e=[];for(let s=1;s<this.dimension-1;++s)e.push(this.cubeletsMerger([{side:o.FRONT,x:0,y:s},{side:o.LEFT,x:t,y:s}])),e.push(this.cubeletsMerger([{side:o.FRONT,x:t,y:s},{side:o.RIGHT,x:0,y:s}])),e.push(this.cubeletsMerger([{side:o.FRONT,x:s,y:0},{side:o.UP,x:s,y:t}])),e.push(this.cubeletsMerger([{side:o.FRONT,x:s,y:t},{side:o.DOWN,x:s,y:0}])),e.push(this.cubeletsMerger([{side:o.BACK,x:t,y:s},{side:o.LEFT,x:0,y:s}])),e.push(this.cubeletsMerger([{side:o.BACK,x:0,y:s},{side:o.RIGHT,x:t,y:s}])),e.push(this.cubeletsMerger([{side:o.BACK,x:s,y:0},{side:o.UP,x:t-s,y:0}])),e.push(this.cubeletsMerger([{side:o.BACK,x:s,y:t},{side:o.DOWN,x:t-s,y:t}])),e.push(this.cubeletsMerger([{side:o.RIGHT,x:s,y:0},{side:o.UP,x:t,y:t-s}])),e.push(this.cubeletsMerger([{side:o.RIGHT,x:s,y:t},{side:o.DOWN,x:t,y:s}])),e.push(this.cubeletsMerger([{side:o.LEFT,x:s,y:0},{side:o.UP,x:0,y:s}])),e.push(this.cubeletsMerger([{side:o.LEFT,x:s,y:t},{side:o.DOWN,x:0,y:t-s}]));return e}extractCenters(){const t=this.dimension-1,e=[];return this.stickers.filter(s=>s.x!==0&&s.x!==t&&s.y!==0&&s.y!==t).forEach(s=>{e.push({stickers:[s]})}),e}extractCorners(){const t=[],e=this.dimension-1;return t.push(this.cubeletsMerger([{side:o.FRONT,x:0,y:0},{side:o.UP,x:0,y:e},{side:o.LEFT,x:e,y:0}])),t.push(this.cubeletsMerger([{side:o.FRONT,x:e,y:0},{side:o.UP,x:e,y:e},{side:o.RIGHT,x:0,y:0}])),t.push(this.cubeletsMerger([{side:o.FRONT,x:0,y:e},{side:o.DOWN,x:0,y:0},{side:o.LEFT,x:e,y:e}])),t.push(this.cubeletsMerger([{side:o.FRONT,x:e,y:e},{side:o.DOWN,x:e,y:0},{side:o.RIGHT,x:0,y:e}])),t.push(this.cubeletsMerger([{side:o.BACK,x:0,y:0},{side:o.UP,x:e,y:0},{side:o.RIGHT,x:e,y:0}])),t.push(this.cubeletsMerger([{side:o.BACK,x:e,y:0},{side:o.UP,x:0,y:0},{side:o.LEFT,x:0,y:0}])),t.push(this.cubeletsMerger([{side:o.BACK,x:0,y:e},{side:o.DOWN,x:e,y:e},{side:o.RIGHT,x:e,y:e}])),t.push(this.cubeletsMerger([{side:o.BACK,x:e,y:e},{side:o.DOWN,x:0,y:e},{side:o.LEFT,x:0,y:e}])),t}};let Z=z;l(Z,"cubeletsCreatorMap",new Map);const Q=new Map;class ce{constructor(t){l(this,"dimension");if(this.dimension=t,!Q.has(this.dimension)){const e=new Map;for(let s=0;s<this.dimension;++s){console.log(`Creating rotation map for layer: ${s} of ${t}x${t} cubes`);const n=this.createUpFaceClockwiseRotator(s),a=this.createLeftFaceClockwiseRotator(s),c=this.createFrontFaceClockwiseRotator(s),d=this.createRightFaceClockwiseRotator(s),g=this.createBackFaceClockwiseRotator(s),f=this.createDownFaceClockwiseRotator(s),m=new Map;m.set(o.UP,n.map(C=>this.faceStickerMapper(C))),m.set(o.LEFT,a.map(C=>this.faceStickerMapper(C))),m.set(o.FRONT,c.map(C=>this.faceStickerMapper(C))),m.set(o.RIGHT,d.map(C=>this.faceStickerMapper(C))),m.set(o.BACK,g.map(C=>this.faceStickerMapper(C))),m.set(o.DOWN,f.map(C=>this.faceStickerMapper(C))),e.set(s,m)}Q.set(this.dimension,e)}}rotate(t,e){const s=new w({clone:t.getConfiguration()}),n=[];return Q.get(this.dimension).get(e.layer||0).get(e.side).forEach(a=>{e.counterClockwiseDirection?n.push({index:a.source,color:t.getColorOfIndex(a.destination)}):n.push({index:a.destination,color:t.getColorOfIndex(a.source)})}),s.setColorsOfIndexes(n),s}idMapper(t){let e=t.side*this.dimension*this.dimension;return e+=this.dimension*t.y,e+=t.x,e}faceStickerMapper(t){return{source:this.idMapper(t.source),destination:this.idMapper(t.destination)}}createSideLidClockwiseRotator(t){const e=[];for(let s=0;s<this.dimension*this.dimension;++s){const n=s%this.dimension,a=Math.floor(s/this.dimension),c=this.dimension-1-a,d=n;e.push({source:{side:t,x:n,y:a},destination:{side:t,x:c,y:d}})}return e}createUpFaceClockwiseRotator(t){this.dimension-1;const e=[];t===0&&e.push(...this.createSideLidClockwiseRotator(o.UP));for(let s=0;s<this.dimension;++s)e.push({source:{side:o.FRONT,x:s,y:t},destination:{side:o.LEFT,x:s,y:t}}),e.push({source:{side:o.LEFT,x:s,y:t},destination:{side:o.BACK,x:s,y:t}}),e.push({source:{side:o.BACK,x:s,y:t},destination:{side:o.RIGHT,x:s,y:t}}),e.push({source:{side:o.RIGHT,x:s,y:t},destination:{side:o.FRONT,x:s,y:t}});return e}createLeftFaceClockwiseRotator(t){const e=this.dimension-1,s=[];t===0&&s.push(...this.createSideLidClockwiseRotator(o.LEFT));for(let n=0;n<this.dimension;++n)s.push({source:{side:o.FRONT,x:t,y:n},destination:{side:o.DOWN,x:t,y:n}}),s.push({source:{side:o.DOWN,x:t,y:n},destination:{side:o.BACK,x:e-t,y:e-n}}),s.push({source:{side:o.BACK,x:e-t,y:e-n},destination:{side:o.UP,x:t,y:n}}),s.push({source:{side:o.UP,x:t,y:n},destination:{side:o.FRONT,x:t,y:n}});return s}createFrontFaceClockwiseRotator(t){const e=this.dimension-1,s=[];t===0&&s.push(...this.createSideLidClockwiseRotator(o.FRONT));for(let n=0;n<this.dimension;++n)s.push({source:{side:o.UP,x:n,y:e-t},destination:{side:o.RIGHT,x:t,y:n}}),s.push({source:{side:o.RIGHT,x:t,y:n},destination:{side:o.DOWN,x:e-n,y:t}}),s.push({source:{side:o.DOWN,x:e-n,y:t},destination:{side:o.LEFT,x:e-t,y:e-n}}),s.push({source:{side:o.LEFT,x:e-t,y:e-n},destination:{side:o.UP,x:n,y:e-t}});return s}createRightFaceClockwiseRotator(t){const e=this.dimension-1,s=[];t===0&&s.push(...this.createSideLidClockwiseRotator(o.RIGHT));for(let n=0;n<this.dimension;++n)s.push({source:{side:o.UP,x:e-t,y:n},destination:{side:o.BACK,x:t,y:e-n}}),s.push({source:{side:o.BACK,x:t,y:e-n},destination:{side:o.DOWN,x:e-t,y:n}}),s.push({source:{side:o.DOWN,x:e-t,y:n},destination:{side:o.FRONT,x:e-t,y:n}}),s.push({source:{side:o.FRONT,x:e-t,y:n},destination:{side:o.UP,x:e-t,y:n}});return s}createBackFaceClockwiseRotator(t){const e=this.dimension-1,s=[];t===0&&s.push(...this.createSideLidClockwiseRotator(o.BACK));for(let n=0;n<this.dimension;++n)s.push({source:{side:o.LEFT,x:t,y:n},destination:{side:o.DOWN,x:n,y:e-t}}),s.push({source:{side:o.DOWN,x:n,y:e-t},destination:{side:o.RIGHT,x:e-t,y:e-n}}),s.push({source:{side:o.RIGHT,x:e-t,y:e-n},destination:{side:o.UP,x:e-n,y:t}}),s.push({source:{side:o.UP,x:e-n,y:t},destination:{side:o.LEFT,x:t,y:n}});return s}createDownFaceClockwiseRotator(t){const e=this.dimension-1,s=[];t===0&&s.push(...this.createSideLidClockwiseRotator(o.DOWN));for(let n=0;n<this.dimension;++n)s.push({source:{side:o.LEFT,x:n,y:e-t},destination:{side:o.FRONT,x:n,y:e-t}}),s.push({source:{side:o.FRONT,x:n,y:e-t},destination:{side:o.RIGHT,x:n,y:e-t}}),s.push({source:{side:o.RIGHT,x:n,y:e-t},destination:{side:o.BACK,x:n,y:e-t}}),s.push({source:{side:o.BACK,x:n,y:e-t},destination:{side:o.LEFT,x:n,y:e-t}});return s}}const L=new Map;L.set(o.FRONT,O.BLUE),L.set(o.UP,O.YELLOW),L.set(o.RIGHT,O.RED),L.set(o.LEFT,O.ORANGE),L.set(o.BACK,O.GREEN),L.set(o.DOWN,O.WHITE);class w{constructor(t){l(this,"configuration");l(this,"dimension");l(this,"faceRotator");l(this,"cubelets");if(this.dimension=t==null?void 0:t.dimension,t!=null&&t.clone)this.dimension=Math.sqrt(t.clone.length/6),this.configuration=t.clone.slice();else{const e=this.dimension*this.dimension,s=(t==null?void 0:t.colorMap)||L,n=y();this.configuration="";for(let a=0;a<n.length;++a){const c=s.get(a),d=oe(c);this.configuration+=d.repeat(e)}}this.faceRotator=new ce(this.dimension),this.cubelets=new Z(this.dimension).create()}clone(){return new w({clone:this.configuration})}getDimension(){return this.dimension}getConfiguration(){return this.configuration}getHash(){return this.configuration}translateCubeBits(){return this.configuration}isSolved(){const t=this.dimension*this.dimension,e=y(),s=Array.from(new Array(t));return e.every((n,a)=>s.every((c,d)=>this.configuration[a*t+d]===this.configuration[a*t]))}rotateFace(t){return this.faceRotator.rotate(this,t)}getAllCubelets(){return this.addColorToCubelets(this.cubelets)}getAllColorlessCubelets(){return this.cubelets}getCubeletsBySides(...t){const e=this.cubelets.filter(s=>s.stickers.every(n=>t.includes(n.side)));return this.addColorToCubelets(e)}getCubeletsByColor(...t){const e=this.cubelets.filter(s=>s.stickers.every(n=>t.includes(J(this.configuration[n.id]))));return this.addColorToCubelets(e)}getColorOfIndex(t){return J(this.configuration[t])}setColorsOfIndexes(t){const e=this.configuration.split("");t.forEach(s=>{e[s.index]=oe(s.color)}),this.configuration=e.join("")}addColorToCubelets(t){return t.map(e=>({stickers:e.stickers.map(s=>({...s,color:J(this.configuration[s.id])}))}))}}class he{readKeys(t){let e;switch(t.key.toLowerCase()){case"w":e=o.UP;break;case"a":e=o.LEFT;break;case"s":e=o.FRONT;break;case"d":e=o.RIGHT;break;case"f":e=o.BACK;break;case"x":e=o.DOWN;break}if(e!==void 0)return{side:e,counterClockwiseDirection:t.shiftKey,layer:0}}}class H{constructor(t){l(this,"moves");l(this,"findSolutionResolve");l(this,"findSolutionReject");l(this,"cube");l(this,"startTime");l(this,"keyboardInterpreter");this.cube=t,this.moves=[],this.keyboardInterpreter=new he}async findSolution(){return this.startTime=Date.now(),new Promise((t,e)=>{this.findSolutionResolve=t,this.findSolutionReject=e})}abort(){this.findSolutionReject()}async readKeys(t){if(this.cube.isSolved())return;const e=this.keyboardInterpreter.readKeys(t);if(e!==void 0)return this.moves.push(e),this.cube=this.cube.rotateFace(e),this.cube.isSolved()&&this.findSolutionResolve({rotations:this.moves,totalTime:Date.now()-this.startTime,data:{human:!0}}),e}}var le=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function de(i){return i&&i.__esModule&&Object.prototype.hasOwnProperty.call(i,"default")?i.default:i}var ee={},pe={get exports(){return ee},set exports(i){ee=i}},te={},fe={get exports(){return te},set exports(i){te=i}};(function(i,t){(function(){var e,s,n,a,c,d,g,f,m,C,j,P,ie,X,G;n=Math.floor,C=Math.min,s=function(r,u){return r<u?-1:r>u?1:0},m=function(r,u,h,p,R){var T;if(h==null&&(h=0),R==null&&(R=s),h<0)throw new Error("lo must be non-negative");for(p==null&&(p=r.length);h<p;)T=n((h+p)/2),R(u,r[T])<0?p=T:h=T+1;return[].splice.apply(r,[h,h-h].concat(u)),u},d=function(r,u,h){return h==null&&(h=s),r.push(u),X(r,0,r.length-1,h)},c=function(r,u){var h,p;return u==null&&(u=s),h=r.pop(),r.length?(p=r[0],r[0]=h,G(r,0,u)):p=h,p},f=function(r,u,h){var p;return h==null&&(h=s),p=r[0],r[0]=u,G(r,0,h),p},g=function(r,u,h){var p;return h==null&&(h=s),r.length&&h(r[0],u)<0&&(p=[r[0],u],u=p[0],r[0]=p[1],G(r,0,h)),u},a=function(r,u){var h,p,R,T,S,b;for(u==null&&(u=s),T=function(){b=[];for(var k=0,D=n(r.length/2);0<=D?k<D:k>D;0<=D?k++:k--)b.push(k);return b}.apply(this).reverse(),S=[],p=0,R=T.length;p<R;p++)h=T[p],S.push(G(r,h,u));return S},ie=function(r,u,h){var p;if(h==null&&(h=s),p=r.indexOf(u),p!==-1)return X(r,0,p,h),G(r,p,h)},j=function(r,u,h){var p,R,T,S,b;if(h==null&&(h=s),R=r.slice(0,u),!R.length)return R;for(a(R,h),b=r.slice(u),T=0,S=b.length;T<S;T++)p=b[T],g(R,p,h);return R.sort(h).reverse()},P=function(r,u,h){var p,R,T,S,b,k,D,V,ne;if(h==null&&(h=s),u*10<=r.length){if(T=r.slice(0,u).sort(h),!T.length)return T;for(R=T[T.length-1],D=r.slice(u),S=0,k=D.length;S<k;S++)p=D[S],h(p,R)<0&&(m(T,p,0,null,h),T.pop(),R=T[T.length-1]);return T}for(a(r,h),ne=[],b=0,V=C(u,r.length);0<=V?b<V:b>V;0<=V?++b:--b)ne.push(c(r,h));return ne},X=function(r,u,h,p){var R,T,S;for(p==null&&(p=s),R=r[h];h>u;){if(S=h-1>>1,T=r[S],p(R,T)<0){r[h]=T,h=S;continue}break}return r[h]=R},G=function(r,u,h){var p,R,T,S,b;for(h==null&&(h=s),R=r.length,b=u,T=r[u],p=2*u+1;p<R;)S=p+1,S<R&&!(h(r[p],r[S])<0)&&(p=S),r[u]=r[p],u=p,p=2*u+1;return r[u]=T,X(r,b,u,h)},e=function(){r.push=d,r.pop=c,r.replace=f,r.pushpop=g,r.heapify=a,r.updateItem=ie,r.nlargest=j,r.nsmallest=P;function r(u){this.cmp=u??s,this.nodes=[]}return r.prototype.push=function(u){return d(this.nodes,u,this.cmp)},r.prototype.pop=function(){return c(this.nodes,this.cmp)},r.prototype.peek=function(){return this.nodes[0]},r.prototype.contains=function(u){return this.nodes.indexOf(u)!==-1},r.prototype.replace=function(u){return f(this.nodes,u,this.cmp)},r.prototype.pushpop=function(u){return g(this.nodes,u,this.cmp)},r.prototype.heapify=function(){return a(this.nodes,this.cmp)},r.prototype.updateItem=function(u){return ie(this.nodes,u,this.cmp)},r.prototype.clear=function(){return this.nodes=[]},r.prototype.empty=function(){return this.nodes.length===0},r.prototype.size=function(){return this.nodes.length},r.prototype.clone=function(){var u;return u=new r,u.nodes=this.nodes.slice(0),u},r.prototype.toArray=function(){return this.nodes.slice(0)},r.prototype.insert=r.prototype.push,r.prototype.top=r.prototype.peek,r.prototype.front=r.prototype.peek,r.prototype.has=r.prototype.contains,r.prototype.copy=r.prototype.clone,r}(),function(r,u){return i.exports=u()}(this,function(){return e})}).call(le)})(fe),function(i){i.exports=te}(pe);var me=de(ee);class Y{constructor(t=!0){l(this,"map");l(this,"startTime");l(this,"totalTime");l(this,"stack",[]);l(this,"enabled");this.map=new Map,this.stack=[],this.enabled=t}add(t,e){if(!this.enabled)return e();this.stack.push(t);const s=new Date().getTime(),n=e(),c={elapsedTime:new Date().getTime()-s,stack:this.stack.join("."),stackSize:this.stack.length};return this.map.set(t,(this.map.get(t)||[]).concat(c)),this.stack.pop(),n}start(){this.startTime=Date.now()}finish(){this.startTime&&(this.totalTime=Date.now()-this.startTime)}getTotalTime(){return this.totalTime}getData(t){const e=[];if(this.totalTime){let s=0;Array.from(this.map.entries()).forEach(n=>{const[a,c]=n;s+=c.reduce((d,g)=>d+g.elapsedTime,0),e.push(this.createSummary(s,c.length,a))}),t&&e.push(this.createSummary(this.totalTime-s,0,t))}return e}createSummary(t,e,s){return{label:s,sumTimes:t,percentageRelativeTime:Math.trunc(1e3*t/this.totalTime)/10,numOfCalls:e,avgTime:10*Math.trunc(1e6*t*1/(e||1))/10}}}var N=(i=>(i[i.ADD_CANDIDATE=0]="ADD_CANDIDATE",i[i.POP_CANDIDATE=1]="POP_CANDIDATE",i[i.CHECK_SOLUTION=2]="CHECK_SOLUTION",i[i.BREATHING_TIME=3]="BREATHING_TIME",i[i.HASH_CALCULATION=4]="HASH_CALCULATION",i[i.VISISTED_LIST_CHECK=5]="VISISTED_LIST_CHECK",i[i.ADD_TO_VISISTED_LIST_CHECK=6]="ADD_TO_VISISTED_LIST_CHECK",i[i.PERFORM_ROTATION=7]="PERFORM_ROTATION",i[i.NOT_MEASURED=8]="NOT_MEASURED",i[i.HEURISTIC_CALCULATION=9]="HEURISTIC_CALCULATION",i[i.GET_ALL_CUBELETS=10]="GET_ALL_CUBELETS",i[i.CUBELET_FINAL_POSITION=11]="CUBELET_FINAL_POSITION",i[i.CUBELET_SIMILARITY=12]="CUBELET_SIMILARITY",i[i.ITERATION=13]="ITERATION",i))(N||{});class ge{constructor(t){l(this,"measurer");l(this,"candidates");l(this,"goalState");l(this,"visitedChecklist");l(this,"actions");l(this,"dimension");l(this,"goalStateCubelets");l(this,"goalStateHash");l(this,"aborted");this.aborted=!1,this.dimension=t.getDimension(),this.measurer=new Y(ue.metrics.enabled),this.candidates=new me((n,a)=>n.cost-a.cost),this.visitedChecklist=new Map;const e={cost:0,cube:t,rotation:void 0,parent:void 0,hash:t.getHash()};this.candidates.push(e),this.actions=[];const s=t.getCubeletsBySides(o.BACK,o.LEFT,o.DOWN)[0];this.goalState=this.buildSolvedPocketCubeFromCornerCubelet(s),this.goalStateHash=this.goalState.getHash(),this.goalStateCubelets=new Map,this.goalState.getAllCubelets().forEach(n=>{const a=n.stickers.map(d=>d.color).sort().toString(),c=n.stickers.map(d=>d.side);this.goalStateCubelets.set(a,c)}),[o.FRONT,o.UP,o.RIGHT].map(n=>[!0,!1].map(a=>{this.actions.push({side:n,counterClockwiseDirection:a,layer:0})}))}async findSolution(){return new Promise((t,e)=>{this.measurer.start();let s,n=0;for(;this.candidates.size()>0;){if(this.aborted)return e();if(++n,s=this.measurer.add(N[1],()=>this.candidates.pop()),n%1e3===0&&console.log(n,s.cost),this.measurer.add(N[5],()=>this.visitedChecklist.has(s.hash)))return;if(this.measurer.add(N[2],()=>s.hash===this.goalStateHash))return this.measurer.finish(),this.candidates.clear(),t(this.createSolution(s,n));this.measurer.add(N[6],()=>this.visitedChecklist.set(s.hash,!0)),this.applyRotations(s)}e(Error("No more candidates to explore"))})}abort(){this.aborted=!0}createSolution(t,e){const s=[];let n=t;for(;n&&n.rotation;)s.unshift(n.rotation),n=n.parent;return{rotations:s,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData(N[8]),iterations:e}}}applyRotations(t){this.actions.forEach(e=>{const s=this.measurer.add(N[7],()=>t.cube.rotateFace(e)),n=this.measurer.add(N[4],()=>s.getHash()),a=this.measurer.add(N[9],()=>this.calculateDistanceToFinalState(s));this.measurer.add(N[5],()=>this.visitedChecklist.has(n))||this.measurer.add(N[0],()=>{this.candidates.push({cost:t.cost+1+a,cube:s,rotation:e,parent:t,hash:n})})})}calculateDistanceToFinalState(t){const e=this.dimension*this.dimension+this.dimension*4;return t.getConfiguration().split("").filter((n,a)=>n!==this.goalStateHash[a]).length/e}buildSolvedPocketCubeFromCornerCubelet(t){const e=new Map;return t.stickers.forEach(s=>{e.set(s.side,s.color),e.set(x(s.side),q(s.color))}),new w({colorMap:e,dimension:this.dimension})}}var Te=E;function E(){this._start=null,this._end=null,this.length=0}E.prototype.unShift=function(i){if(this._start===null)this._start=M(i),this._end=this._start;else{var t=this._start;this._start.previous=M(i),this._start=this._start.previous,this._start.next=t}this.length++},E.prototype.push=function(i){if(this._start===null)this._start=M(i),this._end=this._start;else{var t=this._end;this._end.next=M(i),this._end=this._end.next,this._end.previous=t}this.length++},E.prototype.add=function(i,t){if(i%1===0)if(i<=0)this.unShift(t);else if(i>=this.length)this.push(t);else{var e=se.call(this,i);if(e){var s=e.previous,n=e,a=M(t);a.previous=s,s.next=a,a.next=n,n.previous=a,this.length++}}},E.prototype.shift=function(){if(this._start){var i=this._start.data;return this._start.next===null?(this._end=null,this._start=null):(this._start=this._start.next,this._start.previous=null),this.length--,i}else return},E.prototype.pop=function(){if(this._end){var i=this._end.data;return this._end.previous===null?(this._end=null,this._start=null):(this._end=this._end.previous,this._end.next=null),this.length--,i}else return},E.prototype.remove=function(i){if(i===0)return this.shift();if(i===this.length-1)return this.pop();var t=se.call(this,i);if(t){var e=t.previous,s=t.next;e.next=s,s.previous=e,this.length--}else return},E.prototype.first=function(){if(this._start)return this._start.data},E.prototype.last=function(){if(this._end)return this._end.data},E.prototype.get=function(i){var t=se.call(this,i);if(t)return t.data},E.prototype.toString=function(){for(var i=this._start,t="",e=0;e<this.length;e++)typeof i.data=="object"?t+=JSON.stringify(i.data):t+=i.data,e!==this.length-1&&(t+=", "),i=i.next;return t};function M(i){return{data:i,previous:null,next:null}}function se(i){var t,e;if(i>=this.length||i<0||i%1!==0)t=null;else if(i<this.length/2)for(t=this._start,e=0;e<i;e++)t=t.next;else for(t=this._end,e=this.length-1;e>i;e--)t=t.previous;return t}var v=(i=>(i[i.ADD_CANDIDATE=0]="ADD_CANDIDATE",i[i.POP_CANDIDATE=1]="POP_CANDIDATE",i[i.CHECK_SOLUTION=2]="CHECK_SOLUTION",i[i.BREATHING_TIME=3]="BREATHING_TIME",i[i.HASH_CALCULATION=4]="HASH_CALCULATION",i[i.VISISTED_LIST_CHECK=5]="VISISTED_LIST_CHECK",i[i.ADD_TO_VISISTED_LIST_CHECK=6]="ADD_TO_VISISTED_LIST_CHECK",i[i.PERFORM_ROTATION=7]="PERFORM_ROTATION",i[i.NOT_MEASURED=8]="NOT_MEASURED",i))(v||{});class Ce{constructor(t){l(this,"measurer");l(this,"candidates");l(this,"visitedChecklist");l(this,"actions");l(this,"aborted");this.measurer=new Y,this.visitedChecklist=new Map,this.candidates=new Te,this.aborted=!1;const e={cube:t,rotation:void 0,parent:void 0};this.candidates.push(e),this.actions=this.createActions()}abort(){this.aborted=!0}async findSolution(){return new Promise((t,e)=>{this.measurer.start();let s,n=0;for(;this.candidates.length>0;){if(this.aborted)return e();if(++n,s=this.measurer.add(v[1],()=>this.candidates.shift()),!this.measurer.add(v[5],()=>this.visitedChecklist.has(s.cube.getHash()))){if(this.measurer.add(v[2],()=>s.cube.isSolved()))return this.measurer.finish(),t(this.createSolution(s,n));this.measurer.add(v[6],()=>this.visitedChecklist.set(s.cube.getHash(),!0)),this.applyRotations(s)}}e(Error("No more candidates to explore"))})}createActions(){const t=[],e=[o.RIGHT,o.LEFT][Math.floor(Math.random()*2)],s=[o.UP,o.DOWN][Math.floor(Math.random()*2)],n=[o.FRONT,o.BACK][Math.floor(Math.random()*2)];return[e,s,n].map(a=>[!0,!1].map(c=>{t.push({side:a,counterClockwiseDirection:c,layer:0})})),t}createSolution(t,e){const s=[];let n=t;for(;n&&n.rotation;)s.unshift(n.rotation),n=n.parent;return{rotations:s,totalTime:this.measurer.getTotalTime(),data:{metrics:this.measurer.getData(v[8]),iterations:e}}}applyRotations(t){this.actions.forEach(e=>{const s=this.measurer.add(v[7],()=>t.cube.rotateFace(e));this.measurer.add(v[5],()=>this.visitedChecklist.has(s.getHash()))||this.measurer.add(v[0],()=>{this.candidates.push({cube:s,rotation:e,parent:t})})})}}class re{constructor(t,e){l(this,"mutationRate");l(this,"populationPerGeneration");l(this,"generationsCounter");this.generationsCounter=0,this.mutationRate=t,this.populationPerGeneration=e}createNextGeneration(t){++this.generationsCounter;const e=t.reduce((n,a)=>n+a.score,0),s=t.map(n=>({genes:n.genes,score:parseFloat(n.score.toString())/e}));return Array.from(Array(this.populationPerGeneration)).map(()=>this.createNewCitizen(this.pickOne(s),this.pickOne(s)))}getGenerationsCounter(){return this.generationsCounter}createNewCitizen(t,e){const s=Math.floor(Math.random()*t.genes.length);return{genes:t.genes.map((a,c)=>{let d=t.genes[c];return c>s&&(d=e.genes[c]),Math.random()<this.mutationRate&&(d*=Math.random()*2-1),d}),score:NaN}}pickOne(t){let e=0,s=Math.random();for(;s>0;)s-=t[e].score,++e;return--e,t[e]}}class B{constructor(t,e){l(this,"weights");l(this,"config");if(this.config=t,e)this.weights=e;else{const s=(this.config.inputs+this.config.outputs)*this.config.hiddenNeurons;this.weights=Array.from(Array(s)).map(()=>Math.random()*2-1)}}getWeights(){return this.weights}doTheMagic(t){if(t.length!==this.config.inputs)throw new Error(`Amount of function argument '${t.length}' should match configuration inputs quantity '${this.config.inputs}'`);const e=B.processLayer(t,this.weights.filter((s,n)=>n>=0&&n<this.config.inputs*this.config.hiddenNeurons),this.config.hiddenNeurons);return B.processLayer(e,this.weights.filter((s,n)=>n>=this.config.inputs*this.config.hiddenNeurons),this.config.outputs)}static processLayer(t,e,s){const n=Array.from(Array(s)).map(()=>0);return e.reduce((a,c,d)=>(a[d%s]+=c*t[d%t.length],a),n).map(a=>Math.tanh(a))}}const ae=(i,t)=>i.layer===t.layer&&i.side===t.side&&i.counterClockwiseDirection===t.counterClockwiseDirection,Re=(i,t)=>i.layer===t.layer&&i.side===t.side&&i.counterClockwiseDirection!==t.counterClockwiseDirection,Se=i=>({layer:i.layer,side:i.side,counterClockwiseDirection:!i.counterClockwiseDirection});class we{tune(t){const e=[];let s,n=!1,a=0;for(let c of t){if(s&&Re(c,s))e.pop(),n=!0,a=0;else{if(s&&ae(s,c)&&(++a,a===3)){e.pop(),e.pop(),e.push(Se(c)),a=0,n=!0;continue}s||++a,e.push(c)}s=c}return n?this.tune(e):e}}var K=(i=>(i[i.NOT_MEASURED=0]="NOT_MEASURED",i[i.RUN_NEURAL_NETWORK=1]="RUN_NEURAL_NETWORK",i[i.CALCULATE_CITIZEN_SCORE=2]="CALCULATE_CITIZEN_SCORE",i[i.ROTATIONS_TUNING=3]="ROTATIONS_TUNING",i))(K||{});const be=i=>i.toString(2).replace(/0/g,"").length;class ye{constructor(t){l(this,"measurer");l(this,"inputs");l(this,"initialState");l(this,"actions");l(this,"neuroGeneticAlgorithm");l(this,"citizens");l(this,"aborted");l(this,"armageddonCounter");this.aborted=!1,this.measurer=new Y,this.armageddonCounter=0,this.neuroGeneticAlgorithm=new re(A.geneticData.mutationRate,A.geneticData.populationPerGeneration),this.initialState=t.clone(),this.inputs=t.getConfiguration().length,this.actions=[],this.actions=[],[o.FRONT,o.UP,o.RIGHT].map(e=>[!0,!1].map(s=>{this.actions.push({side:e,counterClockwiseDirection:s,layer:0})})),this.citizens=this.createNewPopulationFromScratch()}async findSolution(){return this.measurer.start(),new Promise((t,e)=>{for(;;){if(this.aborted)return e();for(let s of this.citizens)if(this.runCitizen(s))return t(this.createSolution(s));this.neuroGeneticAlgorithm.getGenerationsCounter()>A.geneticData.armageddonThreshold?(++this.armageddonCounter,this.citizens=this.createNewPopulationFromScratch()):this.citizens=this.createNewPopulationFromPreviousOne()}})}abort(){this.aborted=!0}createNewPopulationFromScratch(){return this.neuroGeneticAlgorithm=new re(A.geneticData.mutationRate,A.geneticData.populationPerGeneration),this.actions.sort(()=>Math.random()*2-1),Array.from(new Array(A.geneticData.populationPerGeneration)).map(()=>{const t=new B({inputs:this.inputs,hiddenNeurons:A.neuralNetworkData.hiddenNeurons,outputs:this.actions.length});return{genes:t.getWeights(),neuralNetwork:t,cube:this.initialState.clone(),moves:[]}})}createNewPopulationFromPreviousOne(){return this.neuroGeneticAlgorithm.createNextGeneration(this.citizens.map(t=>({genes:t.genes,score:this.calculateCitizenScore(t)}))).map(t=>{const e=new B({inputs:this.inputs,hiddenNeurons:A.neuralNetworkData.hiddenNeurons,outputs:this.actions.length},t.genes);return{genes:t.genes,neuralNetwork:e,cube:this.initialState.clone(),moves:[]}})}runCitizen(t){return Array.from(new Array(A.neuralNetworkData.iterations)).reduce(e=>e||this.measurer.add(K[1],()=>{const s=t.neuralNetwork.doTheMagic(t.cube.getConfiguration());let n=0;for(let a of s){if(a>.75){const c=this.actions[n];if(t.cube=t.cube.rotateFace(c),t.moves.push(c),t.cube.isSolved())return!0}++n}return!1}),!1)}calculateCitizenScore(t){return this.measurer.add(K[2],()=>t.cube.getConfiguration().reduce((e,s,n)=>e+be(s&this.goalState[n]),0))}createSolution(t){const e=this.measurer.add(K[3],()=>new we().tune(t.moves));return this.measurer.finish(),{rotations:e,totalTime:this.measurer.getTotalTime(),data:{armageddonCounter:this.armageddonCounter,genes:t.genes,neuralNetwork:t.neuralNetwork,metrics:this.measurer.getData(K[0]),generations:this.neuroGeneticAlgorithm.getGenerationsCounter()}}}buildSolvedPocketCubeFromCornerCubelet(t){const e=new Map;return t.stickers.forEach(s=>{e.set(s.color,s.side),e.set(q(s.color),x(s.side))}),new PocketCube({colorMap:e})}}class Ne{constructor(t=30){l(this,"moves");this.moves=t}scramble(t){let e;const s=Math.floor(t.getDimension()/2),n=y(),a=[];return Array.from(new Array(this.moves)).forEach(()=>{const c=Math.floor(Math.random()*6)===0,d=Math.floor(Math.random()*2)===0,g=Math.floor(Math.random()*s);let f=Math.floor(Math.random()*n.length),m={side:f,counterClockwiseDirection:d,layer:g};for(;e!==void 0&&e.side===m.side&&e.layer===m.layer;)f=Math.floor(Math.random()*n.length),m={side:f,counterClockwiseDirection:d,layer:g};e=m,c&&(m.counterClockwiseDirection=!1,a.push(m)),a.push(m)}),a.filter((c,d)=>d<this.moves)}}class Ee{constructor(t){l(this,"mutationList");l(this,"generationsCounter");this.generationsCounter=0,this.mutationList=t}createNextGeneration(t){++this.generationsCounter;const s=t.sort((n,a)=>a.score-n.score).filter((n,a)=>a<U.elitism);return Array.from(Array(U.populationPerGeneration)).map(()=>this.createNewCitizen(s))}getGenerationsCounter(){return this.generationsCounter}createNewCitizen(t){const e=t[Math.floor(Math.random()*t.length)],s=()=>this.mutationList[Math.floor(Math.random()*this.mutationList.length)];return{cube:e.cube.clone(),genes:e.genes,goalState:[...e.goalState],newGenes:s().concat(s().concat(s())),score:NaN}}}class I{translateSide(t,e){const s=e.getAllCubelets(),n=e.getDimension(),a=10,c=(g,f,m)=>{for(const C of s){const j=C.stickers.find(P=>P.side===g&&P.x===f&&P.y===m);if(j)return j}console.log(`Sticker not found: ${o[g]}, ${f}, ${m}`)},d=[];d.push(`${(o[t]+Array.from(new Array(a)).fill(" ").join("")).substring(0,a)}`);for(let g=0;g<n;++g){let f="";for(let m=0;m<n;++m){const C=c(t,m,g);f+=O[C.color].substring(0,1)+I.mapToSubscript(`${("  "+C.id).slice(-2)}  `)}d.push(f)}return d}translateCube(t){const e=t.getDimension(),s=this.translateSide(o.UP,t),n=this.translateSide(o.LEFT,t),a=this.translateSide(o.FRONT,t),c=this.translateSide(o.RIGHT,t),d=this.translateSide(o.BACK,t),g=this.translateSide(o.DOWN,t);let f="";const m=Array.from(new Array(s[1].length)).fill(" ").join("");s.forEach(C=>{f+=m+C+`
`}),f+=n[0],f+=(m+a[0]).slice(-m.length),f+=(m+c[0]).slice(-m.length),f+=(m+d[0]).slice(-m.length)+`
`;for(let C=1;C<e+1;++C)f+=n[C],f+=a[C],f+=c[C],f+=d[C]+`
`;return g.forEach(C=>{f+=m+C+`
`}),f}convertStringToFaceRotations(t){return t.match(/((\d?)(\w)(\d?)('?))\s*/g).reduce((e,s)=>{const[n,a,c,d,g]=s.match(/(2?)(\w)(\d?)('?)/),f={side:o.UP,counterClockwiseDirection:(g==null?void 0:g.length)>0,layer:Number((d==null?void 0:d.length)>0)};switch(c.toLowerCase()){case"u":f.side=o.UP;break;case"l":f.side=o.LEFT;break;case"f":f.side=o.FRONT;break;case"r":f.side=o.RIGHT;break;case"b":f.side=o.BACK;break;case"d":f.side=o.DOWN;break;default:return e}return(a==null?void 0:a.length)>0&&e.push(f),e.push(f),e},[])}translateRotations(t,e){const s=[...t];let n=0,a="";e!=null&&e.showNumberOfMoves&&(n++,a+=`${t.length}:      `.substring(0,4));let c=s.shift();for(;c;){const d=s[0];let g=" ";d&&ae(d,c)&&(s.shift(),g="2");let f="";if(e&&e.showLayer){let m=1;c.layer!==void 0&&(m=c.layer+1),f=m.toString(),e.subscript&&(f=I.mapToSubscript(m.toString()))}a+=`${g}${o[c.side].substring(0,1)}${c.counterClockwiseDirection?"'":" "}${f}  `,(e==null?void 0:e.lineBreak)!==void 0&&n%(e==null?void 0:e.lineBreak)===(e==null?void 0:e.lineBreak)-1&&(a+=`
`),++n,c=s.shift()}return a}translateCubelets(t){let e="";return t.map(s=>{s.stickers.map(n=>{const a=O[n.color],c=o[n.side],d=I.mapToSmallTopLetters(n.id.toString()),g=`${I.mapToSubscript("("+n.x+","+n.y+")")}`;e+=`${a.substring(0,1).toUpperCase().concat(a.substring(1).toLowerCase())}: ${c}${d}${g};  `}),e+=`
`}),e}static mapToSmallTopLetters(t){const e=new Map;return e.set("0","⁰"),e.set("1","¹"),e.set("2","²"),e.set("3","³"),e.set("4","⁴"),e.set("5","⁵"),e.set("6","⁶"),e.set("7","⁷"),e.set("8","⁸"),e.set("9","⁹"),e.set(",","﹐"),t.split("").map(s=>e.has(s)?e.get(s):s).join("")}static mapToSubscript(t){const e=new Map;return e.set("0","₀"),e.set("1","₁"),e.set("2","₂"),e.set("3","₃"),e.set("4","₄"),e.set("5","₅"),e.set("6","₆"),e.set("7","₇"),e.set("8","₈"),e.set("9","₉"),e.set("0","₀"),e.set("(","₍"),e.set(")","₎"),t.split("").map(s=>e.has(s)?e.get(s):s).join("")}}var W=(i=>(i[i.NOT_MEASURED=0]="NOT_MEASURED",i[i.RUN_CITIZEN_ROTATIONS=1]="RUN_CITIZEN_ROTATIONS",i[i.CALCULATE_CITIZEN_SCORE=2]="CALCULATE_CITIZEN_SCORE",i[i.ROTATIONS_TUNING=3]="ROTATIONS_TUNING",i))(W||{});const Ae=i=>i.toString(2).replace(/0/g,"").length;class xe{constructor(t){l(this,"measurer");l(this,"initialState");l(this,"geneticAlgorithm");l(this,"citizens");l(this,"aborted");l(this,"armageddonCounter");this.measurer=new Y,this.initialState=t.clone(),this.aborted=!1,this.armageddonCounter=0,this.citizens=this.createNewPopulationFromScratch();const e=new I;this.geneticAlgorithm=new Ee([e.convertStringToFaceRotations("F"),e.convertStringToFaceRotations("F'"),e.convertStringToFaceRotations("U"),e.convertStringToFaceRotations("U'"),e.convertStringToFaceRotations("R"),e.convertStringToFaceRotations("R'"),e.convertStringToFaceRotations("B U B'"),e.convertStringToFaceRotations("U R U'"),e.convertStringToFaceRotations("F U' F'"),e.convertStringToFaceRotations("D B D'"),e.convertStringToFaceRotations("R U R' U R 2U R'"),e.convertStringToFaceRotations("U R' U' R U' R' 2U R"),e.convertStringToFaceRotations("U' R' U' R U' R' 2U R"),e.convertStringToFaceRotations("2U R' U' R U' R' 2U R"),e.convertStringToFaceRotations("L' U R' 2D R U' R' 2D 2R"),e.convertStringToFaceRotations("2R L' U R' 2D R U' R' 2D"),e.convertStringToFaceRotations("2F L' U R' 2D R U' R' 2D 2R 2F'")])}async findSolution(){return this.measurer.start(),new Promise((t,e)=>{for(;;){if(this.aborted)return e();for(let s of this.citizens)if(this.runCitizen(s))return t(this.createSolution(s));this.geneticAlgorithm.getGenerationsCounter()>U.armageddonThreshold?(++this.armageddonCounter,this.citizens=this.createNewPopulationFromScratch()):this.citizens=this.createNewPopulationFromPreviousOne()}})}abort(){this.aborted=!0}createNewPopulationFromScratch(){return Array.from(new Array(U.populationPerGeneration)).map(()=>{const t=new Ne(1).scramble(this.initialState.clone()),e=this.initialState.clone(),s=e.getCubeletsBySides(o.BACK,o.LEFT,o.DOWN)[0],n=this.buildSolvedPocketCubeFromCornerCubelet(s).getConfiguration();return{cube:e.clone(),genes:[...t],goalState:[...n],score:NaN,newGenes:[]}})}createNewPopulationFromPreviousOne(){return this.geneticAlgorithm.createNextGeneration(this.citizens.map(t=>({cube:t.cube.clone(),genes:[...t.genes],newGenes:[],score:this.calculateCitizenScore(t),goalState:t.goalState})))}runCitizen(t){t.genes=t.genes.concat(t.newGenes);const e=[];let s=this.initialState.clone();for(let n of t.genes)if(this.measurer.add(W[1],()=>{if(e.push(n),s=s.rotateFace(n),s.isSolved()){const a=e.reduce((c,d)=>c.rotateFace(d),this.initialState.clone());return console.log("proof",t.genes),console.log(e),console.log(new I().translateCube(a)),console.log(new I().translateCube(s)),t.genes=e,!0}return!1}))return!0;return!1}calculateCitizenScore(t){return this.measurer.add(W[2],()=>t.cube.getConfiguration().reduce((e,s,n)=>e+Ae(s&t.goalState[n]),0))}createSolution(t){const e=this.measurer.add(W[3],()=>t.genes);return this.measurer.finish(),console.log(new I().translateCube(t.cube)),{rotations:e,totalTime:this.measurer.getTotalTime(),data:{armageddonCounter:this.armageddonCounter,metrics:this.measurer.getData(W[0]),generations:this.geneticAlgorithm.getGenerationsCounter()}}}buildSolvedPocketCubeFromCornerCubelet(t){const e=new Map;return t.stickers.forEach(s=>{e.set(s.color,s.side),e.set(q(s.color),x(s.side))}),new w(this.initialState.getDimension(),{colorMap:e})}}const A={geneticData:{mutationRate:.05,populationPerGeneration:100,armageddonThreshold:500},neuralNetworkData:{hiddenNeurons:10,iterations:20}},U={populationPerGeneration:100,elitism:10,armageddonThreshold:10},ue={metrics:{enabled:!0},world:{debug:!1,scrambleMoves:10,scrambleRotationDuration:100,cubesCircleRay:5},renderers:{translationDuration:500,rotationDuration:250,titleDistance:8.5,cubeSize:2.5},cubeTypes:[{label:"2x2",dimension:2,instantiator:()=>new w({dimension:2}),methods:[{key:"Human",instantiator:i=>new H(new w({clone:i,dimension:2})),checked:!1,info:"Use keys 'WASDFX' combined with 'shift' to rotate cube faces"},{key:"BFS",instantiator:i=>new Ce(new w({clone:i,dimension:2})),checked:!1,info:"Breadth-first-search. Brute force"},{key:"A*",instantiator:i=>new ge(new w({clone:i,dimension:2})),checked:!0,info:"Astar. Uses number of misplaced cubies as heuristic"}]},{label:"3x3",dimension:3,instantiator:()=>new w({dimension:3}),methods:[{key:"Human",instantiator:i=>new H(new w({clone:i})),checked:!1,info:"Use keys 'WASDFX' combined with 'shift' to rotate cube faces"},{key:"NE",instantiator:i=>new ye(new w({clone:i})),checked:!1,info:`Neuro Evolutionary. Uses number of misplaced stickers as fitness function. Internal neurons: ${A.neuralNetworkData.hiddenNeurons}. Population: ${A.geneticData.populationPerGeneration}. No elitism`},{key:"GA",instantiator:i=>new xe(new w({clone:i})),checked:!0,info:`Predefined macro movements combined with genetic algorithm. Uses number of misplaced stickers as fitness function. Population: ${U.populationPerGeneration}. Elitism ${U.elitism}. Asexual reproduction`}]},{label:"4x4",dimension:4,instantiator:()=>new w({dimension:4}),methods:[{key:"Human",instantiator:i=>new H(new w({clone:i})),checked:!1,info:"Use keys 'WASDFX' combined with 'shift' and numbers to rotate cube faces"}]},{label:"5x5",dimension:5,instantiator:()=>new w({dimension:5}),methods:[{key:"Human",instantiator:i=>new H(new w({clone:i})),checked:!1,info:"Use keys 'WASDFX' combined with 'shift' and numbers to rotate cube faces"}]}]},Oe=i=>{for(let t of ue.cubeTypes)if(t.label.toLowerCase()===i.label.toLowerCase()){for(let e of t.methods)if(e.key.toLowerCase()===i.solverTag.toLowerCase())return e;return}};let $;self.onmessage=async i=>{if(i.data.abort)$.abort();else{const t=i.data.solverTag.toLowerCase(),e=Oe(i.data);if(t&&e)if(i.data.cube)try{$=e.instantiator(i.data.cube);const s=await $.findSolution();self.postMessage({solution:JSON.stringify(s),solverKey:t})}catch(s){console.log(`Solver '${i.data.label}.${t}' aborted`,s)}else if(i.data.keyboardEvent){if($ instanceof H){const s=await $.readKeys(i.data.keyboardEvent);s!==void 0&&self.postMessage({faceRotation:s,solverKey:t})}}else self.postMessage({error:`Command for '${i.data}' not found`,solverTag:i.data.solverTag});else self.postMessage({error:`Solver '${i.data.solverTag}' not found`,solverTag:i.data.solverTag})}}})();
